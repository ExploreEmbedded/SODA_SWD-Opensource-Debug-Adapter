/*
 * Copyright (c) 2014, Freescale Semiconductor, Inc.
 * All rights reserved.
 *
 * THIS SOFTWARE IS PROVIDED BY FREESCALE "AS IS" AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
 * SHALL FREESCALE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
 * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
 * OF SUCH DAMAGE.
 */
/*
 * WARNING! DO NOT EDIT THIS FILE DIRECTLY!
 *
 * This file was generated automatically and any changes may be lost.
 */
#ifndef __HW_LMEM_REGISTERS_H__
#define __HW_LMEM_REGISTERS_H__

#include "MK70F12.h"
#include "fsl_bitband.h"

/*
 * MK70F12 LMEM
 *
 * Local Memory Controller
 *
 * Registers defined in this header file:
 * - HW_LMEM_PCCCR - Cache control register
 * - HW_LMEM_PCCLCR - Cache line control register
 * - HW_LMEM_PCCSAR - Cache search address register
 * - HW_LMEM_PCCCVR - Cache read/write value register
 * - HW_LMEM_PCCRMR - Cache regions mode register
 * - HW_LMEM_PSCCR - Cache control register
 * - HW_LMEM_PSCLCR - Cache line control register
 * - HW_LMEM_PSCSAR - Cache search address register
 * - HW_LMEM_PSCCVR - Cache read/write value register
 * - HW_LMEM_PSCRMR - Cache regions mode register
 *
 * - hw_lmem_t - Struct containing all module registers.
 */

#define HW_LMEM_INSTANCE_COUNT (1U) /*!< Number of instances of the LMEM module. */

/*******************************************************************************
 * HW_LMEM_PCCCR - Cache control register
 ******************************************************************************/

/*!
 * @brief HW_LMEM_PCCCR - Cache control register (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_lmem_pcccr
{
    uint32_t U;
    struct _hw_lmem_pcccr_bitfields
    {
        uint32_t ENCACHE : 1;          /*!< [0] Cache enable */
        uint32_t ENWRBUF : 1;          /*!< [1] Enable Write Buffer */
        uint32_t RESERVED0 : 22;       /*!< [23:2]  */
        uint32_t INVW0 : 1;            /*!< [24] Invalidate Way 0 */
        uint32_t PUSHW0 : 1;           /*!< [25] Push Way 0 */
        uint32_t INVW1 : 1;            /*!< [26] Invalidate Way 1 */
        uint32_t PUSHW1 : 1;           /*!< [27] Push Way 1 */
        uint32_t RESERVED1 : 3;        /*!< [30:28]  */
        uint32_t GO : 1;               /*!< [31] Initiate Cache Command */
    } B;
} hw_lmem_pcccr_t;

/*!
 * @name Constants and macros for entire LMEM_PCCCR register
 */
/*@{*/
#define HW_LMEM_PCCCR_ADDR(x)    ((x) + 0x0U)

#define HW_LMEM_PCCCR(x)         (*(__IO hw_lmem_pcccr_t *) HW_LMEM_PCCCR_ADDR(x))
#define HW_LMEM_PCCCR_RD(x)      (HW_LMEM_PCCCR(x).U)
#define HW_LMEM_PCCCR_WR(x, v)   (HW_LMEM_PCCCR(x).U = (v))
#define HW_LMEM_PCCCR_SET(x, v)  (HW_LMEM_PCCCR_WR(x, HW_LMEM_PCCCR_RD(x) |  (v)))
#define HW_LMEM_PCCCR_CLR(x, v)  (HW_LMEM_PCCCR_WR(x, HW_LMEM_PCCCR_RD(x) & ~(v)))
#define HW_LMEM_PCCCR_TOG(x, v)  (HW_LMEM_PCCCR_WR(x, HW_LMEM_PCCCR_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual LMEM_PCCCR bitfields
 */

/*!
 * @name Register LMEM_PCCCR, field ENCACHE[0] (RW)
 *
 * Values:
 * - 0 - Cache disabled
 * - 1 - Cache enabled
 */
/*@{*/
#define BP_LMEM_PCCCR_ENCACHE (0U)         /*!< Bit position for LMEM_PCCCR_ENCACHE. */
#define BM_LMEM_PCCCR_ENCACHE (0x00000001U) /*!< Bit mask for LMEM_PCCCR_ENCACHE. */
#define BS_LMEM_PCCCR_ENCACHE (1U)         /*!< Bit field size in bits for LMEM_PCCCR_ENCACHE. */

/*! @brief Read current value of the LMEM_PCCCR_ENCACHE field. */
#define BR_LMEM_PCCCR_ENCACHE(x) (BITBAND_ACCESS32(HW_LMEM_PCCCR_ADDR(x), BP_LMEM_PCCCR_ENCACHE))

/*! @brief Format value for bitfield LMEM_PCCCR_ENCACHE. */
#define BF_LMEM_PCCCR_ENCACHE(v) ((uint32_t)((uint32_t)(v) << BP_LMEM_PCCCR_ENCACHE) & BM_LMEM_PCCCR_ENCACHE)

/*! @brief Set the ENCACHE field to a new value. */
#define BW_LMEM_PCCCR_ENCACHE(x, v) (BITBAND_ACCESS32(HW_LMEM_PCCCR_ADDR(x), BP_LMEM_PCCCR_ENCACHE) = (v))
/*@}*/

/*!
 * @name Register LMEM_PCCCR, field ENWRBUF[1] (RW)
 *
 * Values:
 * - 0 - Write buffer disabled
 * - 1 - Write buffer enabled
 */
/*@{*/
#define BP_LMEM_PCCCR_ENWRBUF (1U)         /*!< Bit position for LMEM_PCCCR_ENWRBUF. */
#define BM_LMEM_PCCCR_ENWRBUF (0x00000002U) /*!< Bit mask for LMEM_PCCCR_ENWRBUF. */
#define BS_LMEM_PCCCR_ENWRBUF (1U)         /*!< Bit field size in bits for LMEM_PCCCR_ENWRBUF. */

/*! @brief Read current value of the LMEM_PCCCR_ENWRBUF field. */
#define BR_LMEM_PCCCR_ENWRBUF(x) (BITBAND_ACCESS32(HW_LMEM_PCCCR_ADDR(x), BP_LMEM_PCCCR_ENWRBUF))

/*! @brief Format value for bitfield LMEM_PCCCR_ENWRBUF. */
#define BF_LMEM_PCCCR_ENWRBUF(v) ((uint32_t)((uint32_t)(v) << BP_LMEM_PCCCR_ENWRBUF) & BM_LMEM_PCCCR_ENWRBUF)

/*! @brief Set the ENWRBUF field to a new value. */
#define BW_LMEM_PCCCR_ENWRBUF(x, v) (BITBAND_ACCESS32(HW_LMEM_PCCCR_ADDR(x), BP_LMEM_PCCCR_ENWRBUF) = (v))
/*@}*/

/*!
 * @name Register LMEM_PCCCR, field INVW0[24] (RW)
 *
 * If the PUSHW0 and INVW0 bits are set, then after setting the GO bit, push all
 * modified lines in way 0 and invalidate all lines in way 0 (clear way 0).
 *
 * Values:
 * - 0 - No operation
 * - 1 - When setting the GO bit, invalidate all lines in way 0.
 */
/*@{*/
#define BP_LMEM_PCCCR_INVW0  (24U)         /*!< Bit position for LMEM_PCCCR_INVW0. */
#define BM_LMEM_PCCCR_INVW0  (0x01000000U) /*!< Bit mask for LMEM_PCCCR_INVW0. */
#define BS_LMEM_PCCCR_INVW0  (1U)          /*!< Bit field size in bits for LMEM_PCCCR_INVW0. */

/*! @brief Read current value of the LMEM_PCCCR_INVW0 field. */
#define BR_LMEM_PCCCR_INVW0(x) (BITBAND_ACCESS32(HW_LMEM_PCCCR_ADDR(x), BP_LMEM_PCCCR_INVW0))

/*! @brief Format value for bitfield LMEM_PCCCR_INVW0. */
#define BF_LMEM_PCCCR_INVW0(v) ((uint32_t)((uint32_t)(v) << BP_LMEM_PCCCR_INVW0) & BM_LMEM_PCCCR_INVW0)

/*! @brief Set the INVW0 field to a new value. */
#define BW_LMEM_PCCCR_INVW0(x, v) (BITBAND_ACCESS32(HW_LMEM_PCCCR_ADDR(x), BP_LMEM_PCCCR_INVW0) = (v))
/*@}*/

/*!
 * @name Register LMEM_PCCCR, field PUSHW0[25] (RW)
 *
 * Values:
 * - 0 - No operation
 * - 1 - When setting the GO bit, push all modified lines in way 0
 */
/*@{*/
#define BP_LMEM_PCCCR_PUSHW0 (25U)         /*!< Bit position for LMEM_PCCCR_PUSHW0. */
#define BM_LMEM_PCCCR_PUSHW0 (0x02000000U) /*!< Bit mask for LMEM_PCCCR_PUSHW0. */
#define BS_LMEM_PCCCR_PUSHW0 (1U)          /*!< Bit field size in bits for LMEM_PCCCR_PUSHW0. */

/*! @brief Read current value of the LMEM_PCCCR_PUSHW0 field. */
#define BR_LMEM_PCCCR_PUSHW0(x) (BITBAND_ACCESS32(HW_LMEM_PCCCR_ADDR(x), BP_LMEM_PCCCR_PUSHW0))

/*! @brief Format value for bitfield LMEM_PCCCR_PUSHW0. */
#define BF_LMEM_PCCCR_PUSHW0(v) ((uint32_t)((uint32_t)(v) << BP_LMEM_PCCCR_PUSHW0) & BM_LMEM_PCCCR_PUSHW0)

/*! @brief Set the PUSHW0 field to a new value. */
#define BW_LMEM_PCCCR_PUSHW0(x, v) (BITBAND_ACCESS32(HW_LMEM_PCCCR_ADDR(x), BP_LMEM_PCCCR_PUSHW0) = (v))
/*@}*/

/*!
 * @name Register LMEM_PCCCR, field INVW1[26] (RW)
 *
 * If the PUSHW1 and INVW1 bits are set, then after setting the GO bit, push all
 * modified lines in way 1 and invalidate all lines in way 1 (clear way 1).
 *
 * Values:
 * - 0 - No operation
 * - 1 - When setting the GO bit, invalidate all lines in way 1
 */
/*@{*/
#define BP_LMEM_PCCCR_INVW1  (26U)         /*!< Bit position for LMEM_PCCCR_INVW1. */
#define BM_LMEM_PCCCR_INVW1  (0x04000000U) /*!< Bit mask for LMEM_PCCCR_INVW1. */
#define BS_LMEM_PCCCR_INVW1  (1U)          /*!< Bit field size in bits for LMEM_PCCCR_INVW1. */

/*! @brief Read current value of the LMEM_PCCCR_INVW1 field. */
#define BR_LMEM_PCCCR_INVW1(x) (BITBAND_ACCESS32(HW_LMEM_PCCCR_ADDR(x), BP_LMEM_PCCCR_INVW1))

/*! @brief Format value for bitfield LMEM_PCCCR_INVW1. */
#define BF_LMEM_PCCCR_INVW1(v) ((uint32_t)((uint32_t)(v) << BP_LMEM_PCCCR_INVW1) & BM_LMEM_PCCCR_INVW1)

/*! @brief Set the INVW1 field to a new value. */
#define BW_LMEM_PCCCR_INVW1(x, v) (BITBAND_ACCESS32(HW_LMEM_PCCCR_ADDR(x), BP_LMEM_PCCCR_INVW1) = (v))
/*@}*/

/*!
 * @name Register LMEM_PCCCR, field PUSHW1[27] (RW)
 *
 * Values:
 * - 0 - No operation
 * - 1 - When setting the GO bit, push all modified lines in way 1
 */
/*@{*/
#define BP_LMEM_PCCCR_PUSHW1 (27U)         /*!< Bit position for LMEM_PCCCR_PUSHW1. */
#define BM_LMEM_PCCCR_PUSHW1 (0x08000000U) /*!< Bit mask for LMEM_PCCCR_PUSHW1. */
#define BS_LMEM_PCCCR_PUSHW1 (1U)          /*!< Bit field size in bits for LMEM_PCCCR_PUSHW1. */

/*! @brief Read current value of the LMEM_PCCCR_PUSHW1 field. */
#define BR_LMEM_PCCCR_PUSHW1(x) (BITBAND_ACCESS32(HW_LMEM_PCCCR_ADDR(x), BP_LMEM_PCCCR_PUSHW1))

/*! @brief Format value for bitfield LMEM_PCCCR_PUSHW1. */
#define BF_LMEM_PCCCR_PUSHW1(v) ((uint32_t)((uint32_t)(v) << BP_LMEM_PCCCR_PUSHW1) & BM_LMEM_PCCCR_PUSHW1)

/*! @brief Set the PUSHW1 field to a new value. */
#define BW_LMEM_PCCCR_PUSHW1(x, v) (BITBAND_ACCESS32(HW_LMEM_PCCCR_ADDR(x), BP_LMEM_PCCCR_PUSHW1) = (v))
/*@}*/

/*!
 * @name Register LMEM_PCCCR, field GO[31] (RW)
 *
 * Setting this bit initiates the cache command indicated by bits 27-24. Reading
 * this bit indicates if a command is active This bit stays set until the
 * command completes. Writing zero has no effect.
 *
 * Values:
 * - 0 - Write: no effect. Read: no cache command active.
 * - 1 - Write: initiate command indicated by bits 27-24. Read: cache command
 *     active.
 */
/*@{*/
#define BP_LMEM_PCCCR_GO     (31U)         /*!< Bit position for LMEM_PCCCR_GO. */
#define BM_LMEM_PCCCR_GO     (0x80000000U) /*!< Bit mask for LMEM_PCCCR_GO. */
#define BS_LMEM_PCCCR_GO     (1U)          /*!< Bit field size in bits for LMEM_PCCCR_GO. */

/*! @brief Read current value of the LMEM_PCCCR_GO field. */
#define BR_LMEM_PCCCR_GO(x)  (BITBAND_ACCESS32(HW_LMEM_PCCCR_ADDR(x), BP_LMEM_PCCCR_GO))

/*! @brief Format value for bitfield LMEM_PCCCR_GO. */
#define BF_LMEM_PCCCR_GO(v)  ((uint32_t)((uint32_t)(v) << BP_LMEM_PCCCR_GO) & BM_LMEM_PCCCR_GO)

/*! @brief Set the GO field to a new value. */
#define BW_LMEM_PCCCR_GO(x, v) (BITBAND_ACCESS32(HW_LMEM_PCCCR_ADDR(x), BP_LMEM_PCCCR_GO) = (v))
/*@}*/

/*******************************************************************************
 * HW_LMEM_PCCLCR - Cache line control register
 ******************************************************************************/

/*!
 * @brief HW_LMEM_PCCLCR - Cache line control register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register defines specific line-sized cache operations to be performed
 * using a specific cache line address or a physical address. If a physical address
 * is specified, both ways of the cache are searched, and the command is only
 * performed on the way which hits.
 */
typedef union _hw_lmem_pcclcr
{
    uint32_t U;
    struct _hw_lmem_pcclcr_bitfields
    {
        uint32_t LGO : 1;              /*!< [0] Initiate Cache Line Command */
        uint32_t RESERVED0 : 1;        /*!< [1]  */
        uint32_t CACHEADDR : 10;       /*!< [11:2] Cache address */
        uint32_t RESERVED1 : 2;        /*!< [13:12]  */
        uint32_t WSEL : 1;             /*!< [14] Way select */
        uint32_t RESERVED2 : 1;        /*!< [15]  */
        uint32_t TDSEL : 1;            /*!< [16] Tag/Data Select */
        uint32_t RESERVED3 : 3;        /*!< [19:17]  */
        uint32_t LCIVB : 1;            /*!< [20] Line Command Initial Valid Bit */
        uint32_t LCIMB : 1;            /*!< [21] Line Command Initial Modified Bit */
        uint32_t LCWAY : 1;            /*!< [22] Line Command Way */
        uint32_t RESERVED4 : 1;        /*!< [23]  */
        uint32_t LCMD : 2;             /*!< [25:24] Line Command */
        uint32_t LADSEL : 1;           /*!< [26] Line Address Select */
        uint32_t LACC : 1;             /*!< [27] Line access type */
        uint32_t RESERVED5 : 4;        /*!< [31:28]  */
    } B;
} hw_lmem_pcclcr_t;

/*!
 * @name Constants and macros for entire LMEM_PCCLCR register
 */
/*@{*/
#define HW_LMEM_PCCLCR_ADDR(x)   ((x) + 0x4U)

#define HW_LMEM_PCCLCR(x)        (*(__IO hw_lmem_pcclcr_t *) HW_LMEM_PCCLCR_ADDR(x))
#define HW_LMEM_PCCLCR_RD(x)     (HW_LMEM_PCCLCR(x).U)
#define HW_LMEM_PCCLCR_WR(x, v)  (HW_LMEM_PCCLCR(x).U = (v))
#define HW_LMEM_PCCLCR_SET(x, v) (HW_LMEM_PCCLCR_WR(x, HW_LMEM_PCCLCR_RD(x) |  (v)))
#define HW_LMEM_PCCLCR_CLR(x, v) (HW_LMEM_PCCLCR_WR(x, HW_LMEM_PCCLCR_RD(x) & ~(v)))
#define HW_LMEM_PCCLCR_TOG(x, v) (HW_LMEM_PCCLCR_WR(x, HW_LMEM_PCCLCR_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual LMEM_PCCLCR bitfields
 */

/*!
 * @name Register LMEM_PCCLCR, field LGO[0] (RW)
 *
 * Setting this bit initiates the cache line command indicated by bits 27-24.
 * Reading this bit indicates if a line command is active This bit stays set until
 * the command completes. Writing zero has no effect. This bit is shared with
 * CSAR[LGO]
 *
 * Values:
 * - 0 - Write: no effect. Read: no line command active.
 * - 1 - Write: initiate line command indicated by bits 27-24. Read: line
 *     command active.
 */
/*@{*/
#define BP_LMEM_PCCLCR_LGO   (0U)          /*!< Bit position for LMEM_PCCLCR_LGO. */
#define BM_LMEM_PCCLCR_LGO   (0x00000001U) /*!< Bit mask for LMEM_PCCLCR_LGO. */
#define BS_LMEM_PCCLCR_LGO   (1U)          /*!< Bit field size in bits for LMEM_PCCLCR_LGO. */

/*! @brief Read current value of the LMEM_PCCLCR_LGO field. */
#define BR_LMEM_PCCLCR_LGO(x) (BITBAND_ACCESS32(HW_LMEM_PCCLCR_ADDR(x), BP_LMEM_PCCLCR_LGO))

/*! @brief Format value for bitfield LMEM_PCCLCR_LGO. */
#define BF_LMEM_PCCLCR_LGO(v) ((uint32_t)((uint32_t)(v) << BP_LMEM_PCCLCR_LGO) & BM_LMEM_PCCLCR_LGO)

/*! @brief Set the LGO field to a new value. */
#define BW_LMEM_PCCLCR_LGO(x, v) (BITBAND_ACCESS32(HW_LMEM_PCCLCR_ADDR(x), BP_LMEM_PCCLCR_LGO) = (v))
/*@}*/

/*!
 * @name Register LMEM_PCCLCR, field CACHEADDR[11:2] (RW)
 *
 * CLCR[11:4] bits are used to access the tag arrays CLCR[11:2] bits are used to
 * access the data arrays
 */
/*@{*/
#define BP_LMEM_PCCLCR_CACHEADDR (2U)      /*!< Bit position for LMEM_PCCLCR_CACHEADDR. */
#define BM_LMEM_PCCLCR_CACHEADDR (0x00000FFCU) /*!< Bit mask for LMEM_PCCLCR_CACHEADDR. */
#define BS_LMEM_PCCLCR_CACHEADDR (10U)     /*!< Bit field size in bits for LMEM_PCCLCR_CACHEADDR. */

/*! @brief Read current value of the LMEM_PCCLCR_CACHEADDR field. */
#define BR_LMEM_PCCLCR_CACHEADDR(x) (HW_LMEM_PCCLCR(x).B.CACHEADDR)

/*! @brief Format value for bitfield LMEM_PCCLCR_CACHEADDR. */
#define BF_LMEM_PCCLCR_CACHEADDR(v) ((uint32_t)((uint32_t)(v) << BP_LMEM_PCCLCR_CACHEADDR) & BM_LMEM_PCCLCR_CACHEADDR)

/*! @brief Set the CACHEADDR field to a new value. */
#define BW_LMEM_PCCLCR_CACHEADDR(x, v) (HW_LMEM_PCCLCR_WR(x, (HW_LMEM_PCCLCR_RD(x) & ~BM_LMEM_PCCLCR_CACHEADDR) | BF_LMEM_PCCLCR_CACHEADDR(v)))
/*@}*/

/*!
 * @name Register LMEM_PCCLCR, field WSEL[14] (RW)
 *
 * Selects the way for line commands.
 *
 * Values:
 * - 0 - Way 0
 * - 1 - Way 1
 */
/*@{*/
#define BP_LMEM_PCCLCR_WSEL  (14U)         /*!< Bit position for LMEM_PCCLCR_WSEL. */
#define BM_LMEM_PCCLCR_WSEL  (0x00004000U) /*!< Bit mask for LMEM_PCCLCR_WSEL. */
#define BS_LMEM_PCCLCR_WSEL  (1U)          /*!< Bit field size in bits for LMEM_PCCLCR_WSEL. */

/*! @brief Read current value of the LMEM_PCCLCR_WSEL field. */
#define BR_LMEM_PCCLCR_WSEL(x) (BITBAND_ACCESS32(HW_LMEM_PCCLCR_ADDR(x), BP_LMEM_PCCLCR_WSEL))

/*! @brief Format value for bitfield LMEM_PCCLCR_WSEL. */
#define BF_LMEM_PCCLCR_WSEL(v) ((uint32_t)((uint32_t)(v) << BP_LMEM_PCCLCR_WSEL) & BM_LMEM_PCCLCR_WSEL)

/*! @brief Set the WSEL field to a new value. */
#define BW_LMEM_PCCLCR_WSEL(x, v) (BITBAND_ACCESS32(HW_LMEM_PCCLCR_ADDR(x), BP_LMEM_PCCLCR_WSEL) = (v))
/*@}*/

/*!
 * @name Register LMEM_PCCLCR, field TDSEL[16] (RW)
 *
 * Selects tag or data for search and read or write commands.
 *
 * Values:
 * - 0 - Data
 * - 1 - Tag
 */
/*@{*/
#define BP_LMEM_PCCLCR_TDSEL (16U)         /*!< Bit position for LMEM_PCCLCR_TDSEL. */
#define BM_LMEM_PCCLCR_TDSEL (0x00010000U) /*!< Bit mask for LMEM_PCCLCR_TDSEL. */
#define BS_LMEM_PCCLCR_TDSEL (1U)          /*!< Bit field size in bits for LMEM_PCCLCR_TDSEL. */

/*! @brief Read current value of the LMEM_PCCLCR_TDSEL field. */
#define BR_LMEM_PCCLCR_TDSEL(x) (BITBAND_ACCESS32(HW_LMEM_PCCLCR_ADDR(x), BP_LMEM_PCCLCR_TDSEL))

/*! @brief Format value for bitfield LMEM_PCCLCR_TDSEL. */
#define BF_LMEM_PCCLCR_TDSEL(v) ((uint32_t)((uint32_t)(v) << BP_LMEM_PCCLCR_TDSEL) & BM_LMEM_PCCLCR_TDSEL)

/*! @brief Set the TDSEL field to a new value. */
#define BW_LMEM_PCCLCR_TDSEL(x, v) (BITBAND_ACCESS32(HW_LMEM_PCCLCR_ADDR(x), BP_LMEM_PCCLCR_TDSEL) = (v))
/*@}*/

/*!
 * @name Register LMEM_PCCLCR, field LCIVB[20] (RO)
 *
 * If command used cache address and way, then this bit shows the initial state
 * of the valid bit If command used physical address and a hit, then this bit
 * shows the initial state of the valid bit. If a miss, this bit reads zero.
 */
/*@{*/
#define BP_LMEM_PCCLCR_LCIVB (20U)         /*!< Bit position for LMEM_PCCLCR_LCIVB. */
#define BM_LMEM_PCCLCR_LCIVB (0x00100000U) /*!< Bit mask for LMEM_PCCLCR_LCIVB. */
#define BS_LMEM_PCCLCR_LCIVB (1U)          /*!< Bit field size in bits for LMEM_PCCLCR_LCIVB. */

/*! @brief Read current value of the LMEM_PCCLCR_LCIVB field. */
#define BR_LMEM_PCCLCR_LCIVB(x) (BITBAND_ACCESS32(HW_LMEM_PCCLCR_ADDR(x), BP_LMEM_PCCLCR_LCIVB))
/*@}*/

/*!
 * @name Register LMEM_PCCLCR, field LCIMB[21] (RO)
 *
 * If command used cache address and way, then this bit shows the initial state
 * of the modified bit If command used physical address and a hit, then this bit
 * shows the initial state of the modified bit. If a miss, this bit reads zero.
 */
/*@{*/
#define BP_LMEM_PCCLCR_LCIMB (21U)         /*!< Bit position for LMEM_PCCLCR_LCIMB. */
#define BM_LMEM_PCCLCR_LCIMB (0x00200000U) /*!< Bit mask for LMEM_PCCLCR_LCIMB. */
#define BS_LMEM_PCCLCR_LCIMB (1U)          /*!< Bit field size in bits for LMEM_PCCLCR_LCIMB. */

/*! @brief Read current value of the LMEM_PCCLCR_LCIMB field. */
#define BR_LMEM_PCCLCR_LCIMB(x) (BITBAND_ACCESS32(HW_LMEM_PCCLCR_ADDR(x), BP_LMEM_PCCLCR_LCIMB))
/*@}*/

/*!
 * @name Register LMEM_PCCLCR, field LCWAY[22] (RO)
 *
 * Indicates the way used by the line command.
 */
/*@{*/
#define BP_LMEM_PCCLCR_LCWAY (22U)         /*!< Bit position for LMEM_PCCLCR_LCWAY. */
#define BM_LMEM_PCCLCR_LCWAY (0x00400000U) /*!< Bit mask for LMEM_PCCLCR_LCWAY. */
#define BS_LMEM_PCCLCR_LCWAY (1U)          /*!< Bit field size in bits for LMEM_PCCLCR_LCWAY. */

/*! @brief Read current value of the LMEM_PCCLCR_LCWAY field. */
#define BR_LMEM_PCCLCR_LCWAY(x) (BITBAND_ACCESS32(HW_LMEM_PCCLCR_ADDR(x), BP_LMEM_PCCLCR_LCWAY))
/*@}*/

/*!
 * @name Register LMEM_PCCLCR, field LCMD[25:24] (RW)
 *
 * Values:
 * - 00 - Search and read or write
 * - 01 - Invalidate
 * - 10 - Push
 * - 11 - Clear
 */
/*@{*/
#define BP_LMEM_PCCLCR_LCMD  (24U)         /*!< Bit position for LMEM_PCCLCR_LCMD. */
#define BM_LMEM_PCCLCR_LCMD  (0x03000000U) /*!< Bit mask for LMEM_PCCLCR_LCMD. */
#define BS_LMEM_PCCLCR_LCMD  (2U)          /*!< Bit field size in bits for LMEM_PCCLCR_LCMD. */

/*! @brief Read current value of the LMEM_PCCLCR_LCMD field. */
#define BR_LMEM_PCCLCR_LCMD(x) (HW_LMEM_PCCLCR(x).B.LCMD)

/*! @brief Format value for bitfield LMEM_PCCLCR_LCMD. */
#define BF_LMEM_PCCLCR_LCMD(v) ((uint32_t)((uint32_t)(v) << BP_LMEM_PCCLCR_LCMD) & BM_LMEM_PCCLCR_LCMD)

/*! @brief Set the LCMD field to a new value. */
#define BW_LMEM_PCCLCR_LCMD(x, v) (HW_LMEM_PCCLCR_WR(x, (HW_LMEM_PCCLCR_RD(x) & ~BM_LMEM_PCCLCR_LCMD) | BF_LMEM_PCCLCR_LCMD(v)))
/*@}*/

/*!
 * @name Register LMEM_PCCLCR, field LADSEL[26] (RW)
 *
 * When using the cache address, the way must also be specified in CLCR[WSEL].
 * When using the physical address, both ways are searched and the command is
 * performed only if a hit.
 *
 * Values:
 * - 0 - Cache address
 * - 1 - Physical address
 */
/*@{*/
#define BP_LMEM_PCCLCR_LADSEL (26U)        /*!< Bit position for LMEM_PCCLCR_LADSEL. */
#define BM_LMEM_PCCLCR_LADSEL (0x04000000U) /*!< Bit mask for LMEM_PCCLCR_LADSEL. */
#define BS_LMEM_PCCLCR_LADSEL (1U)         /*!< Bit field size in bits for LMEM_PCCLCR_LADSEL. */

/*! @brief Read current value of the LMEM_PCCLCR_LADSEL field. */
#define BR_LMEM_PCCLCR_LADSEL(x) (BITBAND_ACCESS32(HW_LMEM_PCCLCR_ADDR(x), BP_LMEM_PCCLCR_LADSEL))

/*! @brief Format value for bitfield LMEM_PCCLCR_LADSEL. */
#define BF_LMEM_PCCLCR_LADSEL(v) ((uint32_t)((uint32_t)(v) << BP_LMEM_PCCLCR_LADSEL) & BM_LMEM_PCCLCR_LADSEL)

/*! @brief Set the LADSEL field to a new value. */
#define BW_LMEM_PCCLCR_LADSEL(x, v) (BITBAND_ACCESS32(HW_LMEM_PCCLCR_ADDR(x), BP_LMEM_PCCLCR_LADSEL) = (v))
/*@}*/

/*!
 * @name Register LMEM_PCCLCR, field LACC[27] (RW)
 *
 * Values:
 * - 0 - Read
 * - 1 - Write
 */
/*@{*/
#define BP_LMEM_PCCLCR_LACC  (27U)         /*!< Bit position for LMEM_PCCLCR_LACC. */
#define BM_LMEM_PCCLCR_LACC  (0x08000000U) /*!< Bit mask for LMEM_PCCLCR_LACC. */
#define BS_LMEM_PCCLCR_LACC  (1U)          /*!< Bit field size in bits for LMEM_PCCLCR_LACC. */

/*! @brief Read current value of the LMEM_PCCLCR_LACC field. */
#define BR_LMEM_PCCLCR_LACC(x) (BITBAND_ACCESS32(HW_LMEM_PCCLCR_ADDR(x), BP_LMEM_PCCLCR_LACC))

/*! @brief Format value for bitfield LMEM_PCCLCR_LACC. */
#define BF_LMEM_PCCLCR_LACC(v) ((uint32_t)((uint32_t)(v) << BP_LMEM_PCCLCR_LACC) & BM_LMEM_PCCLCR_LACC)

/*! @brief Set the LACC field to a new value. */
#define BW_LMEM_PCCLCR_LACC(x, v) (BITBAND_ACCESS32(HW_LMEM_PCCLCR_ADDR(x), BP_LMEM_PCCLCR_LACC) = (v))
/*@}*/

/*******************************************************************************
 * HW_LMEM_PCCSAR - Cache search address register
 ******************************************************************************/

/*!
 * @brief HW_LMEM_PCCSAR - Cache search address register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The CSAR register is used to define the explicit cache address or the
 * physical address for line-sized commands specified in the CLCR[LADSEL] bit.
 */
typedef union _hw_lmem_pccsar
{
    uint32_t U;
    struct _hw_lmem_pccsar_bitfields
    {
        uint32_t LGO : 1;              /*!< [0] Initiate Cache Line Command */
        uint32_t RESERVED0 : 1;        /*!< [1]  */
        uint32_t PHYADDR : 30;         /*!< [31:2] Physical Address */
    } B;
} hw_lmem_pccsar_t;

/*!
 * @name Constants and macros for entire LMEM_PCCSAR register
 */
/*@{*/
#define HW_LMEM_PCCSAR_ADDR(x)   ((x) + 0x8U)

#define HW_LMEM_PCCSAR(x)        (*(__IO hw_lmem_pccsar_t *) HW_LMEM_PCCSAR_ADDR(x))
#define HW_LMEM_PCCSAR_RD(x)     (HW_LMEM_PCCSAR(x).U)
#define HW_LMEM_PCCSAR_WR(x, v)  (HW_LMEM_PCCSAR(x).U = (v))
#define HW_LMEM_PCCSAR_SET(x, v) (HW_LMEM_PCCSAR_WR(x, HW_LMEM_PCCSAR_RD(x) |  (v)))
#define HW_LMEM_PCCSAR_CLR(x, v) (HW_LMEM_PCCSAR_WR(x, HW_LMEM_PCCSAR_RD(x) & ~(v)))
#define HW_LMEM_PCCSAR_TOG(x, v) (HW_LMEM_PCCSAR_WR(x, HW_LMEM_PCCSAR_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual LMEM_PCCSAR bitfields
 */

/*!
 * @name Register LMEM_PCCSAR, field LGO[0] (RW)
 *
 * Setting this bit initiates the cache line command indicated by bits 27-24.
 * Reading this bit indicates if a line command is active This bit stays set until
 * the command completes. Writing zero has no effect. This bit is shared with
 * CLCR[LGO]
 *
 * Values:
 * - 0 - Write: no effect. Read: no line command active.
 * - 1 - Write: initiate line command indicated by bits CLCR[27:24]. Read: line
 *     command active.
 */
/*@{*/
#define BP_LMEM_PCCSAR_LGO   (0U)          /*!< Bit position for LMEM_PCCSAR_LGO. */
#define BM_LMEM_PCCSAR_LGO   (0x00000001U) /*!< Bit mask for LMEM_PCCSAR_LGO. */
#define BS_LMEM_PCCSAR_LGO   (1U)          /*!< Bit field size in bits for LMEM_PCCSAR_LGO. */

/*! @brief Read current value of the LMEM_PCCSAR_LGO field. */
#define BR_LMEM_PCCSAR_LGO(x) (BITBAND_ACCESS32(HW_LMEM_PCCSAR_ADDR(x), BP_LMEM_PCCSAR_LGO))

/*! @brief Format value for bitfield LMEM_PCCSAR_LGO. */
#define BF_LMEM_PCCSAR_LGO(v) ((uint32_t)((uint32_t)(v) << BP_LMEM_PCCSAR_LGO) & BM_LMEM_PCCSAR_LGO)

/*! @brief Set the LGO field to a new value. */
#define BW_LMEM_PCCSAR_LGO(x, v) (BITBAND_ACCESS32(HW_LMEM_PCCSAR_ADDR(x), BP_LMEM_PCCSAR_LGO) = (v))
/*@}*/

/*!
 * @name Register LMEM_PCCSAR, field PHYADDR[31:2] (RW)
 *
 * PHYADDR represents bits [31:2] of the system address. CSAR[31:12] bits are
 * used for tag compare CSAR[11:4] bits are used to access the tag arrays
 * CSAR[11:2] bits are used to access the data arrays
 */
/*@{*/
#define BP_LMEM_PCCSAR_PHYADDR (2U)        /*!< Bit position for LMEM_PCCSAR_PHYADDR. */
#define BM_LMEM_PCCSAR_PHYADDR (0xFFFFFFFCU) /*!< Bit mask for LMEM_PCCSAR_PHYADDR. */
#define BS_LMEM_PCCSAR_PHYADDR (30U)       /*!< Bit field size in bits for LMEM_PCCSAR_PHYADDR. */

/*! @brief Read current value of the LMEM_PCCSAR_PHYADDR field. */
#define BR_LMEM_PCCSAR_PHYADDR(x) (HW_LMEM_PCCSAR(x).B.PHYADDR)

/*! @brief Format value for bitfield LMEM_PCCSAR_PHYADDR. */
#define BF_LMEM_PCCSAR_PHYADDR(v) ((uint32_t)((uint32_t)(v) << BP_LMEM_PCCSAR_PHYADDR) & BM_LMEM_PCCSAR_PHYADDR)

/*! @brief Set the PHYADDR field to a new value. */
#define BW_LMEM_PCCSAR_PHYADDR(x, v) (HW_LMEM_PCCSAR_WR(x, (HW_LMEM_PCCSAR_RD(x) & ~BM_LMEM_PCCSAR_PHYADDR) | BF_LMEM_PCCSAR_PHYADDR(v)))
/*@}*/

/*******************************************************************************
 * HW_LMEM_PCCCVR - Cache read/write value register
 ******************************************************************************/

/*!
 * @brief HW_LMEM_PCCCVR - Cache read/write value register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The CCVR register is used to source write data or return read data for the
 * commands specified in the CLCR register.
 */
typedef union _hw_lmem_pcccvr
{
    uint32_t U;
    struct _hw_lmem_pcccvr_bitfields
    {
        uint32_t DATA : 32;            /*!< [31:0] Cache read/write Data */
    } B;
} hw_lmem_pcccvr_t;

/*!
 * @name Constants and macros for entire LMEM_PCCCVR register
 */
/*@{*/
#define HW_LMEM_PCCCVR_ADDR(x)   ((x) + 0xCU)

#define HW_LMEM_PCCCVR(x)        (*(__IO hw_lmem_pcccvr_t *) HW_LMEM_PCCCVR_ADDR(x))
#define HW_LMEM_PCCCVR_RD(x)     (HW_LMEM_PCCCVR(x).U)
#define HW_LMEM_PCCCVR_WR(x, v)  (HW_LMEM_PCCCVR(x).U = (v))
#define HW_LMEM_PCCCVR_SET(x, v) (HW_LMEM_PCCCVR_WR(x, HW_LMEM_PCCCVR_RD(x) |  (v)))
#define HW_LMEM_PCCCVR_CLR(x, v) (HW_LMEM_PCCCVR_WR(x, HW_LMEM_PCCCVR_RD(x) & ~(v)))
#define HW_LMEM_PCCCVR_TOG(x, v) (HW_LMEM_PCCCVR_WR(x, HW_LMEM_PCCCVR_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual LMEM_PCCCVR bitfields
 */

/*!
 * @name Register LMEM_PCCCVR, field DATA[31:0] (RW)
 *
 * For tag search, read or write: CCVR[31:12] bits are used for tag array R/W
 * value CCVR[11:4] bits are used for tag set address on reads; unused on writes
 * CCVR[3:2] bits are reserved For data search, read or write: CCVR[31:0] bits are
 * used for data array R/W value
 */
/*@{*/
#define BP_LMEM_PCCCVR_DATA  (0U)          /*!< Bit position for LMEM_PCCCVR_DATA. */
#define BM_LMEM_PCCCVR_DATA  (0xFFFFFFFFU) /*!< Bit mask for LMEM_PCCCVR_DATA. */
#define BS_LMEM_PCCCVR_DATA  (32U)         /*!< Bit field size in bits for LMEM_PCCCVR_DATA. */

/*! @brief Read current value of the LMEM_PCCCVR_DATA field. */
#define BR_LMEM_PCCCVR_DATA(x) (HW_LMEM_PCCCVR(x).U)

/*! @brief Format value for bitfield LMEM_PCCCVR_DATA. */
#define BF_LMEM_PCCCVR_DATA(v) ((uint32_t)((uint32_t)(v) << BP_LMEM_PCCCVR_DATA) & BM_LMEM_PCCCVR_DATA)

/*! @brief Set the DATA field to a new value. */
#define BW_LMEM_PCCCVR_DATA(x, v) (HW_LMEM_PCCCVR_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_LMEM_PCCRMR - Cache regions mode register
 ******************************************************************************/

/*!
 * @brief HW_LMEM_PCCRMR - Cache regions mode register (RW)
 *
 * Reset value: 0xAA0FA000U
 *
 * The CRMR register allows you to demote the cache mode of various subregions
 * within the device's memory map. Demoting the cache mode reduces the cache
 * function applied to a memory region from write-back to write-through to
 * non-cacheable. After a region is demoted, its cache mode can only be raised by a reset,
 * which returns it to its default state. To maintain cache coherency, changes to
 * the cache mode should be completed while the address space being changed is
 * not being accessed or the cache is disabled. Before a cache mode change,
 * complete a cache clear all command to push and invalidate any cache entries that may
 * have changed. The address/module assignment of the 16 subregions is
 * device-specific and are detailed in the Chip Configuration section. Some of the regions
 * may not be used (non-cacheable), and some regions may not be capable of
 * write-back.
 */
typedef union _hw_lmem_pccrmr
{
    uint32_t U;
    struct _hw_lmem_pccrmr_bitfields
    {
        uint32_t R15 : 2;              /*!< [1:0] Region 15 mode */
        uint32_t R14 : 2;              /*!< [3:2] Region 14 mode */
        uint32_t R13 : 2;              /*!< [5:4] Region 13 mode */
        uint32_t R12 : 2;              /*!< [7:6] Region 12 mode */
        uint32_t R11 : 2;              /*!< [9:8] Region 11 mode */
        uint32_t R10 : 2;              /*!< [11:10] Region 10 mode */
        uint32_t R9 : 2;               /*!< [13:12] Region 9 mode */
        uint32_t R8 : 2;               /*!< [15:14] Region 8 mode */
        uint32_t R7 : 2;               /*!< [17:16] Region 7 mode */
        uint32_t R6 : 2;               /*!< [19:18] Region 6 mode */
        uint32_t R5 : 2;               /*!< [21:20] Region 5 mode */
        uint32_t R4 : 2;               /*!< [23:22] Region 4 mode */
        uint32_t R3 : 2;               /*!< [25:24] Region 3 mode */
        uint32_t R2 : 2;               /*!< [27:26] Region 2 mode */
        uint32_t R1 : 2;               /*!< [29:28] Region 1 mode */
        uint32_t R0 : 2;               /*!< [31:30] Region 0 mode */
    } B;
} hw_lmem_pccrmr_t;

/*!
 * @name Constants and macros for entire LMEM_PCCRMR register
 */
/*@{*/
#define HW_LMEM_PCCRMR_ADDR(x)   ((x) + 0x20U)

#define HW_LMEM_PCCRMR(x)        (*(__IO hw_lmem_pccrmr_t *) HW_LMEM_PCCRMR_ADDR(x))
#define HW_LMEM_PCCRMR_RD(x)     (HW_LMEM_PCCRMR(x).U)
#define HW_LMEM_PCCRMR_WR(x, v)  (HW_LMEM_PCCRMR(x).U = (v))
#define HW_LMEM_PCCRMR_SET(x, v) (HW_LMEM_PCCRMR_WR(x, HW_LMEM_PCCRMR_RD(x) |  (v)))
#define HW_LMEM_PCCRMR_CLR(x, v) (HW_LMEM_PCCRMR_WR(x, HW_LMEM_PCCRMR_RD(x) & ~(v)))
#define HW_LMEM_PCCRMR_TOG(x, v) (HW_LMEM_PCCRMR_WR(x, HW_LMEM_PCCRMR_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual LMEM_PCCRMR bitfields
 */

/*!
 * @name Register LMEM_PCCRMR, field R15[1:0] (RW)
 *
 * Controls the cache mode for region 15
 *
 * Values:
 * - 00 - Non-cacheable
 * - 01 - Non-cacheable
 * - 10 - Write-through
 * - 11 - Write-back
 */
/*@{*/
#define BP_LMEM_PCCRMR_R15   (0U)          /*!< Bit position for LMEM_PCCRMR_R15. */
#define BM_LMEM_PCCRMR_R15   (0x00000003U) /*!< Bit mask for LMEM_PCCRMR_R15. */
#define BS_LMEM_PCCRMR_R15   (2U)          /*!< Bit field size in bits for LMEM_PCCRMR_R15. */

/*! @brief Read current value of the LMEM_PCCRMR_R15 field. */
#define BR_LMEM_PCCRMR_R15(x) (HW_LMEM_PCCRMR(x).B.R15)

/*! @brief Format value for bitfield LMEM_PCCRMR_R15. */
#define BF_LMEM_PCCRMR_R15(v) ((uint32_t)((uint32_t)(v) << BP_LMEM_PCCRMR_R15) & BM_LMEM_PCCRMR_R15)

/*! @brief Set the R15 field to a new value. */
#define BW_LMEM_PCCRMR_R15(x, v) (HW_LMEM_PCCRMR_WR(x, (HW_LMEM_PCCRMR_RD(x) & ~BM_LMEM_PCCRMR_R15) | BF_LMEM_PCCRMR_R15(v)))
/*@}*/

/*!
 * @name Register LMEM_PCCRMR, field R14[3:2] (RW)
 *
 * Controls the cache mode for region 14
 *
 * Values:
 * - 00 - Non-cacheable
 * - 01 - Non-cacheable
 * - 10 - Write-through
 * - 11 - Write-back
 */
/*@{*/
#define BP_LMEM_PCCRMR_R14   (2U)          /*!< Bit position for LMEM_PCCRMR_R14. */
#define BM_LMEM_PCCRMR_R14   (0x0000000CU) /*!< Bit mask for LMEM_PCCRMR_R14. */
#define BS_LMEM_PCCRMR_R14   (2U)          /*!< Bit field size in bits for LMEM_PCCRMR_R14. */

/*! @brief Read current value of the LMEM_PCCRMR_R14 field. */
#define BR_LMEM_PCCRMR_R14(x) (HW_LMEM_PCCRMR(x).B.R14)

/*! @brief Format value for bitfield LMEM_PCCRMR_R14. */
#define BF_LMEM_PCCRMR_R14(v) ((uint32_t)((uint32_t)(v) << BP_LMEM_PCCRMR_R14) & BM_LMEM_PCCRMR_R14)

/*! @brief Set the R14 field to a new value. */
#define BW_LMEM_PCCRMR_R14(x, v) (HW_LMEM_PCCRMR_WR(x, (HW_LMEM_PCCRMR_RD(x) & ~BM_LMEM_PCCRMR_R14) | BF_LMEM_PCCRMR_R14(v)))
/*@}*/

/*!
 * @name Register LMEM_PCCRMR, field R13[5:4] (RW)
 *
 * Controls the cache mode for region 13
 *
 * Values:
 * - 00 - Non-cacheable
 * - 01 - Non-cacheable
 * - 10 - Write-through
 * - 11 - Write-back
 */
/*@{*/
#define BP_LMEM_PCCRMR_R13   (4U)          /*!< Bit position for LMEM_PCCRMR_R13. */
#define BM_LMEM_PCCRMR_R13   (0x00000030U) /*!< Bit mask for LMEM_PCCRMR_R13. */
#define BS_LMEM_PCCRMR_R13   (2U)          /*!< Bit field size in bits for LMEM_PCCRMR_R13. */

/*! @brief Read current value of the LMEM_PCCRMR_R13 field. */
#define BR_LMEM_PCCRMR_R13(x) (HW_LMEM_PCCRMR(x).B.R13)

/*! @brief Format value for bitfield LMEM_PCCRMR_R13. */
#define BF_LMEM_PCCRMR_R13(v) ((uint32_t)((uint32_t)(v) << BP_LMEM_PCCRMR_R13) & BM_LMEM_PCCRMR_R13)

/*! @brief Set the R13 field to a new value. */
#define BW_LMEM_PCCRMR_R13(x, v) (HW_LMEM_PCCRMR_WR(x, (HW_LMEM_PCCRMR_RD(x) & ~BM_LMEM_PCCRMR_R13) | BF_LMEM_PCCRMR_R13(v)))
/*@}*/

/*!
 * @name Register LMEM_PCCRMR, field R12[7:6] (RW)
 *
 * Controls the cache mode for region 12
 *
 * Values:
 * - 00 - Non-cacheable
 * - 01 - Non-cacheable
 * - 10 - Write-through
 * - 11 - Write-back
 */
/*@{*/
#define BP_LMEM_PCCRMR_R12   (6U)          /*!< Bit position for LMEM_PCCRMR_R12. */
#define BM_LMEM_PCCRMR_R12   (0x000000C0U) /*!< Bit mask for LMEM_PCCRMR_R12. */
#define BS_LMEM_PCCRMR_R12   (2U)          /*!< Bit field size in bits for LMEM_PCCRMR_R12. */

/*! @brief Read current value of the LMEM_PCCRMR_R12 field. */
#define BR_LMEM_PCCRMR_R12(x) (HW_LMEM_PCCRMR(x).B.R12)

/*! @brief Format value for bitfield LMEM_PCCRMR_R12. */
#define BF_LMEM_PCCRMR_R12(v) ((uint32_t)((uint32_t)(v) << BP_LMEM_PCCRMR_R12) & BM_LMEM_PCCRMR_R12)

/*! @brief Set the R12 field to a new value. */
#define BW_LMEM_PCCRMR_R12(x, v) (HW_LMEM_PCCRMR_WR(x, (HW_LMEM_PCCRMR_RD(x) & ~BM_LMEM_PCCRMR_R12) | BF_LMEM_PCCRMR_R12(v)))
/*@}*/

/*!
 * @name Register LMEM_PCCRMR, field R11[9:8] (RW)
 *
 * Controls the cache mode for region 11
 *
 * Values:
 * - 00 - Non-cacheable
 * - 01 - Non-cacheable
 * - 10 - Write-through
 * - 11 - Write-back
 */
/*@{*/
#define BP_LMEM_PCCRMR_R11   (8U)          /*!< Bit position for LMEM_PCCRMR_R11. */
#define BM_LMEM_PCCRMR_R11   (0x00000300U) /*!< Bit mask for LMEM_PCCRMR_R11. */
#define BS_LMEM_PCCRMR_R11   (2U)          /*!< Bit field size in bits for LMEM_PCCRMR_R11. */

/*! @brief Read current value of the LMEM_PCCRMR_R11 field. */
#define BR_LMEM_PCCRMR_R11(x) (HW_LMEM_PCCRMR(x).B.R11)

/*! @brief Format value for bitfield LMEM_PCCRMR_R11. */
#define BF_LMEM_PCCRMR_R11(v) ((uint32_t)((uint32_t)(v) << BP_LMEM_PCCRMR_R11) & BM_LMEM_PCCRMR_R11)

/*! @brief Set the R11 field to a new value. */
#define BW_LMEM_PCCRMR_R11(x, v) (HW_LMEM_PCCRMR_WR(x, (HW_LMEM_PCCRMR_RD(x) & ~BM_LMEM_PCCRMR_R11) | BF_LMEM_PCCRMR_R11(v)))
/*@}*/

/*!
 * @name Register LMEM_PCCRMR, field R10[11:10] (RW)
 *
 * Controls the cache mode for region 10
 *
 * Values:
 * - 00 - Non-cacheable
 * - 01 - Non-cacheable
 * - 10 - Write-through
 * - 11 - Write-back
 */
/*@{*/
#define BP_LMEM_PCCRMR_R10   (10U)         /*!< Bit position for LMEM_PCCRMR_R10. */
#define BM_LMEM_PCCRMR_R10   (0x00000C00U) /*!< Bit mask for LMEM_PCCRMR_R10. */
#define BS_LMEM_PCCRMR_R10   (2U)          /*!< Bit field size in bits for LMEM_PCCRMR_R10. */

/*! @brief Read current value of the LMEM_PCCRMR_R10 field. */
#define BR_LMEM_PCCRMR_R10(x) (HW_LMEM_PCCRMR(x).B.R10)

/*! @brief Format value for bitfield LMEM_PCCRMR_R10. */
#define BF_LMEM_PCCRMR_R10(v) ((uint32_t)((uint32_t)(v) << BP_LMEM_PCCRMR_R10) & BM_LMEM_PCCRMR_R10)

/*! @brief Set the R10 field to a new value. */
#define BW_LMEM_PCCRMR_R10(x, v) (HW_LMEM_PCCRMR_WR(x, (HW_LMEM_PCCRMR_RD(x) & ~BM_LMEM_PCCRMR_R10) | BF_LMEM_PCCRMR_R10(v)))
/*@}*/

/*!
 * @name Register LMEM_PCCRMR, field R9[13:12] (RW)
 *
 * Controls the cache mode for region 9
 *
 * Values:
 * - 00 - Non-cacheable
 * - 01 - Non-cacheable
 * - 10 - Write-through
 * - 11 - Write-back
 */
/*@{*/
#define BP_LMEM_PCCRMR_R9    (12U)         /*!< Bit position for LMEM_PCCRMR_R9. */
#define BM_LMEM_PCCRMR_R9    (0x00003000U) /*!< Bit mask for LMEM_PCCRMR_R9. */
#define BS_LMEM_PCCRMR_R9    (2U)          /*!< Bit field size in bits for LMEM_PCCRMR_R9. */

/*! @brief Read current value of the LMEM_PCCRMR_R9 field. */
#define BR_LMEM_PCCRMR_R9(x) (HW_LMEM_PCCRMR(x).B.R9)

/*! @brief Format value for bitfield LMEM_PCCRMR_R9. */
#define BF_LMEM_PCCRMR_R9(v) ((uint32_t)((uint32_t)(v) << BP_LMEM_PCCRMR_R9) & BM_LMEM_PCCRMR_R9)

/*! @brief Set the R9 field to a new value. */
#define BW_LMEM_PCCRMR_R9(x, v) (HW_LMEM_PCCRMR_WR(x, (HW_LMEM_PCCRMR_RD(x) & ~BM_LMEM_PCCRMR_R9) | BF_LMEM_PCCRMR_R9(v)))
/*@}*/

/*!
 * @name Register LMEM_PCCRMR, field R8[15:14] (RW)
 *
 * Controls the cache mode for region 8
 *
 * Values:
 * - 00 - Non-cacheable
 * - 01 - Non-cacheable
 * - 10 - Write-through
 * - 11 - Write-back
 */
/*@{*/
#define BP_LMEM_PCCRMR_R8    (14U)         /*!< Bit position for LMEM_PCCRMR_R8. */
#define BM_LMEM_PCCRMR_R8    (0x0000C000U) /*!< Bit mask for LMEM_PCCRMR_R8. */
#define BS_LMEM_PCCRMR_R8    (2U)          /*!< Bit field size in bits for LMEM_PCCRMR_R8. */

/*! @brief Read current value of the LMEM_PCCRMR_R8 field. */
#define BR_LMEM_PCCRMR_R8(x) (HW_LMEM_PCCRMR(x).B.R8)

/*! @brief Format value for bitfield LMEM_PCCRMR_R8. */
#define BF_LMEM_PCCRMR_R8(v) ((uint32_t)((uint32_t)(v) << BP_LMEM_PCCRMR_R8) & BM_LMEM_PCCRMR_R8)

/*! @brief Set the R8 field to a new value. */
#define BW_LMEM_PCCRMR_R8(x, v) (HW_LMEM_PCCRMR_WR(x, (HW_LMEM_PCCRMR_RD(x) & ~BM_LMEM_PCCRMR_R8) | BF_LMEM_PCCRMR_R8(v)))
/*@}*/

/*!
 * @name Register LMEM_PCCRMR, field R7[17:16] (RW)
 *
 * Controls the cache mode for region 7
 *
 * Values:
 * - 00 - Non-cacheable
 * - 01 - Non-cacheable
 * - 10 - Write-through
 * - 11 - Write-back
 */
/*@{*/
#define BP_LMEM_PCCRMR_R7    (16U)         /*!< Bit position for LMEM_PCCRMR_R7. */
#define BM_LMEM_PCCRMR_R7    (0x00030000U) /*!< Bit mask for LMEM_PCCRMR_R7. */
#define BS_LMEM_PCCRMR_R7    (2U)          /*!< Bit field size in bits for LMEM_PCCRMR_R7. */

/*! @brief Read current value of the LMEM_PCCRMR_R7 field. */
#define BR_LMEM_PCCRMR_R7(x) (HW_LMEM_PCCRMR(x).B.R7)

/*! @brief Format value for bitfield LMEM_PCCRMR_R7. */
#define BF_LMEM_PCCRMR_R7(v) ((uint32_t)((uint32_t)(v) << BP_LMEM_PCCRMR_R7) & BM_LMEM_PCCRMR_R7)

/*! @brief Set the R7 field to a new value. */
#define BW_LMEM_PCCRMR_R7(x, v) (HW_LMEM_PCCRMR_WR(x, (HW_LMEM_PCCRMR_RD(x) & ~BM_LMEM_PCCRMR_R7) | BF_LMEM_PCCRMR_R7(v)))
/*@}*/

/*!
 * @name Register LMEM_PCCRMR, field R6[19:18] (RW)
 *
 * Controls the cache mode for region 6
 *
 * Values:
 * - 00 - Non-cacheable
 * - 01 - Non-cacheable
 * - 10 - Write-through
 * - 11 - Write-back
 */
/*@{*/
#define BP_LMEM_PCCRMR_R6    (18U)         /*!< Bit position for LMEM_PCCRMR_R6. */
#define BM_LMEM_PCCRMR_R6    (0x000C0000U) /*!< Bit mask for LMEM_PCCRMR_R6. */
#define BS_LMEM_PCCRMR_R6    (2U)          /*!< Bit field size in bits for LMEM_PCCRMR_R6. */

/*! @brief Read current value of the LMEM_PCCRMR_R6 field. */
#define BR_LMEM_PCCRMR_R6(x) (HW_LMEM_PCCRMR(x).B.R6)

/*! @brief Format value for bitfield LMEM_PCCRMR_R6. */
#define BF_LMEM_PCCRMR_R6(v) ((uint32_t)((uint32_t)(v) << BP_LMEM_PCCRMR_R6) & BM_LMEM_PCCRMR_R6)

/*! @brief Set the R6 field to a new value. */
#define BW_LMEM_PCCRMR_R6(x, v) (HW_LMEM_PCCRMR_WR(x, (HW_LMEM_PCCRMR_RD(x) & ~BM_LMEM_PCCRMR_R6) | BF_LMEM_PCCRMR_R6(v)))
/*@}*/

/*!
 * @name Register LMEM_PCCRMR, field R5[21:20] (RW)
 *
 * Controls the cache mode for region 5
 *
 * Values:
 * - 00 - Non-cacheable
 * - 01 - Non-cacheable
 * - 10 - Write-through
 * - 11 - Write-back
 */
/*@{*/
#define BP_LMEM_PCCRMR_R5    (20U)         /*!< Bit position for LMEM_PCCRMR_R5. */
#define BM_LMEM_PCCRMR_R5    (0x00300000U) /*!< Bit mask for LMEM_PCCRMR_R5. */
#define BS_LMEM_PCCRMR_R5    (2U)          /*!< Bit field size in bits for LMEM_PCCRMR_R5. */

/*! @brief Read current value of the LMEM_PCCRMR_R5 field. */
#define BR_LMEM_PCCRMR_R5(x) (HW_LMEM_PCCRMR(x).B.R5)

/*! @brief Format value for bitfield LMEM_PCCRMR_R5. */
#define BF_LMEM_PCCRMR_R5(v) ((uint32_t)((uint32_t)(v) << BP_LMEM_PCCRMR_R5) & BM_LMEM_PCCRMR_R5)

/*! @brief Set the R5 field to a new value. */
#define BW_LMEM_PCCRMR_R5(x, v) (HW_LMEM_PCCRMR_WR(x, (HW_LMEM_PCCRMR_RD(x) & ~BM_LMEM_PCCRMR_R5) | BF_LMEM_PCCRMR_R5(v)))
/*@}*/

/*!
 * @name Register LMEM_PCCRMR, field R4[23:22] (RW)
 *
 * Controls the cache mode for region 4
 *
 * Values:
 * - 00 - Non-cacheable
 * - 01 - Non-cacheable
 * - 10 - Write-through
 * - 11 - Write-back
 */
/*@{*/
#define BP_LMEM_PCCRMR_R4    (22U)         /*!< Bit position for LMEM_PCCRMR_R4. */
#define BM_LMEM_PCCRMR_R4    (0x00C00000U) /*!< Bit mask for LMEM_PCCRMR_R4. */
#define BS_LMEM_PCCRMR_R4    (2U)          /*!< Bit field size in bits for LMEM_PCCRMR_R4. */

/*! @brief Read current value of the LMEM_PCCRMR_R4 field. */
#define BR_LMEM_PCCRMR_R4(x) (HW_LMEM_PCCRMR(x).B.R4)

/*! @brief Format value for bitfield LMEM_PCCRMR_R4. */
#define BF_LMEM_PCCRMR_R4(v) ((uint32_t)((uint32_t)(v) << BP_LMEM_PCCRMR_R4) & BM_LMEM_PCCRMR_R4)

/*! @brief Set the R4 field to a new value. */
#define BW_LMEM_PCCRMR_R4(x, v) (HW_LMEM_PCCRMR_WR(x, (HW_LMEM_PCCRMR_RD(x) & ~BM_LMEM_PCCRMR_R4) | BF_LMEM_PCCRMR_R4(v)))
/*@}*/

/*!
 * @name Register LMEM_PCCRMR, field R3[25:24] (RW)
 *
 * Controls the cache mode for region 3
 *
 * Values:
 * - 00 - Non-cacheable
 * - 01 - Non-cacheable
 * - 10 - Write-through
 * - 11 - Write-back
 */
/*@{*/
#define BP_LMEM_PCCRMR_R3    (24U)         /*!< Bit position for LMEM_PCCRMR_R3. */
#define BM_LMEM_PCCRMR_R3    (0x03000000U) /*!< Bit mask for LMEM_PCCRMR_R3. */
#define BS_LMEM_PCCRMR_R3    (2U)          /*!< Bit field size in bits for LMEM_PCCRMR_R3. */

/*! @brief Read current value of the LMEM_PCCRMR_R3 field. */
#define BR_LMEM_PCCRMR_R3(x) (HW_LMEM_PCCRMR(x).B.R3)

/*! @brief Format value for bitfield LMEM_PCCRMR_R3. */
#define BF_LMEM_PCCRMR_R3(v) ((uint32_t)((uint32_t)(v) << BP_LMEM_PCCRMR_R3) & BM_LMEM_PCCRMR_R3)

/*! @brief Set the R3 field to a new value. */
#define BW_LMEM_PCCRMR_R3(x, v) (HW_LMEM_PCCRMR_WR(x, (HW_LMEM_PCCRMR_RD(x) & ~BM_LMEM_PCCRMR_R3) | BF_LMEM_PCCRMR_R3(v)))
/*@}*/

/*!
 * @name Register LMEM_PCCRMR, field R2[27:26] (RW)
 *
 * Controls the cache mode for region 2
 *
 * Values:
 * - 00 - Non-cacheable
 * - 01 - Non-cacheable
 * - 10 - Write-through
 * - 11 - Write-back
 */
/*@{*/
#define BP_LMEM_PCCRMR_R2    (26U)         /*!< Bit position for LMEM_PCCRMR_R2. */
#define BM_LMEM_PCCRMR_R2    (0x0C000000U) /*!< Bit mask for LMEM_PCCRMR_R2. */
#define BS_LMEM_PCCRMR_R2    (2U)          /*!< Bit field size in bits for LMEM_PCCRMR_R2. */

/*! @brief Read current value of the LMEM_PCCRMR_R2 field. */
#define BR_LMEM_PCCRMR_R2(x) (HW_LMEM_PCCRMR(x).B.R2)

/*! @brief Format value for bitfield LMEM_PCCRMR_R2. */
#define BF_LMEM_PCCRMR_R2(v) ((uint32_t)((uint32_t)(v) << BP_LMEM_PCCRMR_R2) & BM_LMEM_PCCRMR_R2)

/*! @brief Set the R2 field to a new value. */
#define BW_LMEM_PCCRMR_R2(x, v) (HW_LMEM_PCCRMR_WR(x, (HW_LMEM_PCCRMR_RD(x) & ~BM_LMEM_PCCRMR_R2) | BF_LMEM_PCCRMR_R2(v)))
/*@}*/

/*!
 * @name Register LMEM_PCCRMR, field R1[29:28] (RW)
 *
 * Controls the cache mode for region 1
 *
 * Values:
 * - 00 - Non-cacheable
 * - 01 - Non-cacheable
 * - 10 - Write-through
 * - 11 - Write-back
 */
/*@{*/
#define BP_LMEM_PCCRMR_R1    (28U)         /*!< Bit position for LMEM_PCCRMR_R1. */
#define BM_LMEM_PCCRMR_R1    (0x30000000U) /*!< Bit mask for LMEM_PCCRMR_R1. */
#define BS_LMEM_PCCRMR_R1    (2U)          /*!< Bit field size in bits for LMEM_PCCRMR_R1. */

/*! @brief Read current value of the LMEM_PCCRMR_R1 field. */
#define BR_LMEM_PCCRMR_R1(x) (HW_LMEM_PCCRMR(x).B.R1)

/*! @brief Format value for bitfield LMEM_PCCRMR_R1. */
#define BF_LMEM_PCCRMR_R1(v) ((uint32_t)((uint32_t)(v) << BP_LMEM_PCCRMR_R1) & BM_LMEM_PCCRMR_R1)

/*! @brief Set the R1 field to a new value. */
#define BW_LMEM_PCCRMR_R1(x, v) (HW_LMEM_PCCRMR_WR(x, (HW_LMEM_PCCRMR_RD(x) & ~BM_LMEM_PCCRMR_R1) | BF_LMEM_PCCRMR_R1(v)))
/*@}*/

/*!
 * @name Register LMEM_PCCRMR, field R0[31:30] (RW)
 *
 * Controls the cache mode for region 0
 *
 * Values:
 * - 00 - Non-cacheable
 * - 01 - Non-cacheable
 * - 10 - Write-through
 * - 11 - Write-back
 */
/*@{*/
#define BP_LMEM_PCCRMR_R0    (30U)         /*!< Bit position for LMEM_PCCRMR_R0. */
#define BM_LMEM_PCCRMR_R0    (0xC0000000U) /*!< Bit mask for LMEM_PCCRMR_R0. */
#define BS_LMEM_PCCRMR_R0    (2U)          /*!< Bit field size in bits for LMEM_PCCRMR_R0. */

/*! @brief Read current value of the LMEM_PCCRMR_R0 field. */
#define BR_LMEM_PCCRMR_R0(x) (HW_LMEM_PCCRMR(x).B.R0)

/*! @brief Format value for bitfield LMEM_PCCRMR_R0. */
#define BF_LMEM_PCCRMR_R0(v) ((uint32_t)((uint32_t)(v) << BP_LMEM_PCCRMR_R0) & BM_LMEM_PCCRMR_R0)

/*! @brief Set the R0 field to a new value. */
#define BW_LMEM_PCCRMR_R0(x, v) (HW_LMEM_PCCRMR_WR(x, (HW_LMEM_PCCRMR_RD(x) & ~BM_LMEM_PCCRMR_R0) | BF_LMEM_PCCRMR_R0(v)))
/*@}*/

/*******************************************************************************
 * HW_LMEM_PSCCR - Cache control register
 ******************************************************************************/

/*!
 * @brief HW_LMEM_PSCCR - Cache control register (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_lmem_psccr
{
    uint32_t U;
    struct _hw_lmem_psccr_bitfields
    {
        uint32_t ENCACHE : 1;          /*!< [0] Cache enable */
        uint32_t ENWRBUF : 1;          /*!< [1] Enable Write Buffer */
        uint32_t RESERVED0 : 22;       /*!< [23:2]  */
        uint32_t INVW0 : 1;            /*!< [24] Invalidate Way 0 */
        uint32_t PUSHW0 : 1;           /*!< [25] Push Way 0 */
        uint32_t INVW1 : 1;            /*!< [26] Invalidate Way 1 */
        uint32_t PUSHW1 : 1;           /*!< [27] Push Way 1 */
        uint32_t RESERVED1 : 3;        /*!< [30:28]  */
        uint32_t GO : 1;               /*!< [31] Initiate Cache Command */
    } B;
} hw_lmem_psccr_t;

/*!
 * @name Constants and macros for entire LMEM_PSCCR register
 */
/*@{*/
#define HW_LMEM_PSCCR_ADDR(x)    ((x) + 0x800U)

#define HW_LMEM_PSCCR(x)         (*(__IO hw_lmem_psccr_t *) HW_LMEM_PSCCR_ADDR(x))
#define HW_LMEM_PSCCR_RD(x)      (HW_LMEM_PSCCR(x).U)
#define HW_LMEM_PSCCR_WR(x, v)   (HW_LMEM_PSCCR(x).U = (v))
#define HW_LMEM_PSCCR_SET(x, v)  (HW_LMEM_PSCCR_WR(x, HW_LMEM_PSCCR_RD(x) |  (v)))
#define HW_LMEM_PSCCR_CLR(x, v)  (HW_LMEM_PSCCR_WR(x, HW_LMEM_PSCCR_RD(x) & ~(v)))
#define HW_LMEM_PSCCR_TOG(x, v)  (HW_LMEM_PSCCR_WR(x, HW_LMEM_PSCCR_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual LMEM_PSCCR bitfields
 */

/*!
 * @name Register LMEM_PSCCR, field ENCACHE[0] (RW)
 *
 * Values:
 * - 0 - Cache disabled
 * - 1 - Cache enabled
 */
/*@{*/
#define BP_LMEM_PSCCR_ENCACHE (0U)         /*!< Bit position for LMEM_PSCCR_ENCACHE. */
#define BM_LMEM_PSCCR_ENCACHE (0x00000001U) /*!< Bit mask for LMEM_PSCCR_ENCACHE. */
#define BS_LMEM_PSCCR_ENCACHE (1U)         /*!< Bit field size in bits for LMEM_PSCCR_ENCACHE. */

/*! @brief Read current value of the LMEM_PSCCR_ENCACHE field. */
#define BR_LMEM_PSCCR_ENCACHE(x) (BITBAND_ACCESS32(HW_LMEM_PSCCR_ADDR(x), BP_LMEM_PSCCR_ENCACHE))

/*! @brief Format value for bitfield LMEM_PSCCR_ENCACHE. */
#define BF_LMEM_PSCCR_ENCACHE(v) ((uint32_t)((uint32_t)(v) << BP_LMEM_PSCCR_ENCACHE) & BM_LMEM_PSCCR_ENCACHE)

/*! @brief Set the ENCACHE field to a new value. */
#define BW_LMEM_PSCCR_ENCACHE(x, v) (BITBAND_ACCESS32(HW_LMEM_PSCCR_ADDR(x), BP_LMEM_PSCCR_ENCACHE) = (v))
/*@}*/

/*!
 * @name Register LMEM_PSCCR, field ENWRBUF[1] (RW)
 *
 * Values:
 * - 0 - Write buffer disabled
 * - 1 - Write buffer enabled
 */
/*@{*/
#define BP_LMEM_PSCCR_ENWRBUF (1U)         /*!< Bit position for LMEM_PSCCR_ENWRBUF. */
#define BM_LMEM_PSCCR_ENWRBUF (0x00000002U) /*!< Bit mask for LMEM_PSCCR_ENWRBUF. */
#define BS_LMEM_PSCCR_ENWRBUF (1U)         /*!< Bit field size in bits for LMEM_PSCCR_ENWRBUF. */

/*! @brief Read current value of the LMEM_PSCCR_ENWRBUF field. */
#define BR_LMEM_PSCCR_ENWRBUF(x) (BITBAND_ACCESS32(HW_LMEM_PSCCR_ADDR(x), BP_LMEM_PSCCR_ENWRBUF))

/*! @brief Format value for bitfield LMEM_PSCCR_ENWRBUF. */
#define BF_LMEM_PSCCR_ENWRBUF(v) ((uint32_t)((uint32_t)(v) << BP_LMEM_PSCCR_ENWRBUF) & BM_LMEM_PSCCR_ENWRBUF)

/*! @brief Set the ENWRBUF field to a new value. */
#define BW_LMEM_PSCCR_ENWRBUF(x, v) (BITBAND_ACCESS32(HW_LMEM_PSCCR_ADDR(x), BP_LMEM_PSCCR_ENWRBUF) = (v))
/*@}*/

/*!
 * @name Register LMEM_PSCCR, field INVW0[24] (RW)
 *
 * If the PUSHW0 and INVW0 bits are set, then after setting the GO bit, push all
 * modified lines in way 0 and invalidate all lines in way 0 (clear way 0).
 *
 * Values:
 * - 0 - No operation
 * - 1 - When setting the GO bit, invalidate all lines in way 0.
 */
/*@{*/
#define BP_LMEM_PSCCR_INVW0  (24U)         /*!< Bit position for LMEM_PSCCR_INVW0. */
#define BM_LMEM_PSCCR_INVW0  (0x01000000U) /*!< Bit mask for LMEM_PSCCR_INVW0. */
#define BS_LMEM_PSCCR_INVW0  (1U)          /*!< Bit field size in bits for LMEM_PSCCR_INVW0. */

/*! @brief Read current value of the LMEM_PSCCR_INVW0 field. */
#define BR_LMEM_PSCCR_INVW0(x) (BITBAND_ACCESS32(HW_LMEM_PSCCR_ADDR(x), BP_LMEM_PSCCR_INVW0))

/*! @brief Format value for bitfield LMEM_PSCCR_INVW0. */
#define BF_LMEM_PSCCR_INVW0(v) ((uint32_t)((uint32_t)(v) << BP_LMEM_PSCCR_INVW0) & BM_LMEM_PSCCR_INVW0)

/*! @brief Set the INVW0 field to a new value. */
#define BW_LMEM_PSCCR_INVW0(x, v) (BITBAND_ACCESS32(HW_LMEM_PSCCR_ADDR(x), BP_LMEM_PSCCR_INVW0) = (v))
/*@}*/

/*!
 * @name Register LMEM_PSCCR, field PUSHW0[25] (RW)
 *
 * Values:
 * - 0 - No operation
 * - 1 - When setting the GO bit, push all modified lines in way 0
 */
/*@{*/
#define BP_LMEM_PSCCR_PUSHW0 (25U)         /*!< Bit position for LMEM_PSCCR_PUSHW0. */
#define BM_LMEM_PSCCR_PUSHW0 (0x02000000U) /*!< Bit mask for LMEM_PSCCR_PUSHW0. */
#define BS_LMEM_PSCCR_PUSHW0 (1U)          /*!< Bit field size in bits for LMEM_PSCCR_PUSHW0. */

/*! @brief Read current value of the LMEM_PSCCR_PUSHW0 field. */
#define BR_LMEM_PSCCR_PUSHW0(x) (BITBAND_ACCESS32(HW_LMEM_PSCCR_ADDR(x), BP_LMEM_PSCCR_PUSHW0))

/*! @brief Format value for bitfield LMEM_PSCCR_PUSHW0. */
#define BF_LMEM_PSCCR_PUSHW0(v) ((uint32_t)((uint32_t)(v) << BP_LMEM_PSCCR_PUSHW0) & BM_LMEM_PSCCR_PUSHW0)

/*! @brief Set the PUSHW0 field to a new value. */
#define BW_LMEM_PSCCR_PUSHW0(x, v) (BITBAND_ACCESS32(HW_LMEM_PSCCR_ADDR(x), BP_LMEM_PSCCR_PUSHW0) = (v))
/*@}*/

/*!
 * @name Register LMEM_PSCCR, field INVW1[26] (RW)
 *
 * If the PUSHW1 and INVW1 bits are set, then after setting the GO bit, push all
 * modified lines in way 1 and invalidate all lines in way 1 (clear way 1).
 *
 * Values:
 * - 0 - No operation
 * - 1 - When setting the GO bit, invalidate all lines in way 1
 */
/*@{*/
#define BP_LMEM_PSCCR_INVW1  (26U)         /*!< Bit position for LMEM_PSCCR_INVW1. */
#define BM_LMEM_PSCCR_INVW1  (0x04000000U) /*!< Bit mask for LMEM_PSCCR_INVW1. */
#define BS_LMEM_PSCCR_INVW1  (1U)          /*!< Bit field size in bits for LMEM_PSCCR_INVW1. */

/*! @brief Read current value of the LMEM_PSCCR_INVW1 field. */
#define BR_LMEM_PSCCR_INVW1(x) (BITBAND_ACCESS32(HW_LMEM_PSCCR_ADDR(x), BP_LMEM_PSCCR_INVW1))

/*! @brief Format value for bitfield LMEM_PSCCR_INVW1. */
#define BF_LMEM_PSCCR_INVW1(v) ((uint32_t)((uint32_t)(v) << BP_LMEM_PSCCR_INVW1) & BM_LMEM_PSCCR_INVW1)

/*! @brief Set the INVW1 field to a new value. */
#define BW_LMEM_PSCCR_INVW1(x, v) (BITBAND_ACCESS32(HW_LMEM_PSCCR_ADDR(x), BP_LMEM_PSCCR_INVW1) = (v))
/*@}*/

/*!
 * @name Register LMEM_PSCCR, field PUSHW1[27] (RW)
 *
 * Values:
 * - 0 - No operation
 * - 1 - When setting the GO bit, push all modified lines in way 1
 */
/*@{*/
#define BP_LMEM_PSCCR_PUSHW1 (27U)         /*!< Bit position for LMEM_PSCCR_PUSHW1. */
#define BM_LMEM_PSCCR_PUSHW1 (0x08000000U) /*!< Bit mask for LMEM_PSCCR_PUSHW1. */
#define BS_LMEM_PSCCR_PUSHW1 (1U)          /*!< Bit field size in bits for LMEM_PSCCR_PUSHW1. */

/*! @brief Read current value of the LMEM_PSCCR_PUSHW1 field. */
#define BR_LMEM_PSCCR_PUSHW1(x) (BITBAND_ACCESS32(HW_LMEM_PSCCR_ADDR(x), BP_LMEM_PSCCR_PUSHW1))

/*! @brief Format value for bitfield LMEM_PSCCR_PUSHW1. */
#define BF_LMEM_PSCCR_PUSHW1(v) ((uint32_t)((uint32_t)(v) << BP_LMEM_PSCCR_PUSHW1) & BM_LMEM_PSCCR_PUSHW1)

/*! @brief Set the PUSHW1 field to a new value. */
#define BW_LMEM_PSCCR_PUSHW1(x, v) (BITBAND_ACCESS32(HW_LMEM_PSCCR_ADDR(x), BP_LMEM_PSCCR_PUSHW1) = (v))
/*@}*/

/*!
 * @name Register LMEM_PSCCR, field GO[31] (RW)
 *
 * Setting this bit initiates the cache command indicated by bits 27-24. Reading
 * this bit indicates if a command is active This bit stays set until the
 * command completes. Writing zero has no effect.
 *
 * Values:
 * - 0 - Write: no effect. Read: no cache command active.
 * - 1 - Write: initiate command indicated by bits 27-24. Read: cache command
 *     active.
 */
/*@{*/
#define BP_LMEM_PSCCR_GO     (31U)         /*!< Bit position for LMEM_PSCCR_GO. */
#define BM_LMEM_PSCCR_GO     (0x80000000U) /*!< Bit mask for LMEM_PSCCR_GO. */
#define BS_LMEM_PSCCR_GO     (1U)          /*!< Bit field size in bits for LMEM_PSCCR_GO. */

/*! @brief Read current value of the LMEM_PSCCR_GO field. */
#define BR_LMEM_PSCCR_GO(x)  (BITBAND_ACCESS32(HW_LMEM_PSCCR_ADDR(x), BP_LMEM_PSCCR_GO))

/*! @brief Format value for bitfield LMEM_PSCCR_GO. */
#define BF_LMEM_PSCCR_GO(v)  ((uint32_t)((uint32_t)(v) << BP_LMEM_PSCCR_GO) & BM_LMEM_PSCCR_GO)

/*! @brief Set the GO field to a new value. */
#define BW_LMEM_PSCCR_GO(x, v) (BITBAND_ACCESS32(HW_LMEM_PSCCR_ADDR(x), BP_LMEM_PSCCR_GO) = (v))
/*@}*/

/*******************************************************************************
 * HW_LMEM_PSCLCR - Cache line control register
 ******************************************************************************/

/*!
 * @brief HW_LMEM_PSCLCR - Cache line control register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register defines specific line-sized cache operations to be performed
 * using a specific cache line address or a physical address. If a physical address
 * is specified, both ways of the cache are searched, and the command is only
 * performed on the way which hits.
 */
typedef union _hw_lmem_psclcr
{
    uint32_t U;
    struct _hw_lmem_psclcr_bitfields
    {
        uint32_t LGO : 1;              /*!< [0] Initiate Cache Line Command */
        uint32_t RESERVED0 : 1;        /*!< [1]  */
        uint32_t CACHEADDR : 10;       /*!< [11:2] Cache address */
        uint32_t RESERVED1 : 2;        /*!< [13:12]  */
        uint32_t WSEL : 1;             /*!< [14] Way select */
        uint32_t RESERVED2 : 1;        /*!< [15]  */
        uint32_t TDSEL : 1;            /*!< [16] Tag/Data Select */
        uint32_t RESERVED3 : 3;        /*!< [19:17]  */
        uint32_t LCIVB : 1;            /*!< [20] Line Command Initial Valid Bit */
        uint32_t LCIMB : 1;            /*!< [21] Line Command Initial Modified Bit */
        uint32_t LCWAY : 1;            /*!< [22] Line Command Way */
        uint32_t RESERVED4 : 1;        /*!< [23]  */
        uint32_t LCMD : 2;             /*!< [25:24] Line Command */
        uint32_t LADSEL : 1;           /*!< [26] Line Address Select */
        uint32_t LACC : 1;             /*!< [27] Line access type */
        uint32_t RESERVED5 : 4;        /*!< [31:28]  */
    } B;
} hw_lmem_psclcr_t;

/*!
 * @name Constants and macros for entire LMEM_PSCLCR register
 */
/*@{*/
#define HW_LMEM_PSCLCR_ADDR(x)   ((x) + 0x804U)

#define HW_LMEM_PSCLCR(x)        (*(__IO hw_lmem_psclcr_t *) HW_LMEM_PSCLCR_ADDR(x))
#define HW_LMEM_PSCLCR_RD(x)     (HW_LMEM_PSCLCR(x).U)
#define HW_LMEM_PSCLCR_WR(x, v)  (HW_LMEM_PSCLCR(x).U = (v))
#define HW_LMEM_PSCLCR_SET(x, v) (HW_LMEM_PSCLCR_WR(x, HW_LMEM_PSCLCR_RD(x) |  (v)))
#define HW_LMEM_PSCLCR_CLR(x, v) (HW_LMEM_PSCLCR_WR(x, HW_LMEM_PSCLCR_RD(x) & ~(v)))
#define HW_LMEM_PSCLCR_TOG(x, v) (HW_LMEM_PSCLCR_WR(x, HW_LMEM_PSCLCR_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual LMEM_PSCLCR bitfields
 */

/*!
 * @name Register LMEM_PSCLCR, field LGO[0] (RW)
 *
 * Setting this bit initiates the cache line command indicated by bits 27-24.
 * Reading this bit indicates if a line command is active This bit stays set until
 * the command completes. Writing zero has no effect. This bit is shared with
 * CSAR[LGO]
 *
 * Values:
 * - 0 - Write: no effect. Read: no line command active.
 * - 1 - Write: initiate line command indicated by bits 27-24. Read: line
 *     command active.
 */
/*@{*/
#define BP_LMEM_PSCLCR_LGO   (0U)          /*!< Bit position for LMEM_PSCLCR_LGO. */
#define BM_LMEM_PSCLCR_LGO   (0x00000001U) /*!< Bit mask for LMEM_PSCLCR_LGO. */
#define BS_LMEM_PSCLCR_LGO   (1U)          /*!< Bit field size in bits for LMEM_PSCLCR_LGO. */

/*! @brief Read current value of the LMEM_PSCLCR_LGO field. */
#define BR_LMEM_PSCLCR_LGO(x) (BITBAND_ACCESS32(HW_LMEM_PSCLCR_ADDR(x), BP_LMEM_PSCLCR_LGO))

/*! @brief Format value for bitfield LMEM_PSCLCR_LGO. */
#define BF_LMEM_PSCLCR_LGO(v) ((uint32_t)((uint32_t)(v) << BP_LMEM_PSCLCR_LGO) & BM_LMEM_PSCLCR_LGO)

/*! @brief Set the LGO field to a new value. */
#define BW_LMEM_PSCLCR_LGO(x, v) (BITBAND_ACCESS32(HW_LMEM_PSCLCR_ADDR(x), BP_LMEM_PSCLCR_LGO) = (v))
/*@}*/

/*!
 * @name Register LMEM_PSCLCR, field CACHEADDR[11:2] (RW)
 *
 * CLCR[11:4] bits are used to access the tag arrays CLCR[11:2] bits are used to
 * access the data arrays
 */
/*@{*/
#define BP_LMEM_PSCLCR_CACHEADDR (2U)      /*!< Bit position for LMEM_PSCLCR_CACHEADDR. */
#define BM_LMEM_PSCLCR_CACHEADDR (0x00000FFCU) /*!< Bit mask for LMEM_PSCLCR_CACHEADDR. */
#define BS_LMEM_PSCLCR_CACHEADDR (10U)     /*!< Bit field size in bits for LMEM_PSCLCR_CACHEADDR. */

/*! @brief Read current value of the LMEM_PSCLCR_CACHEADDR field. */
#define BR_LMEM_PSCLCR_CACHEADDR(x) (HW_LMEM_PSCLCR(x).B.CACHEADDR)

/*! @brief Format value for bitfield LMEM_PSCLCR_CACHEADDR. */
#define BF_LMEM_PSCLCR_CACHEADDR(v) ((uint32_t)((uint32_t)(v) << BP_LMEM_PSCLCR_CACHEADDR) & BM_LMEM_PSCLCR_CACHEADDR)

/*! @brief Set the CACHEADDR field to a new value. */
#define BW_LMEM_PSCLCR_CACHEADDR(x, v) (HW_LMEM_PSCLCR_WR(x, (HW_LMEM_PSCLCR_RD(x) & ~BM_LMEM_PSCLCR_CACHEADDR) | BF_LMEM_PSCLCR_CACHEADDR(v)))
/*@}*/

/*!
 * @name Register LMEM_PSCLCR, field WSEL[14] (RW)
 *
 * Selects the way for line commands.
 *
 * Values:
 * - 0 - Way 0
 * - 1 - Way 1
 */
/*@{*/
#define BP_LMEM_PSCLCR_WSEL  (14U)         /*!< Bit position for LMEM_PSCLCR_WSEL. */
#define BM_LMEM_PSCLCR_WSEL  (0x00004000U) /*!< Bit mask for LMEM_PSCLCR_WSEL. */
#define BS_LMEM_PSCLCR_WSEL  (1U)          /*!< Bit field size in bits for LMEM_PSCLCR_WSEL. */

/*! @brief Read current value of the LMEM_PSCLCR_WSEL field. */
#define BR_LMEM_PSCLCR_WSEL(x) (BITBAND_ACCESS32(HW_LMEM_PSCLCR_ADDR(x), BP_LMEM_PSCLCR_WSEL))

/*! @brief Format value for bitfield LMEM_PSCLCR_WSEL. */
#define BF_LMEM_PSCLCR_WSEL(v) ((uint32_t)((uint32_t)(v) << BP_LMEM_PSCLCR_WSEL) & BM_LMEM_PSCLCR_WSEL)

/*! @brief Set the WSEL field to a new value. */
#define BW_LMEM_PSCLCR_WSEL(x, v) (BITBAND_ACCESS32(HW_LMEM_PSCLCR_ADDR(x), BP_LMEM_PSCLCR_WSEL) = (v))
/*@}*/

/*!
 * @name Register LMEM_PSCLCR, field TDSEL[16] (RW)
 *
 * Selects tag or data for search and read or write commands.
 *
 * Values:
 * - 0 - Data
 * - 1 - Tag
 */
/*@{*/
#define BP_LMEM_PSCLCR_TDSEL (16U)         /*!< Bit position for LMEM_PSCLCR_TDSEL. */
#define BM_LMEM_PSCLCR_TDSEL (0x00010000U) /*!< Bit mask for LMEM_PSCLCR_TDSEL. */
#define BS_LMEM_PSCLCR_TDSEL (1U)          /*!< Bit field size in bits for LMEM_PSCLCR_TDSEL. */

/*! @brief Read current value of the LMEM_PSCLCR_TDSEL field. */
#define BR_LMEM_PSCLCR_TDSEL(x) (BITBAND_ACCESS32(HW_LMEM_PSCLCR_ADDR(x), BP_LMEM_PSCLCR_TDSEL))

/*! @brief Format value for bitfield LMEM_PSCLCR_TDSEL. */
#define BF_LMEM_PSCLCR_TDSEL(v) ((uint32_t)((uint32_t)(v) << BP_LMEM_PSCLCR_TDSEL) & BM_LMEM_PSCLCR_TDSEL)

/*! @brief Set the TDSEL field to a new value. */
#define BW_LMEM_PSCLCR_TDSEL(x, v) (BITBAND_ACCESS32(HW_LMEM_PSCLCR_ADDR(x), BP_LMEM_PSCLCR_TDSEL) = (v))
/*@}*/

/*!
 * @name Register LMEM_PSCLCR, field LCIVB[20] (RO)
 *
 * If command used cache address and way, then this bit shows the initial state
 * of the valid bit If command used physical address and a hit, then this bit
 * shows the initial state of the valid bit. If a miss, this bit reads zero.
 */
/*@{*/
#define BP_LMEM_PSCLCR_LCIVB (20U)         /*!< Bit position for LMEM_PSCLCR_LCIVB. */
#define BM_LMEM_PSCLCR_LCIVB (0x00100000U) /*!< Bit mask for LMEM_PSCLCR_LCIVB. */
#define BS_LMEM_PSCLCR_LCIVB (1U)          /*!< Bit field size in bits for LMEM_PSCLCR_LCIVB. */

/*! @brief Read current value of the LMEM_PSCLCR_LCIVB field. */
#define BR_LMEM_PSCLCR_LCIVB(x) (BITBAND_ACCESS32(HW_LMEM_PSCLCR_ADDR(x), BP_LMEM_PSCLCR_LCIVB))
/*@}*/

/*!
 * @name Register LMEM_PSCLCR, field LCIMB[21] (RO)
 *
 * If command used cache address and way, then this bit shows the initial state
 * of the modified bit If command used physical address and a hit, then this bit
 * shows the initial state of the modified bit. If a miss, this bit reads zero.
 */
/*@{*/
#define BP_LMEM_PSCLCR_LCIMB (21U)         /*!< Bit position for LMEM_PSCLCR_LCIMB. */
#define BM_LMEM_PSCLCR_LCIMB (0x00200000U) /*!< Bit mask for LMEM_PSCLCR_LCIMB. */
#define BS_LMEM_PSCLCR_LCIMB (1U)          /*!< Bit field size in bits for LMEM_PSCLCR_LCIMB. */

/*! @brief Read current value of the LMEM_PSCLCR_LCIMB field. */
#define BR_LMEM_PSCLCR_LCIMB(x) (BITBAND_ACCESS32(HW_LMEM_PSCLCR_ADDR(x), BP_LMEM_PSCLCR_LCIMB))
/*@}*/

/*!
 * @name Register LMEM_PSCLCR, field LCWAY[22] (RO)
 *
 * Indicates the way used by the line command.
 */
/*@{*/
#define BP_LMEM_PSCLCR_LCWAY (22U)         /*!< Bit position for LMEM_PSCLCR_LCWAY. */
#define BM_LMEM_PSCLCR_LCWAY (0x00400000U) /*!< Bit mask for LMEM_PSCLCR_LCWAY. */
#define BS_LMEM_PSCLCR_LCWAY (1U)          /*!< Bit field size in bits for LMEM_PSCLCR_LCWAY. */

/*! @brief Read current value of the LMEM_PSCLCR_LCWAY field. */
#define BR_LMEM_PSCLCR_LCWAY(x) (BITBAND_ACCESS32(HW_LMEM_PSCLCR_ADDR(x), BP_LMEM_PSCLCR_LCWAY))
/*@}*/

/*!
 * @name Register LMEM_PSCLCR, field LCMD[25:24] (RW)
 *
 * Values:
 * - 00 - Search and read or write
 * - 01 - Invalidate
 * - 10 - Push
 * - 11 - Clear
 */
/*@{*/
#define BP_LMEM_PSCLCR_LCMD  (24U)         /*!< Bit position for LMEM_PSCLCR_LCMD. */
#define BM_LMEM_PSCLCR_LCMD  (0x03000000U) /*!< Bit mask for LMEM_PSCLCR_LCMD. */
#define BS_LMEM_PSCLCR_LCMD  (2U)          /*!< Bit field size in bits for LMEM_PSCLCR_LCMD. */

/*! @brief Read current value of the LMEM_PSCLCR_LCMD field. */
#define BR_LMEM_PSCLCR_LCMD(x) (HW_LMEM_PSCLCR(x).B.LCMD)

/*! @brief Format value for bitfield LMEM_PSCLCR_LCMD. */
#define BF_LMEM_PSCLCR_LCMD(v) ((uint32_t)((uint32_t)(v) << BP_LMEM_PSCLCR_LCMD) & BM_LMEM_PSCLCR_LCMD)

/*! @brief Set the LCMD field to a new value. */
#define BW_LMEM_PSCLCR_LCMD(x, v) (HW_LMEM_PSCLCR_WR(x, (HW_LMEM_PSCLCR_RD(x) & ~BM_LMEM_PSCLCR_LCMD) | BF_LMEM_PSCLCR_LCMD(v)))
/*@}*/

/*!
 * @name Register LMEM_PSCLCR, field LADSEL[26] (RW)
 *
 * When using the cache address, the way must also be specified in CLCR[WSEL].
 * When using the physical address, both ways are searched and the command is
 * performed only if a hit.
 *
 * Values:
 * - 0 - Cache address
 * - 1 - Physical address
 */
/*@{*/
#define BP_LMEM_PSCLCR_LADSEL (26U)        /*!< Bit position for LMEM_PSCLCR_LADSEL. */
#define BM_LMEM_PSCLCR_LADSEL (0x04000000U) /*!< Bit mask for LMEM_PSCLCR_LADSEL. */
#define BS_LMEM_PSCLCR_LADSEL (1U)         /*!< Bit field size in bits for LMEM_PSCLCR_LADSEL. */

/*! @brief Read current value of the LMEM_PSCLCR_LADSEL field. */
#define BR_LMEM_PSCLCR_LADSEL(x) (BITBAND_ACCESS32(HW_LMEM_PSCLCR_ADDR(x), BP_LMEM_PSCLCR_LADSEL))

/*! @brief Format value for bitfield LMEM_PSCLCR_LADSEL. */
#define BF_LMEM_PSCLCR_LADSEL(v) ((uint32_t)((uint32_t)(v) << BP_LMEM_PSCLCR_LADSEL) & BM_LMEM_PSCLCR_LADSEL)

/*! @brief Set the LADSEL field to a new value. */
#define BW_LMEM_PSCLCR_LADSEL(x, v) (BITBAND_ACCESS32(HW_LMEM_PSCLCR_ADDR(x), BP_LMEM_PSCLCR_LADSEL) = (v))
/*@}*/

/*!
 * @name Register LMEM_PSCLCR, field LACC[27] (RW)
 *
 * Values:
 * - 0 - Read
 * - 1 - Write
 */
/*@{*/
#define BP_LMEM_PSCLCR_LACC  (27U)         /*!< Bit position for LMEM_PSCLCR_LACC. */
#define BM_LMEM_PSCLCR_LACC  (0x08000000U) /*!< Bit mask for LMEM_PSCLCR_LACC. */
#define BS_LMEM_PSCLCR_LACC  (1U)          /*!< Bit field size in bits for LMEM_PSCLCR_LACC. */

/*! @brief Read current value of the LMEM_PSCLCR_LACC field. */
#define BR_LMEM_PSCLCR_LACC(x) (BITBAND_ACCESS32(HW_LMEM_PSCLCR_ADDR(x), BP_LMEM_PSCLCR_LACC))

/*! @brief Format value for bitfield LMEM_PSCLCR_LACC. */
#define BF_LMEM_PSCLCR_LACC(v) ((uint32_t)((uint32_t)(v) << BP_LMEM_PSCLCR_LACC) & BM_LMEM_PSCLCR_LACC)

/*! @brief Set the LACC field to a new value. */
#define BW_LMEM_PSCLCR_LACC(x, v) (BITBAND_ACCESS32(HW_LMEM_PSCLCR_ADDR(x), BP_LMEM_PSCLCR_LACC) = (v))
/*@}*/

/*******************************************************************************
 * HW_LMEM_PSCSAR - Cache search address register
 ******************************************************************************/

/*!
 * @brief HW_LMEM_PSCSAR - Cache search address register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The CSAR register is used to define the explicit cache address or the
 * physical address for line-sized commands specified in the CLCR[LADSEL] bit.
 */
typedef union _hw_lmem_pscsar
{
    uint32_t U;
    struct _hw_lmem_pscsar_bitfields
    {
        uint32_t LGO : 1;              /*!< [0] Initiate Cache Line Command */
        uint32_t RESERVED0 : 1;        /*!< [1]  */
        uint32_t PHYADDR : 30;         /*!< [31:2] Physical Address */
    } B;
} hw_lmem_pscsar_t;

/*!
 * @name Constants and macros for entire LMEM_PSCSAR register
 */
/*@{*/
#define HW_LMEM_PSCSAR_ADDR(x)   ((x) + 0x808U)

#define HW_LMEM_PSCSAR(x)        (*(__IO hw_lmem_pscsar_t *) HW_LMEM_PSCSAR_ADDR(x))
#define HW_LMEM_PSCSAR_RD(x)     (HW_LMEM_PSCSAR(x).U)
#define HW_LMEM_PSCSAR_WR(x, v)  (HW_LMEM_PSCSAR(x).U = (v))
#define HW_LMEM_PSCSAR_SET(x, v) (HW_LMEM_PSCSAR_WR(x, HW_LMEM_PSCSAR_RD(x) |  (v)))
#define HW_LMEM_PSCSAR_CLR(x, v) (HW_LMEM_PSCSAR_WR(x, HW_LMEM_PSCSAR_RD(x) & ~(v)))
#define HW_LMEM_PSCSAR_TOG(x, v) (HW_LMEM_PSCSAR_WR(x, HW_LMEM_PSCSAR_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual LMEM_PSCSAR bitfields
 */

/*!
 * @name Register LMEM_PSCSAR, field LGO[0] (RW)
 *
 * Setting this bit initiates the cache line command indicated by bits 27-24.
 * Reading this bit indicates if a line command is active This bit stays set until
 * the command completes. Writing zero has no effect. This bit is shared with
 * CLCR[LGO]
 *
 * Values:
 * - 0 - Write: no effect. Read: no line command active.
 * - 1 - Write: initiate line command indicated by bits CLCR[27:24]. Read: line
 *     command active.
 */
/*@{*/
#define BP_LMEM_PSCSAR_LGO   (0U)          /*!< Bit position for LMEM_PSCSAR_LGO. */
#define BM_LMEM_PSCSAR_LGO   (0x00000001U) /*!< Bit mask for LMEM_PSCSAR_LGO. */
#define BS_LMEM_PSCSAR_LGO   (1U)          /*!< Bit field size in bits for LMEM_PSCSAR_LGO. */

/*! @brief Read current value of the LMEM_PSCSAR_LGO field. */
#define BR_LMEM_PSCSAR_LGO(x) (BITBAND_ACCESS32(HW_LMEM_PSCSAR_ADDR(x), BP_LMEM_PSCSAR_LGO))

/*! @brief Format value for bitfield LMEM_PSCSAR_LGO. */
#define BF_LMEM_PSCSAR_LGO(v) ((uint32_t)((uint32_t)(v) << BP_LMEM_PSCSAR_LGO) & BM_LMEM_PSCSAR_LGO)

/*! @brief Set the LGO field to a new value. */
#define BW_LMEM_PSCSAR_LGO(x, v) (BITBAND_ACCESS32(HW_LMEM_PSCSAR_ADDR(x), BP_LMEM_PSCSAR_LGO) = (v))
/*@}*/

/*!
 * @name Register LMEM_PSCSAR, field PHYADDR[31:2] (RW)
 *
 * PHYADDR represents bits [31:2] of the system address. CSAR[31:12] bits are
 * used for tag compare CSAR[11:4] bits are used to access the tag arrays
 * CSAR[11:2] bits are used to access the data arrays
 */
/*@{*/
#define BP_LMEM_PSCSAR_PHYADDR (2U)        /*!< Bit position for LMEM_PSCSAR_PHYADDR. */
#define BM_LMEM_PSCSAR_PHYADDR (0xFFFFFFFCU) /*!< Bit mask for LMEM_PSCSAR_PHYADDR. */
#define BS_LMEM_PSCSAR_PHYADDR (30U)       /*!< Bit field size in bits for LMEM_PSCSAR_PHYADDR. */

/*! @brief Read current value of the LMEM_PSCSAR_PHYADDR field. */
#define BR_LMEM_PSCSAR_PHYADDR(x) (HW_LMEM_PSCSAR(x).B.PHYADDR)

/*! @brief Format value for bitfield LMEM_PSCSAR_PHYADDR. */
#define BF_LMEM_PSCSAR_PHYADDR(v) ((uint32_t)((uint32_t)(v) << BP_LMEM_PSCSAR_PHYADDR) & BM_LMEM_PSCSAR_PHYADDR)

/*! @brief Set the PHYADDR field to a new value. */
#define BW_LMEM_PSCSAR_PHYADDR(x, v) (HW_LMEM_PSCSAR_WR(x, (HW_LMEM_PSCSAR_RD(x) & ~BM_LMEM_PSCSAR_PHYADDR) | BF_LMEM_PSCSAR_PHYADDR(v)))
/*@}*/

/*******************************************************************************
 * HW_LMEM_PSCCVR - Cache read/write value register
 ******************************************************************************/

/*!
 * @brief HW_LMEM_PSCCVR - Cache read/write value register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The CCVR register is used to source write data or return read data for the
 * commands specified in the CLCR register.
 */
typedef union _hw_lmem_psccvr
{
    uint32_t U;
    struct _hw_lmem_psccvr_bitfields
    {
        uint32_t DATA : 32;            /*!< [31:0] Cache read/write Data */
    } B;
} hw_lmem_psccvr_t;

/*!
 * @name Constants and macros for entire LMEM_PSCCVR register
 */
/*@{*/
#define HW_LMEM_PSCCVR_ADDR(x)   ((x) + 0x80CU)

#define HW_LMEM_PSCCVR(x)        (*(__IO hw_lmem_psccvr_t *) HW_LMEM_PSCCVR_ADDR(x))
#define HW_LMEM_PSCCVR_RD(x)     (HW_LMEM_PSCCVR(x).U)
#define HW_LMEM_PSCCVR_WR(x, v)  (HW_LMEM_PSCCVR(x).U = (v))
#define HW_LMEM_PSCCVR_SET(x, v) (HW_LMEM_PSCCVR_WR(x, HW_LMEM_PSCCVR_RD(x) |  (v)))
#define HW_LMEM_PSCCVR_CLR(x, v) (HW_LMEM_PSCCVR_WR(x, HW_LMEM_PSCCVR_RD(x) & ~(v)))
#define HW_LMEM_PSCCVR_TOG(x, v) (HW_LMEM_PSCCVR_WR(x, HW_LMEM_PSCCVR_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual LMEM_PSCCVR bitfields
 */

/*!
 * @name Register LMEM_PSCCVR, field DATA[31:0] (RW)
 *
 * For tag search, read or write: CCVR[31:12] bits are used for tag array R/W
 * value CCVR[11:4] bits are used for tag set address on reads; unused on writes
 * CCVR[3:2] bits are reserved For data search, read or write: CCVR[31:0] bits are
 * used for data array R/W value
 */
/*@{*/
#define BP_LMEM_PSCCVR_DATA  (0U)          /*!< Bit position for LMEM_PSCCVR_DATA. */
#define BM_LMEM_PSCCVR_DATA  (0xFFFFFFFFU) /*!< Bit mask for LMEM_PSCCVR_DATA. */
#define BS_LMEM_PSCCVR_DATA  (32U)         /*!< Bit field size in bits for LMEM_PSCCVR_DATA. */

/*! @brief Read current value of the LMEM_PSCCVR_DATA field. */
#define BR_LMEM_PSCCVR_DATA(x) (HW_LMEM_PSCCVR(x).U)

/*! @brief Format value for bitfield LMEM_PSCCVR_DATA. */
#define BF_LMEM_PSCCVR_DATA(v) ((uint32_t)((uint32_t)(v) << BP_LMEM_PSCCVR_DATA) & BM_LMEM_PSCCVR_DATA)

/*! @brief Set the DATA field to a new value. */
#define BW_LMEM_PSCCVR_DATA(x, v) (HW_LMEM_PSCCVR_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_LMEM_PSCRMR - Cache regions mode register
 ******************************************************************************/

/*!
 * @brief HW_LMEM_PSCRMR - Cache regions mode register (RW)
 *
 * Reset value: 0xAA0FA000U
 *
 * The CRMR register allows you to demote the cache mode of various subregions
 * within the device's memory map. Demoting the cache mode reduces the cache
 * function applied to a memory region from write-back to write-through to
 * non-cacheable. After a region is demoted, its cache mode can only be raised by a reset,
 * which returns it to its default state. To maintain cache coherency, changes to
 * the cache mode should be completed while the address space being changed is
 * not being accessed or the cache is disabled. Before a cache mode change,
 * complete a cache clear all command to push and invalidate any cache entries that may
 * have changed. The address/module assignment of the 16 subregions is
 * device-specific and are detailed in the Chip Configuration section. Some of the regions
 * may not be used (non-cacheable), and some regions may not be capable of
 * write-back.
 */
typedef union _hw_lmem_pscrmr
{
    uint32_t U;
    struct _hw_lmem_pscrmr_bitfields
    {
        uint32_t R15 : 2;              /*!< [1:0] Region 15 mode */
        uint32_t R14 : 2;              /*!< [3:2] Region 14 mode */
        uint32_t R13 : 2;              /*!< [5:4] Region 13 mode */
        uint32_t R12 : 2;              /*!< [7:6] Region 12 mode */
        uint32_t R11 : 2;              /*!< [9:8] Region 11 mode */
        uint32_t R10 : 2;              /*!< [11:10] Region 10 mode */
        uint32_t R9 : 2;               /*!< [13:12] Region 9 mode */
        uint32_t R8 : 2;               /*!< [15:14] Region 8 mode */
        uint32_t R7 : 2;               /*!< [17:16] Region 7 mode */
        uint32_t R6 : 2;               /*!< [19:18] Region 6 mode */
        uint32_t R5 : 2;               /*!< [21:20] Region 5 mode */
        uint32_t R4 : 2;               /*!< [23:22] Region 4 mode */
        uint32_t R3 : 2;               /*!< [25:24] Region 3 mode */
        uint32_t R2 : 2;               /*!< [27:26] Region 2 mode */
        uint32_t R1 : 2;               /*!< [29:28] Region 1 mode */
        uint32_t R0 : 2;               /*!< [31:30] Region 0 mode */
    } B;
} hw_lmem_pscrmr_t;

/*!
 * @name Constants and macros for entire LMEM_PSCRMR register
 */
/*@{*/
#define HW_LMEM_PSCRMR_ADDR(x)   ((x) + 0x820U)

#define HW_LMEM_PSCRMR(x)        (*(__IO hw_lmem_pscrmr_t *) HW_LMEM_PSCRMR_ADDR(x))
#define HW_LMEM_PSCRMR_RD(x)     (HW_LMEM_PSCRMR(x).U)
#define HW_LMEM_PSCRMR_WR(x, v)  (HW_LMEM_PSCRMR(x).U = (v))
#define HW_LMEM_PSCRMR_SET(x, v) (HW_LMEM_PSCRMR_WR(x, HW_LMEM_PSCRMR_RD(x) |  (v)))
#define HW_LMEM_PSCRMR_CLR(x, v) (HW_LMEM_PSCRMR_WR(x, HW_LMEM_PSCRMR_RD(x) & ~(v)))
#define HW_LMEM_PSCRMR_TOG(x, v) (HW_LMEM_PSCRMR_WR(x, HW_LMEM_PSCRMR_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual LMEM_PSCRMR bitfields
 */

/*!
 * @name Register LMEM_PSCRMR, field R15[1:0] (RW)
 *
 * Controls the cache mode for region 15
 *
 * Values:
 * - 00 - Non-cacheable
 * - 01 - Non-cacheable
 * - 10 - Write-through
 * - 11 - Write-back
 */
/*@{*/
#define BP_LMEM_PSCRMR_R15   (0U)          /*!< Bit position for LMEM_PSCRMR_R15. */
#define BM_LMEM_PSCRMR_R15   (0x00000003U) /*!< Bit mask for LMEM_PSCRMR_R15. */
#define BS_LMEM_PSCRMR_R15   (2U)          /*!< Bit field size in bits for LMEM_PSCRMR_R15. */

/*! @brief Read current value of the LMEM_PSCRMR_R15 field. */
#define BR_LMEM_PSCRMR_R15(x) (HW_LMEM_PSCRMR(x).B.R15)

/*! @brief Format value for bitfield LMEM_PSCRMR_R15. */
#define BF_LMEM_PSCRMR_R15(v) ((uint32_t)((uint32_t)(v) << BP_LMEM_PSCRMR_R15) & BM_LMEM_PSCRMR_R15)

/*! @brief Set the R15 field to a new value. */
#define BW_LMEM_PSCRMR_R15(x, v) (HW_LMEM_PSCRMR_WR(x, (HW_LMEM_PSCRMR_RD(x) & ~BM_LMEM_PSCRMR_R15) | BF_LMEM_PSCRMR_R15(v)))
/*@}*/

/*!
 * @name Register LMEM_PSCRMR, field R14[3:2] (RW)
 *
 * Controls the cache mode for region 14
 *
 * Values:
 * - 00 - Non-cacheable
 * - 01 - Non-cacheable
 * - 10 - Write-through
 * - 11 - Write-back
 */
/*@{*/
#define BP_LMEM_PSCRMR_R14   (2U)          /*!< Bit position for LMEM_PSCRMR_R14. */
#define BM_LMEM_PSCRMR_R14   (0x0000000CU) /*!< Bit mask for LMEM_PSCRMR_R14. */
#define BS_LMEM_PSCRMR_R14   (2U)          /*!< Bit field size in bits for LMEM_PSCRMR_R14. */

/*! @brief Read current value of the LMEM_PSCRMR_R14 field. */
#define BR_LMEM_PSCRMR_R14(x) (HW_LMEM_PSCRMR(x).B.R14)

/*! @brief Format value for bitfield LMEM_PSCRMR_R14. */
#define BF_LMEM_PSCRMR_R14(v) ((uint32_t)((uint32_t)(v) << BP_LMEM_PSCRMR_R14) & BM_LMEM_PSCRMR_R14)

/*! @brief Set the R14 field to a new value. */
#define BW_LMEM_PSCRMR_R14(x, v) (HW_LMEM_PSCRMR_WR(x, (HW_LMEM_PSCRMR_RD(x) & ~BM_LMEM_PSCRMR_R14) | BF_LMEM_PSCRMR_R14(v)))
/*@}*/

/*!
 * @name Register LMEM_PSCRMR, field R13[5:4] (RW)
 *
 * Controls the cache mode for region 13
 *
 * Values:
 * - 00 - Non-cacheable
 * - 01 - Non-cacheable
 * - 10 - Write-through
 * - 11 - Write-back
 */
/*@{*/
#define BP_LMEM_PSCRMR_R13   (4U)          /*!< Bit position for LMEM_PSCRMR_R13. */
#define BM_LMEM_PSCRMR_R13   (0x00000030U) /*!< Bit mask for LMEM_PSCRMR_R13. */
#define BS_LMEM_PSCRMR_R13   (2U)          /*!< Bit field size in bits for LMEM_PSCRMR_R13. */

/*! @brief Read current value of the LMEM_PSCRMR_R13 field. */
#define BR_LMEM_PSCRMR_R13(x) (HW_LMEM_PSCRMR(x).B.R13)

/*! @brief Format value for bitfield LMEM_PSCRMR_R13. */
#define BF_LMEM_PSCRMR_R13(v) ((uint32_t)((uint32_t)(v) << BP_LMEM_PSCRMR_R13) & BM_LMEM_PSCRMR_R13)

/*! @brief Set the R13 field to a new value. */
#define BW_LMEM_PSCRMR_R13(x, v) (HW_LMEM_PSCRMR_WR(x, (HW_LMEM_PSCRMR_RD(x) & ~BM_LMEM_PSCRMR_R13) | BF_LMEM_PSCRMR_R13(v)))
/*@}*/

/*!
 * @name Register LMEM_PSCRMR, field R12[7:6] (RW)
 *
 * Controls the cache mode for region 12
 *
 * Values:
 * - 00 - Non-cacheable
 * - 01 - Non-cacheable
 * - 10 - Write-through
 * - 11 - Write-back
 */
/*@{*/
#define BP_LMEM_PSCRMR_R12   (6U)          /*!< Bit position for LMEM_PSCRMR_R12. */
#define BM_LMEM_PSCRMR_R12   (0x000000C0U) /*!< Bit mask for LMEM_PSCRMR_R12. */
#define BS_LMEM_PSCRMR_R12   (2U)          /*!< Bit field size in bits for LMEM_PSCRMR_R12. */

/*! @brief Read current value of the LMEM_PSCRMR_R12 field. */
#define BR_LMEM_PSCRMR_R12(x) (HW_LMEM_PSCRMR(x).B.R12)

/*! @brief Format value for bitfield LMEM_PSCRMR_R12. */
#define BF_LMEM_PSCRMR_R12(v) ((uint32_t)((uint32_t)(v) << BP_LMEM_PSCRMR_R12) & BM_LMEM_PSCRMR_R12)

/*! @brief Set the R12 field to a new value. */
#define BW_LMEM_PSCRMR_R12(x, v) (HW_LMEM_PSCRMR_WR(x, (HW_LMEM_PSCRMR_RD(x) & ~BM_LMEM_PSCRMR_R12) | BF_LMEM_PSCRMR_R12(v)))
/*@}*/

/*!
 * @name Register LMEM_PSCRMR, field R11[9:8] (RW)
 *
 * Controls the cache mode for region 11
 *
 * Values:
 * - 00 - Non-cacheable
 * - 01 - Non-cacheable
 * - 10 - Write-through
 * - 11 - Write-back
 */
/*@{*/
#define BP_LMEM_PSCRMR_R11   (8U)          /*!< Bit position for LMEM_PSCRMR_R11. */
#define BM_LMEM_PSCRMR_R11   (0x00000300U) /*!< Bit mask for LMEM_PSCRMR_R11. */
#define BS_LMEM_PSCRMR_R11   (2U)          /*!< Bit field size in bits for LMEM_PSCRMR_R11. */

/*! @brief Read current value of the LMEM_PSCRMR_R11 field. */
#define BR_LMEM_PSCRMR_R11(x) (HW_LMEM_PSCRMR(x).B.R11)

/*! @brief Format value for bitfield LMEM_PSCRMR_R11. */
#define BF_LMEM_PSCRMR_R11(v) ((uint32_t)((uint32_t)(v) << BP_LMEM_PSCRMR_R11) & BM_LMEM_PSCRMR_R11)

/*! @brief Set the R11 field to a new value. */
#define BW_LMEM_PSCRMR_R11(x, v) (HW_LMEM_PSCRMR_WR(x, (HW_LMEM_PSCRMR_RD(x) & ~BM_LMEM_PSCRMR_R11) | BF_LMEM_PSCRMR_R11(v)))
/*@}*/

/*!
 * @name Register LMEM_PSCRMR, field R10[11:10] (RW)
 *
 * Controls the cache mode for region 10
 *
 * Values:
 * - 00 - Non-cacheable
 * - 01 - Non-cacheable
 * - 10 - Write-through
 * - 11 - Write-back
 */
/*@{*/
#define BP_LMEM_PSCRMR_R10   (10U)         /*!< Bit position for LMEM_PSCRMR_R10. */
#define BM_LMEM_PSCRMR_R10   (0x00000C00U) /*!< Bit mask for LMEM_PSCRMR_R10. */
#define BS_LMEM_PSCRMR_R10   (2U)          /*!< Bit field size in bits for LMEM_PSCRMR_R10. */

/*! @brief Read current value of the LMEM_PSCRMR_R10 field. */
#define BR_LMEM_PSCRMR_R10(x) (HW_LMEM_PSCRMR(x).B.R10)

/*! @brief Format value for bitfield LMEM_PSCRMR_R10. */
#define BF_LMEM_PSCRMR_R10(v) ((uint32_t)((uint32_t)(v) << BP_LMEM_PSCRMR_R10) & BM_LMEM_PSCRMR_R10)

/*! @brief Set the R10 field to a new value. */
#define BW_LMEM_PSCRMR_R10(x, v) (HW_LMEM_PSCRMR_WR(x, (HW_LMEM_PSCRMR_RD(x) & ~BM_LMEM_PSCRMR_R10) | BF_LMEM_PSCRMR_R10(v)))
/*@}*/

/*!
 * @name Register LMEM_PSCRMR, field R9[13:12] (RW)
 *
 * Controls the cache mode for region 9
 *
 * Values:
 * - 00 - Non-cacheable
 * - 01 - Non-cacheable
 * - 10 - Write-through
 * - 11 - Write-back
 */
/*@{*/
#define BP_LMEM_PSCRMR_R9    (12U)         /*!< Bit position for LMEM_PSCRMR_R9. */
#define BM_LMEM_PSCRMR_R9    (0x00003000U) /*!< Bit mask for LMEM_PSCRMR_R9. */
#define BS_LMEM_PSCRMR_R9    (2U)          /*!< Bit field size in bits for LMEM_PSCRMR_R9. */

/*! @brief Read current value of the LMEM_PSCRMR_R9 field. */
#define BR_LMEM_PSCRMR_R9(x) (HW_LMEM_PSCRMR(x).B.R9)

/*! @brief Format value for bitfield LMEM_PSCRMR_R9. */
#define BF_LMEM_PSCRMR_R9(v) ((uint32_t)((uint32_t)(v) << BP_LMEM_PSCRMR_R9) & BM_LMEM_PSCRMR_R9)

/*! @brief Set the R9 field to a new value. */
#define BW_LMEM_PSCRMR_R9(x, v) (HW_LMEM_PSCRMR_WR(x, (HW_LMEM_PSCRMR_RD(x) & ~BM_LMEM_PSCRMR_R9) | BF_LMEM_PSCRMR_R9(v)))
/*@}*/

/*!
 * @name Register LMEM_PSCRMR, field R8[15:14] (RW)
 *
 * Controls the cache mode for region 8
 *
 * Values:
 * - 00 - Non-cacheable
 * - 01 - Non-cacheable
 * - 10 - Write-through
 * - 11 - Write-back
 */
/*@{*/
#define BP_LMEM_PSCRMR_R8    (14U)         /*!< Bit position for LMEM_PSCRMR_R8. */
#define BM_LMEM_PSCRMR_R8    (0x0000C000U) /*!< Bit mask for LMEM_PSCRMR_R8. */
#define BS_LMEM_PSCRMR_R8    (2U)          /*!< Bit field size in bits for LMEM_PSCRMR_R8. */

/*! @brief Read current value of the LMEM_PSCRMR_R8 field. */
#define BR_LMEM_PSCRMR_R8(x) (HW_LMEM_PSCRMR(x).B.R8)

/*! @brief Format value for bitfield LMEM_PSCRMR_R8. */
#define BF_LMEM_PSCRMR_R8(v) ((uint32_t)((uint32_t)(v) << BP_LMEM_PSCRMR_R8) & BM_LMEM_PSCRMR_R8)

/*! @brief Set the R8 field to a new value. */
#define BW_LMEM_PSCRMR_R8(x, v) (HW_LMEM_PSCRMR_WR(x, (HW_LMEM_PSCRMR_RD(x) & ~BM_LMEM_PSCRMR_R8) | BF_LMEM_PSCRMR_R8(v)))
/*@}*/

/*!
 * @name Register LMEM_PSCRMR, field R7[17:16] (RW)
 *
 * Controls the cache mode for region 7
 *
 * Values:
 * - 00 - Non-cacheable
 * - 01 - Non-cacheable
 * - 10 - Write-through
 * - 11 - Write-back
 */
/*@{*/
#define BP_LMEM_PSCRMR_R7    (16U)         /*!< Bit position for LMEM_PSCRMR_R7. */
#define BM_LMEM_PSCRMR_R7    (0x00030000U) /*!< Bit mask for LMEM_PSCRMR_R7. */
#define BS_LMEM_PSCRMR_R7    (2U)          /*!< Bit field size in bits for LMEM_PSCRMR_R7. */

/*! @brief Read current value of the LMEM_PSCRMR_R7 field. */
#define BR_LMEM_PSCRMR_R7(x) (HW_LMEM_PSCRMR(x).B.R7)

/*! @brief Format value for bitfield LMEM_PSCRMR_R7. */
#define BF_LMEM_PSCRMR_R7(v) ((uint32_t)((uint32_t)(v) << BP_LMEM_PSCRMR_R7) & BM_LMEM_PSCRMR_R7)

/*! @brief Set the R7 field to a new value. */
#define BW_LMEM_PSCRMR_R7(x, v) (HW_LMEM_PSCRMR_WR(x, (HW_LMEM_PSCRMR_RD(x) & ~BM_LMEM_PSCRMR_R7) | BF_LMEM_PSCRMR_R7(v)))
/*@}*/

/*!
 * @name Register LMEM_PSCRMR, field R6[19:18] (RW)
 *
 * Controls the cache mode for region 6
 *
 * Values:
 * - 00 - Non-cacheable
 * - 01 - Non-cacheable
 * - 10 - Write-through
 * - 11 - Write-back
 */
/*@{*/
#define BP_LMEM_PSCRMR_R6    (18U)         /*!< Bit position for LMEM_PSCRMR_R6. */
#define BM_LMEM_PSCRMR_R6    (0x000C0000U) /*!< Bit mask for LMEM_PSCRMR_R6. */
#define BS_LMEM_PSCRMR_R6    (2U)          /*!< Bit field size in bits for LMEM_PSCRMR_R6. */

/*! @brief Read current value of the LMEM_PSCRMR_R6 field. */
#define BR_LMEM_PSCRMR_R6(x) (HW_LMEM_PSCRMR(x).B.R6)

/*! @brief Format value for bitfield LMEM_PSCRMR_R6. */
#define BF_LMEM_PSCRMR_R6(v) ((uint32_t)((uint32_t)(v) << BP_LMEM_PSCRMR_R6) & BM_LMEM_PSCRMR_R6)

/*! @brief Set the R6 field to a new value. */
#define BW_LMEM_PSCRMR_R6(x, v) (HW_LMEM_PSCRMR_WR(x, (HW_LMEM_PSCRMR_RD(x) & ~BM_LMEM_PSCRMR_R6) | BF_LMEM_PSCRMR_R6(v)))
/*@}*/

/*!
 * @name Register LMEM_PSCRMR, field R5[21:20] (RW)
 *
 * Controls the cache mode for region 5
 *
 * Values:
 * - 00 - Non-cacheable
 * - 01 - Non-cacheable
 * - 10 - Write-through
 * - 11 - Write-back
 */
/*@{*/
#define BP_LMEM_PSCRMR_R5    (20U)         /*!< Bit position for LMEM_PSCRMR_R5. */
#define BM_LMEM_PSCRMR_R5    (0x00300000U) /*!< Bit mask for LMEM_PSCRMR_R5. */
#define BS_LMEM_PSCRMR_R5    (2U)          /*!< Bit field size in bits for LMEM_PSCRMR_R5. */

/*! @brief Read current value of the LMEM_PSCRMR_R5 field. */
#define BR_LMEM_PSCRMR_R5(x) (HW_LMEM_PSCRMR(x).B.R5)

/*! @brief Format value for bitfield LMEM_PSCRMR_R5. */
#define BF_LMEM_PSCRMR_R5(v) ((uint32_t)((uint32_t)(v) << BP_LMEM_PSCRMR_R5) & BM_LMEM_PSCRMR_R5)

/*! @brief Set the R5 field to a new value. */
#define BW_LMEM_PSCRMR_R5(x, v) (HW_LMEM_PSCRMR_WR(x, (HW_LMEM_PSCRMR_RD(x) & ~BM_LMEM_PSCRMR_R5) | BF_LMEM_PSCRMR_R5(v)))
/*@}*/

/*!
 * @name Register LMEM_PSCRMR, field R4[23:22] (RW)
 *
 * Controls the cache mode for region 4
 *
 * Values:
 * - 00 - Non-cacheable
 * - 01 - Non-cacheable
 * - 10 - Write-through
 * - 11 - Write-back
 */
/*@{*/
#define BP_LMEM_PSCRMR_R4    (22U)         /*!< Bit position for LMEM_PSCRMR_R4. */
#define BM_LMEM_PSCRMR_R4    (0x00C00000U) /*!< Bit mask for LMEM_PSCRMR_R4. */
#define BS_LMEM_PSCRMR_R4    (2U)          /*!< Bit field size in bits for LMEM_PSCRMR_R4. */

/*! @brief Read current value of the LMEM_PSCRMR_R4 field. */
#define BR_LMEM_PSCRMR_R4(x) (HW_LMEM_PSCRMR(x).B.R4)

/*! @brief Format value for bitfield LMEM_PSCRMR_R4. */
#define BF_LMEM_PSCRMR_R4(v) ((uint32_t)((uint32_t)(v) << BP_LMEM_PSCRMR_R4) & BM_LMEM_PSCRMR_R4)

/*! @brief Set the R4 field to a new value. */
#define BW_LMEM_PSCRMR_R4(x, v) (HW_LMEM_PSCRMR_WR(x, (HW_LMEM_PSCRMR_RD(x) & ~BM_LMEM_PSCRMR_R4) | BF_LMEM_PSCRMR_R4(v)))
/*@}*/

/*!
 * @name Register LMEM_PSCRMR, field R3[25:24] (RW)
 *
 * Controls the cache mode for region 3
 *
 * Values:
 * - 00 - Non-cacheable
 * - 01 - Non-cacheable
 * - 10 - Write-through
 * - 11 - Write-back
 */
/*@{*/
#define BP_LMEM_PSCRMR_R3    (24U)         /*!< Bit position for LMEM_PSCRMR_R3. */
#define BM_LMEM_PSCRMR_R3    (0x03000000U) /*!< Bit mask for LMEM_PSCRMR_R3. */
#define BS_LMEM_PSCRMR_R3    (2U)          /*!< Bit field size in bits for LMEM_PSCRMR_R3. */

/*! @brief Read current value of the LMEM_PSCRMR_R3 field. */
#define BR_LMEM_PSCRMR_R3(x) (HW_LMEM_PSCRMR(x).B.R3)

/*! @brief Format value for bitfield LMEM_PSCRMR_R3. */
#define BF_LMEM_PSCRMR_R3(v) ((uint32_t)((uint32_t)(v) << BP_LMEM_PSCRMR_R3) & BM_LMEM_PSCRMR_R3)

/*! @brief Set the R3 field to a new value. */
#define BW_LMEM_PSCRMR_R3(x, v) (HW_LMEM_PSCRMR_WR(x, (HW_LMEM_PSCRMR_RD(x) & ~BM_LMEM_PSCRMR_R3) | BF_LMEM_PSCRMR_R3(v)))
/*@}*/

/*!
 * @name Register LMEM_PSCRMR, field R2[27:26] (RW)
 *
 * Controls the cache mode for region 2
 *
 * Values:
 * - 00 - Non-cacheable
 * - 01 - Non-cacheable
 * - 10 - Write-through
 * - 11 - Write-back
 */
/*@{*/
#define BP_LMEM_PSCRMR_R2    (26U)         /*!< Bit position for LMEM_PSCRMR_R2. */
#define BM_LMEM_PSCRMR_R2    (0x0C000000U) /*!< Bit mask for LMEM_PSCRMR_R2. */
#define BS_LMEM_PSCRMR_R2    (2U)          /*!< Bit field size in bits for LMEM_PSCRMR_R2. */

/*! @brief Read current value of the LMEM_PSCRMR_R2 field. */
#define BR_LMEM_PSCRMR_R2(x) (HW_LMEM_PSCRMR(x).B.R2)

/*! @brief Format value for bitfield LMEM_PSCRMR_R2. */
#define BF_LMEM_PSCRMR_R2(v) ((uint32_t)((uint32_t)(v) << BP_LMEM_PSCRMR_R2) & BM_LMEM_PSCRMR_R2)

/*! @brief Set the R2 field to a new value. */
#define BW_LMEM_PSCRMR_R2(x, v) (HW_LMEM_PSCRMR_WR(x, (HW_LMEM_PSCRMR_RD(x) & ~BM_LMEM_PSCRMR_R2) | BF_LMEM_PSCRMR_R2(v)))
/*@}*/

/*!
 * @name Register LMEM_PSCRMR, field R1[29:28] (RW)
 *
 * Controls the cache mode for region 1
 *
 * Values:
 * - 00 - Non-cacheable
 * - 01 - Non-cacheable
 * - 10 - Write-through
 * - 11 - Write-back
 */
/*@{*/
#define BP_LMEM_PSCRMR_R1    (28U)         /*!< Bit position for LMEM_PSCRMR_R1. */
#define BM_LMEM_PSCRMR_R1    (0x30000000U) /*!< Bit mask for LMEM_PSCRMR_R1. */
#define BS_LMEM_PSCRMR_R1    (2U)          /*!< Bit field size in bits for LMEM_PSCRMR_R1. */

/*! @brief Read current value of the LMEM_PSCRMR_R1 field. */
#define BR_LMEM_PSCRMR_R1(x) (HW_LMEM_PSCRMR(x).B.R1)

/*! @brief Format value for bitfield LMEM_PSCRMR_R1. */
#define BF_LMEM_PSCRMR_R1(v) ((uint32_t)((uint32_t)(v) << BP_LMEM_PSCRMR_R1) & BM_LMEM_PSCRMR_R1)

/*! @brief Set the R1 field to a new value. */
#define BW_LMEM_PSCRMR_R1(x, v) (HW_LMEM_PSCRMR_WR(x, (HW_LMEM_PSCRMR_RD(x) & ~BM_LMEM_PSCRMR_R1) | BF_LMEM_PSCRMR_R1(v)))
/*@}*/

/*!
 * @name Register LMEM_PSCRMR, field R0[31:30] (RW)
 *
 * Controls the cache mode for region 0
 *
 * Values:
 * - 00 - Non-cacheable
 * - 01 - Non-cacheable
 * - 10 - Write-through
 * - 11 - Write-back
 */
/*@{*/
#define BP_LMEM_PSCRMR_R0    (30U)         /*!< Bit position for LMEM_PSCRMR_R0. */
#define BM_LMEM_PSCRMR_R0    (0xC0000000U) /*!< Bit mask for LMEM_PSCRMR_R0. */
#define BS_LMEM_PSCRMR_R0    (2U)          /*!< Bit field size in bits for LMEM_PSCRMR_R0. */

/*! @brief Read current value of the LMEM_PSCRMR_R0 field. */
#define BR_LMEM_PSCRMR_R0(x) (HW_LMEM_PSCRMR(x).B.R0)

/*! @brief Format value for bitfield LMEM_PSCRMR_R0. */
#define BF_LMEM_PSCRMR_R0(v) ((uint32_t)((uint32_t)(v) << BP_LMEM_PSCRMR_R0) & BM_LMEM_PSCRMR_R0)

/*! @brief Set the R0 field to a new value. */
#define BW_LMEM_PSCRMR_R0(x, v) (HW_LMEM_PSCRMR_WR(x, (HW_LMEM_PSCRMR_RD(x) & ~BM_LMEM_PSCRMR_R0) | BF_LMEM_PSCRMR_R0(v)))
/*@}*/

/*******************************************************************************
 * hw_lmem_t - module struct
 ******************************************************************************/
/*!
 * @brief All LMEM module registers.
 */
#pragma pack(1)
typedef struct _hw_lmem
{
    __IO hw_lmem_pcccr_t PCCCR;            /*!< [0x0] Cache control register */
    __IO hw_lmem_pcclcr_t PCCLCR;          /*!< [0x4] Cache line control register */
    __IO hw_lmem_pccsar_t PCCSAR;          /*!< [0x8] Cache search address register */
    __IO hw_lmem_pcccvr_t PCCCVR;          /*!< [0xC] Cache read/write value register */
    uint8_t _reserved0[16];
    __IO hw_lmem_pccrmr_t PCCRMR;          /*!< [0x20] Cache regions mode register */
    uint8_t _reserved1[2012];
    __IO hw_lmem_psccr_t PSCCR;            /*!< [0x800] Cache control register */
    __IO hw_lmem_psclcr_t PSCLCR;          /*!< [0x804] Cache line control register */
    __IO hw_lmem_pscsar_t PSCSAR;          /*!< [0x808] Cache search address register */
    __IO hw_lmem_psccvr_t PSCCVR;          /*!< [0x80C] Cache read/write value register */
    uint8_t _reserved2[16];
    __IO hw_lmem_pscrmr_t PSCRMR;          /*!< [0x820] Cache regions mode register */
} hw_lmem_t;
#pragma pack()

/*! @brief Macro to access all LMEM registers. */
/*! @param x LMEM module instance base address. */
/*! @return Reference (not a pointer) to the registers struct. To get a pointer to the struct,
 *     use the '&' operator, like <code>&HW_LMEM(LMEM_BASE)</code>. */
#define HW_LMEM(x)     (*(hw_lmem_t *)(x))

#endif /* __HW_LMEM_REGISTERS_H__ */
/* v33/140401/2.1.0 */
/* EOF */

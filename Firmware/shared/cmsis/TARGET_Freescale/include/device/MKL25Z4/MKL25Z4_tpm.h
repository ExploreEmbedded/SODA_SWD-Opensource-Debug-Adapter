/*
 * Copyright (c) 2014, Freescale Semiconductor, Inc.
 * All rights reserved.
 *
 * THIS SOFTWARE IS PROVIDED BY FREESCALE "AS IS" AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
 * SHALL FREESCALE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
 * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
 * OF SUCH DAMAGE.
 */
/*
 * WARNING! DO NOT EDIT THIS FILE DIRECTLY!
 *
 * This file was generated automatically and any changes may be lost.
 */
#ifndef __HW_TPM_REGISTERS_H__
#define __HW_TPM_REGISTERS_H__

#include "MKL25Z4.h"
#include "fsl_bitband.h"

/*
 * MKL25Z4 TPM
 *
 * Timer/PWM Module
 *
 * Registers defined in this header file:
 * - HW_TPM_SC - Status and Control
 * - HW_TPM_CNT - Counter
 * - HW_TPM_MOD - Modulo
 * - HW_TPM_CnSC - Channel (n) Status and Control
 * - HW_TPM_CnV - Channel (n) Value
 * - HW_TPM_STATUS - Capture and Compare Status
 * - HW_TPM_CONF - Configuration
 *
 * - hw_tpm_t - Struct containing all module registers.
 */

#define HW_TPM_INSTANCE_COUNT (3U) /*!< Number of instances of the TPM module. */
#define HW_TPM0 (0U) /*!< Instance number for TPM0. */
#define HW_TPM1 (1U) /*!< Instance number for TPM1. */
#define HW_TPM2 (2U) /*!< Instance number for TPM2. */

/*******************************************************************************
 * HW_TPM_SC - Status and Control
 ******************************************************************************/

/*!
 * @brief HW_TPM_SC - Status and Control (RW)
 *
 * Reset value: 0x00000000U
 *
 * SC contains the overflow status flag and control bits used to configure the
 * interrupt enable, module configuration and prescaler factor. These controls
 * relate to all channels within this module.
 */
typedef union _hw_tpm_sc
{
    uint32_t U;
    struct _hw_tpm_sc_bitfields
    {
        uint32_t PS : 3;               /*!< [2:0] Prescale Factor Selection */
        uint32_t CMOD : 2;             /*!< [4:3] Clock Mode Selection */
        uint32_t CPWMS : 1;            /*!< [5] Center-aligned PWM Select */
        uint32_t TOIE : 1;             /*!< [6] Timer Overflow Interrupt Enable */
        uint32_t TOF : 1;              /*!< [7] Timer Overflow Flag */
        uint32_t DMA : 1;              /*!< [8] DMA Enable */
        uint32_t RESERVED0 : 23;       /*!< [31:9]  */
    } B;
} hw_tpm_sc_t;

/*!
 * @name Constants and macros for entire TPM_SC register
 */
/*@{*/
#define HW_TPM_SC_ADDR(x)        ((x) + 0x0U)

#define HW_TPM_SC(x)             (*(__IO hw_tpm_sc_t *) HW_TPM_SC_ADDR(x))
#define HW_TPM_SC_RD(x)          (HW_TPM_SC(x).U)
#define HW_TPM_SC_WR(x, v)       (HW_TPM_SC(x).U = (v))
#define HW_TPM_SC_SET(x, v)      (BME_OR32(HW_TPM_SC_ADDR(x), (uint32_t)(v)))
#define HW_TPM_SC_CLR(x, v)      (BME_AND32(HW_TPM_SC_ADDR(x), (uint32_t)(~(v))))
#define HW_TPM_SC_TOG(x, v)      (BME_XOR32(HW_TPM_SC_ADDR(x), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual TPM_SC bitfields
 */

/*!
 * @name Register TPM_SC, field PS[2:0] (RW)
 *
 * Selects one of 8 division factors for the clock mode selected by CMOD. This
 * field is write protected. It can be written only when the counter is disabled.
 *
 * Values:
 * - 000 - Divide by 1
 * - 001 - Divide by 2
 * - 010 - Divide by 4
 * - 011 - Divide by 8
 * - 100 - Divide by 16
 * - 101 - Divide by 32
 * - 110 - Divide by 64
 * - 111 - Divide by 128
 */
/*@{*/
#define BP_TPM_SC_PS         (0U)          /*!< Bit position for TPM_SC_PS. */
#define BM_TPM_SC_PS         (0x00000007U) /*!< Bit mask for TPM_SC_PS. */
#define BS_TPM_SC_PS         (3U)          /*!< Bit field size in bits for TPM_SC_PS. */

/*! @brief Read current value of the TPM_SC_PS field. */
#define BR_TPM_SC_PS(x)      (BME_UBFX32(HW_TPM_SC_ADDR(x), BP_TPM_SC_PS, BS_TPM_SC_PS))

/*! @brief Format value for bitfield TPM_SC_PS. */
#define BF_TPM_SC_PS(v)      ((uint32_t)((uint32_t)(v) << BP_TPM_SC_PS) & BM_TPM_SC_PS)

/*! @brief Set the PS field to a new value. */
#define BW_TPM_SC_PS(x, v)   (BME_BFI32(HW_TPM_SC_ADDR(x), ((uint32_t)(v) << BP_TPM_SC_PS), BP_TPM_SC_PS, 3))
/*@}*/

/*!
 * @name Register TPM_SC, field CMOD[4:3] (RW)
 *
 * Selects the LPTPM counter clock modes. When disabling the counter, this field
 * remain set until acknolwedged in the LPTPM clock domain.
 *
 * Values:
 * - 00 - LPTPM counter is disabled
 * - 01 - LPTPM counter increments on every LPTPM counter clock
 * - 10 - LPTPM counter increments on rising edge of LPTPM_EXTCLK synchronized
 *     to the LPTPM counter clock
 * - 11 - Reserved
 */
/*@{*/
#define BP_TPM_SC_CMOD       (3U)          /*!< Bit position for TPM_SC_CMOD. */
#define BM_TPM_SC_CMOD       (0x00000018U) /*!< Bit mask for TPM_SC_CMOD. */
#define BS_TPM_SC_CMOD       (2U)          /*!< Bit field size in bits for TPM_SC_CMOD. */

/*! @brief Read current value of the TPM_SC_CMOD field. */
#define BR_TPM_SC_CMOD(x)    (BME_UBFX32(HW_TPM_SC_ADDR(x), BP_TPM_SC_CMOD, BS_TPM_SC_CMOD))

/*! @brief Format value for bitfield TPM_SC_CMOD. */
#define BF_TPM_SC_CMOD(v)    ((uint32_t)((uint32_t)(v) << BP_TPM_SC_CMOD) & BM_TPM_SC_CMOD)

/*! @brief Set the CMOD field to a new value. */
#define BW_TPM_SC_CMOD(x, v) (BME_BFI32(HW_TPM_SC_ADDR(x), ((uint32_t)(v) << BP_TPM_SC_CMOD), BP_TPM_SC_CMOD, 2))
/*@}*/

/*!
 * @name Register TPM_SC, field CPWMS[5] (RW)
 *
 * Selects CPWM mode. This mode configures the LPTPM to operate in up-down
 * counting mode. This field is write protected. It can be written only when the
 * counter is disabled.
 *
 * Values:
 * - 0 - LPTPM counter operates in up counting mode.
 * - 1 - LPTPM counter operates in up-down counting mode.
 */
/*@{*/
#define BP_TPM_SC_CPWMS      (5U)          /*!< Bit position for TPM_SC_CPWMS. */
#define BM_TPM_SC_CPWMS      (0x00000020U) /*!< Bit mask for TPM_SC_CPWMS. */
#define BS_TPM_SC_CPWMS      (1U)          /*!< Bit field size in bits for TPM_SC_CPWMS. */

/*! @brief Read current value of the TPM_SC_CPWMS field. */
#define BR_TPM_SC_CPWMS(x)   (BME_UBFX32(HW_TPM_SC_ADDR(x), BP_TPM_SC_CPWMS, BS_TPM_SC_CPWMS))

/*! @brief Format value for bitfield TPM_SC_CPWMS. */
#define BF_TPM_SC_CPWMS(v)   ((uint32_t)((uint32_t)(v) << BP_TPM_SC_CPWMS) & BM_TPM_SC_CPWMS)

/*! @brief Set the CPWMS field to a new value. */
#define BW_TPM_SC_CPWMS(x, v) (BME_BFI32(HW_TPM_SC_ADDR(x), ((uint32_t)(v) << BP_TPM_SC_CPWMS), BP_TPM_SC_CPWMS, 1))
/*@}*/

/*!
 * @name Register TPM_SC, field TOIE[6] (RW)
 *
 * Enables LPTPM overflow interrupts.
 *
 * Values:
 * - 0 - Disable TOF interrupts. Use software polling or DMA request.
 * - 1 - Enable TOF interrupts. An interrupt is generated when TOF equals one.
 */
/*@{*/
#define BP_TPM_SC_TOIE       (6U)          /*!< Bit position for TPM_SC_TOIE. */
#define BM_TPM_SC_TOIE       (0x00000040U) /*!< Bit mask for TPM_SC_TOIE. */
#define BS_TPM_SC_TOIE       (1U)          /*!< Bit field size in bits for TPM_SC_TOIE. */

/*! @brief Read current value of the TPM_SC_TOIE field. */
#define BR_TPM_SC_TOIE(x)    (BME_UBFX32(HW_TPM_SC_ADDR(x), BP_TPM_SC_TOIE, BS_TPM_SC_TOIE))

/*! @brief Format value for bitfield TPM_SC_TOIE. */
#define BF_TPM_SC_TOIE(v)    ((uint32_t)((uint32_t)(v) << BP_TPM_SC_TOIE) & BM_TPM_SC_TOIE)

/*! @brief Set the TOIE field to a new value. */
#define BW_TPM_SC_TOIE(x, v) (BME_BFI32(HW_TPM_SC_ADDR(x), ((uint32_t)(v) << BP_TPM_SC_TOIE), BP_TPM_SC_TOIE, 1))
/*@}*/

/*!
 * @name Register TPM_SC, field TOF[7] (W1C)
 *
 * Set by hardware when the LPTPM counter equals the value in the MOD register
 * and increments. The TOF bit is cleared by writing a 1 to TOF bit. Writing a 0
 * to TOF has no effect. If another LPTPM overflow occurs between the flag setting
 * and the flag clearing, the write operation has no effect; therefore, TOF
 * remains set indicating another overflow has occurred. In this case a TOF interrupt
 * request is not lost due to a delay in clearing the previous TOF.
 *
 * Values:
 * - 0 - LPTPM counter has not overflowed.
 * - 1 - LPTPM counter has overflowed.
 */
/*@{*/
#define BP_TPM_SC_TOF        (7U)          /*!< Bit position for TPM_SC_TOF. */
#define BM_TPM_SC_TOF        (0x00000080U) /*!< Bit mask for TPM_SC_TOF. */
#define BS_TPM_SC_TOF        (1U)          /*!< Bit field size in bits for TPM_SC_TOF. */

/*! @brief Read current value of the TPM_SC_TOF field. */
#define BR_TPM_SC_TOF(x)     (BME_UBFX32(HW_TPM_SC_ADDR(x), BP_TPM_SC_TOF, BS_TPM_SC_TOF))

/*! @brief Format value for bitfield TPM_SC_TOF. */
#define BF_TPM_SC_TOF(v)     ((uint32_t)((uint32_t)(v) << BP_TPM_SC_TOF) & BM_TPM_SC_TOF)

/*! @brief Set the TOF field to a new value. */
#define BW_TPM_SC_TOF(x, v)  (BME_BFI32(HW_TPM_SC_ADDR(x), ((uint32_t)(v) << BP_TPM_SC_TOF), BP_TPM_SC_TOF, 1))
/*@}*/

/*!
 * @name Register TPM_SC, field DMA[8] (RW)
 *
 * Enables DMA transfers for the overflow flag.
 *
 * Values:
 * - 0 - Disables DMA transfers.
 * - 1 - Enables DMA transfers.
 */
/*@{*/
#define BP_TPM_SC_DMA        (8U)          /*!< Bit position for TPM_SC_DMA. */
#define BM_TPM_SC_DMA        (0x00000100U) /*!< Bit mask for TPM_SC_DMA. */
#define BS_TPM_SC_DMA        (1U)          /*!< Bit field size in bits for TPM_SC_DMA. */

/*! @brief Read current value of the TPM_SC_DMA field. */
#define BR_TPM_SC_DMA(x)     (BME_UBFX32(HW_TPM_SC_ADDR(x), BP_TPM_SC_DMA, BS_TPM_SC_DMA))

/*! @brief Format value for bitfield TPM_SC_DMA. */
#define BF_TPM_SC_DMA(v)     ((uint32_t)((uint32_t)(v) << BP_TPM_SC_DMA) & BM_TPM_SC_DMA)

/*! @brief Set the DMA field to a new value. */
#define BW_TPM_SC_DMA(x, v)  (BME_BFI32(HW_TPM_SC_ADDR(x), ((uint32_t)(v) << BP_TPM_SC_DMA), BP_TPM_SC_DMA, 1))
/*@}*/

/*******************************************************************************
 * HW_TPM_CNT - Counter
 ******************************************************************************/

/*!
 * @brief HW_TPM_CNT - Counter (RW)
 *
 * Reset value: 0x00000000U
 *
 * The CNT register contains the LPTPM counter value. Reset clears the CNT
 * register. Writing any value to COUNT also clears the counter. When debug is active,
 * the LPTPM counter does not increment unless configured otherwise. Reading the
 * CNT register adds two wait states to the register access due to
 * synchronization delays.
 */
typedef union _hw_tpm_cnt
{
    uint32_t U;
    struct _hw_tpm_cnt_bitfields
    {
        uint32_t COUNT : 16;           /*!< [15:0] Counter value */
        uint32_t RESERVED0 : 16;       /*!< [31:16]  */
    } B;
} hw_tpm_cnt_t;

/*!
 * @name Constants and macros for entire TPM_CNT register
 */
/*@{*/
#define HW_TPM_CNT_ADDR(x)       ((x) + 0x4U)

#define HW_TPM_CNT(x)            (*(__IO hw_tpm_cnt_t *) HW_TPM_CNT_ADDR(x))
#define HW_TPM_CNT_RD(x)         (HW_TPM_CNT(x).U)
#define HW_TPM_CNT_WR(x, v)      (HW_TPM_CNT(x).U = (v))
#define HW_TPM_CNT_SET(x, v)     (BME_OR32(HW_TPM_CNT_ADDR(x), (uint32_t)(v)))
#define HW_TPM_CNT_CLR(x, v)     (BME_AND32(HW_TPM_CNT_ADDR(x), (uint32_t)(~(v))))
#define HW_TPM_CNT_TOG(x, v)     (BME_XOR32(HW_TPM_CNT_ADDR(x), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual TPM_CNT bitfields
 */

/*!
 * @name Register TPM_CNT, field COUNT[15:0] (RW)
 */
/*@{*/
#define BP_TPM_CNT_COUNT     (0U)          /*!< Bit position for TPM_CNT_COUNT. */
#define BM_TPM_CNT_COUNT     (0x0000FFFFU) /*!< Bit mask for TPM_CNT_COUNT. */
#define BS_TPM_CNT_COUNT     (16U)         /*!< Bit field size in bits for TPM_CNT_COUNT. */

/*! @brief Read current value of the TPM_CNT_COUNT field. */
#define BR_TPM_CNT_COUNT(x)  (BME_UBFX32(HW_TPM_CNT_ADDR(x), BP_TPM_CNT_COUNT, BS_TPM_CNT_COUNT))

/*! @brief Format value for bitfield TPM_CNT_COUNT. */
#define BF_TPM_CNT_COUNT(v)  ((uint32_t)((uint32_t)(v) << BP_TPM_CNT_COUNT) & BM_TPM_CNT_COUNT)

/*! @brief Set the COUNT field to a new value. */
#define BW_TPM_CNT_COUNT(x, v) (BME_BFI32(HW_TPM_CNT_ADDR(x), ((uint32_t)(v) << BP_TPM_CNT_COUNT), BP_TPM_CNT_COUNT, 16))
/*@}*/

/*******************************************************************************
 * HW_TPM_MOD - Modulo
 ******************************************************************************/

/*!
 * @brief HW_TPM_MOD - Modulo (RW)
 *
 * Reset value: 0x0000FFFFU
 *
 * The Modulo register contains the modulo value for the LPTPM counter. When the
 * LPTPM counter reaches the modulo value and increments, the overflow flag
 * (TOF) is set and the next value of LPTPM counter depends on the selected counting
 * method (see Counter ). Writing to the MOD register latches the value into a
 * buffer. The MOD register is updated with the value of its write buffer according
 * to MOD Register Update . It is recommended to initialize the LPTPM counter
 * (write to CNT) before writing to the MOD register to avoid confusion about when
 * the first counter overflow will occur.
 */
typedef union _hw_tpm_mod
{
    uint32_t U;
    struct _hw_tpm_mod_bitfields
    {
        uint32_t MOD : 16;             /*!< [15:0] Modulo value */
        uint32_t RESERVED0 : 16;       /*!< [31:16]  */
    } B;
} hw_tpm_mod_t;

/*!
 * @name Constants and macros for entire TPM_MOD register
 */
/*@{*/
#define HW_TPM_MOD_ADDR(x)       ((x) + 0x8U)

#define HW_TPM_MOD(x)            (*(__IO hw_tpm_mod_t *) HW_TPM_MOD_ADDR(x))
#define HW_TPM_MOD_RD(x)         (HW_TPM_MOD(x).U)
#define HW_TPM_MOD_WR(x, v)      (HW_TPM_MOD(x).U = (v))
#define HW_TPM_MOD_SET(x, v)     (BME_OR32(HW_TPM_MOD_ADDR(x), (uint32_t)(v)))
#define HW_TPM_MOD_CLR(x, v)     (BME_AND32(HW_TPM_MOD_ADDR(x), (uint32_t)(~(v))))
#define HW_TPM_MOD_TOG(x, v)     (BME_XOR32(HW_TPM_MOD_ADDR(x), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual TPM_MOD bitfields
 */

/*!
 * @name Register TPM_MOD, field MOD[15:0] (RW)
 *
 * When writing this field, all bytes must be written at the same time.
 */
/*@{*/
#define BP_TPM_MOD_MOD       (0U)          /*!< Bit position for TPM_MOD_MOD. */
#define BM_TPM_MOD_MOD       (0x0000FFFFU) /*!< Bit mask for TPM_MOD_MOD. */
#define BS_TPM_MOD_MOD       (16U)         /*!< Bit field size in bits for TPM_MOD_MOD. */

/*! @brief Read current value of the TPM_MOD_MOD field. */
#define BR_TPM_MOD_MOD(x)    (BME_UBFX32(HW_TPM_MOD_ADDR(x), BP_TPM_MOD_MOD, BS_TPM_MOD_MOD))

/*! @brief Format value for bitfield TPM_MOD_MOD. */
#define BF_TPM_MOD_MOD(v)    ((uint32_t)((uint32_t)(v) << BP_TPM_MOD_MOD) & BM_TPM_MOD_MOD)

/*! @brief Set the MOD field to a new value. */
#define BW_TPM_MOD_MOD(x, v) (BME_BFI32(HW_TPM_MOD_ADDR(x), ((uint32_t)(v) << BP_TPM_MOD_MOD), BP_TPM_MOD_MOD, 16))
/*@}*/

/*******************************************************************************
 * HW_TPM_CnSC - Channel (n) Status and Control
 ******************************************************************************/

/*!
 * @brief HW_TPM_CnSC - Channel (n) Status and Control (RW)
 *
 * Reset value: 0x00000000U
 *
 * CnSC contains the channel-interrupt-status flag and control bits used to
 * configure the interrupt enable, channel configuration, and pin function. When
 * switching from one channel mode to a different channel mode, the channel must
 * first be disabled and this must be acknowledged in the LPTPM counter clock domain.
 * Mode, Edge, and Level Selection CPWMS MSnB:MSnA ELSnB:ELSnA Mode
 * Configuration X 00 00 None Channel disabled X 01/10/11 00 Software compare Pin not used
 * for LPTPM 0 00 01 Input capture Capture on Rising Edge Only 10 Capture on
 * Falling Edge Only 11 Capture on Rising or Falling Edge 01 01 Output compare Toggle
 * Output on match 10 Clear Output on match 11 Set Output on match 10 10
 * Edge-aligned PWM High-true pulses (clear Output on match, set Output on reload) X1
 * Low-true pulses (set Output on match, clear Output on reload) 11 10 Output compare
 * Pulse Output low on match X1 Pulse Output high on match 1 10 10
 * Center-aligned PWM High-true pulses (clear Output on match-up, set Output on match-down) X1
 * Low-true pulses (set Output on match-up, clear Output on match-down)
 */
typedef union _hw_tpm_cnsc
{
    uint32_t U;
    struct _hw_tpm_cnsc_bitfields
    {
        uint32_t DMA : 1;              /*!< [0] DMA Enable */
        uint32_t RESERVED0 : 1;        /*!< [1]  */
        uint32_t ELSA : 1;             /*!< [2] Edge or Level Select */
        uint32_t ELSB : 1;             /*!< [3] Edge or Level Select */
        uint32_t MSA : 1;              /*!< [4] Channel Mode Select */
        uint32_t MSB : 1;              /*!< [5] Channel Mode Select */
        uint32_t CHIE : 1;             /*!< [6] Channel Interrupt Enable */
        uint32_t CHF : 1;              /*!< [7] Channel Flag */
        uint32_t RESERVED1 : 24;       /*!< [31:8]  */
    } B;
} hw_tpm_cnsc_t;

/*!
 * @name Constants and macros for entire TPM_CnSC register
 */
/*@{*/
#define HW_TPM_CnSC_COUNT (6U)

#define HW_TPM_CnSC_ADDR(x, n)   ((x) + 0xCU + (0x8U * (n)))

#define HW_TPM_CnSC(x, n)        (*(__IO hw_tpm_cnsc_t *) HW_TPM_CnSC_ADDR(x, n))
#define HW_TPM_CnSC_RD(x, n)     (HW_TPM_CnSC(x, n).U)
#define HW_TPM_CnSC_WR(x, n, v)  (HW_TPM_CnSC(x, n).U = (v))
#define HW_TPM_CnSC_SET(x, n, v) (BME_OR32(HW_TPM_CnSC_ADDR(x, n), (uint32_t)(v)))
#define HW_TPM_CnSC_CLR(x, n, v) (BME_AND32(HW_TPM_CnSC_ADDR(x, n), (uint32_t)(~(v))))
#define HW_TPM_CnSC_TOG(x, n, v) (BME_XOR32(HW_TPM_CnSC_ADDR(x, n), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual TPM_CnSC bitfields
 */

/*!
 * @name Register TPM_CnSC, field DMA[0] (RW)
 *
 * Enables DMA transfers for the channel.
 *
 * Values:
 * - 0 - Disable DMA transfers.
 * - 1 - Enable DMA transfers.
 */
/*@{*/
#define BP_TPM_CnSC_DMA      (0U)          /*!< Bit position for TPM_CnSC_DMA. */
#define BM_TPM_CnSC_DMA      (0x00000001U) /*!< Bit mask for TPM_CnSC_DMA. */
#define BS_TPM_CnSC_DMA      (1U)          /*!< Bit field size in bits for TPM_CnSC_DMA. */

/*! @brief Read current value of the TPM_CnSC_DMA field. */
#define BR_TPM_CnSC_DMA(x, n) (BME_UBFX32(HW_TPM_CnSC_ADDR(x, n), BP_TPM_CnSC_DMA, BS_TPM_CnSC_DMA))

/*! @brief Format value for bitfield TPM_CnSC_DMA. */
#define BF_TPM_CnSC_DMA(v)   ((uint32_t)((uint32_t)(v) << BP_TPM_CnSC_DMA) & BM_TPM_CnSC_DMA)

/*! @brief Set the DMA field to a new value. */
#define BW_TPM_CnSC_DMA(x, n, v) (BME_BFI32(HW_TPM_CnSC_ADDR(x, n), ((uint32_t)(v) << BP_TPM_CnSC_DMA), BP_TPM_CnSC_DMA, 1))
/*@}*/

/*!
 * @name Register TPM_CnSC, field ELSA[2] (RW)
 *
 * The functionality of ELSB and ELSA depends on the channel mode. When a
 * channel is disabled, this bit will not change state until acknowledged in the LPTPM
 * counter clock domain.
 */
/*@{*/
#define BP_TPM_CnSC_ELSA     (2U)          /*!< Bit position for TPM_CnSC_ELSA. */
#define BM_TPM_CnSC_ELSA     (0x00000004U) /*!< Bit mask for TPM_CnSC_ELSA. */
#define BS_TPM_CnSC_ELSA     (1U)          /*!< Bit field size in bits for TPM_CnSC_ELSA. */

/*! @brief Read current value of the TPM_CnSC_ELSA field. */
#define BR_TPM_CnSC_ELSA(x, n) (BME_UBFX32(HW_TPM_CnSC_ADDR(x, n), BP_TPM_CnSC_ELSA, BS_TPM_CnSC_ELSA))

/*! @brief Format value for bitfield TPM_CnSC_ELSA. */
#define BF_TPM_CnSC_ELSA(v)  ((uint32_t)((uint32_t)(v) << BP_TPM_CnSC_ELSA) & BM_TPM_CnSC_ELSA)

/*! @brief Set the ELSA field to a new value. */
#define BW_TPM_CnSC_ELSA(x, n, v) (BME_BFI32(HW_TPM_CnSC_ADDR(x, n), ((uint32_t)(v) << BP_TPM_CnSC_ELSA), BP_TPM_CnSC_ELSA, 1))
/*@}*/

/*!
 * @name Register TPM_CnSC, field ELSB[3] (RW)
 *
 * The functionality of ELSB and ELSA depends on the channel mode. When a
 * channel is disabled, this bit will not change state until acknowledged in the LPTPM
 * counter clock domain.
 */
/*@{*/
#define BP_TPM_CnSC_ELSB     (3U)          /*!< Bit position for TPM_CnSC_ELSB. */
#define BM_TPM_CnSC_ELSB     (0x00000008U) /*!< Bit mask for TPM_CnSC_ELSB. */
#define BS_TPM_CnSC_ELSB     (1U)          /*!< Bit field size in bits for TPM_CnSC_ELSB. */

/*! @brief Read current value of the TPM_CnSC_ELSB field. */
#define BR_TPM_CnSC_ELSB(x, n) (BME_UBFX32(HW_TPM_CnSC_ADDR(x, n), BP_TPM_CnSC_ELSB, BS_TPM_CnSC_ELSB))

/*! @brief Format value for bitfield TPM_CnSC_ELSB. */
#define BF_TPM_CnSC_ELSB(v)  ((uint32_t)((uint32_t)(v) << BP_TPM_CnSC_ELSB) & BM_TPM_CnSC_ELSB)

/*! @brief Set the ELSB field to a new value. */
#define BW_TPM_CnSC_ELSB(x, n, v) (BME_BFI32(HW_TPM_CnSC_ADDR(x, n), ((uint32_t)(v) << BP_TPM_CnSC_ELSB), BP_TPM_CnSC_ELSB, 1))
/*@}*/

/*!
 * @name Register TPM_CnSC, field MSA[4] (RW)
 *
 * Used for further selections in the channel logic. Its functionality is
 * dependent on the channel mode. When a channel is disabled, this bit will not change
 * state until acknowledged in the LPTPM counter clock domain.
 */
/*@{*/
#define BP_TPM_CnSC_MSA      (4U)          /*!< Bit position for TPM_CnSC_MSA. */
#define BM_TPM_CnSC_MSA      (0x00000010U) /*!< Bit mask for TPM_CnSC_MSA. */
#define BS_TPM_CnSC_MSA      (1U)          /*!< Bit field size in bits for TPM_CnSC_MSA. */

/*! @brief Read current value of the TPM_CnSC_MSA field. */
#define BR_TPM_CnSC_MSA(x, n) (BME_UBFX32(HW_TPM_CnSC_ADDR(x, n), BP_TPM_CnSC_MSA, BS_TPM_CnSC_MSA))

/*! @brief Format value for bitfield TPM_CnSC_MSA. */
#define BF_TPM_CnSC_MSA(v)   ((uint32_t)((uint32_t)(v) << BP_TPM_CnSC_MSA) & BM_TPM_CnSC_MSA)

/*! @brief Set the MSA field to a new value. */
#define BW_TPM_CnSC_MSA(x, n, v) (BME_BFI32(HW_TPM_CnSC_ADDR(x, n), ((uint32_t)(v) << BP_TPM_CnSC_MSA), BP_TPM_CnSC_MSA, 1))
/*@}*/

/*!
 * @name Register TPM_CnSC, field MSB[5] (RW)
 *
 * Used for further selections in the channel logic. Its functionality is
 * dependent on the channel mode. When a channel is disabled, this bit will not change
 * state until acknowledged in the LPTPM counter clock domain.
 */
/*@{*/
#define BP_TPM_CnSC_MSB      (5U)          /*!< Bit position for TPM_CnSC_MSB. */
#define BM_TPM_CnSC_MSB      (0x00000020U) /*!< Bit mask for TPM_CnSC_MSB. */
#define BS_TPM_CnSC_MSB      (1U)          /*!< Bit field size in bits for TPM_CnSC_MSB. */

/*! @brief Read current value of the TPM_CnSC_MSB field. */
#define BR_TPM_CnSC_MSB(x, n) (BME_UBFX32(HW_TPM_CnSC_ADDR(x, n), BP_TPM_CnSC_MSB, BS_TPM_CnSC_MSB))

/*! @brief Format value for bitfield TPM_CnSC_MSB. */
#define BF_TPM_CnSC_MSB(v)   ((uint32_t)((uint32_t)(v) << BP_TPM_CnSC_MSB) & BM_TPM_CnSC_MSB)

/*! @brief Set the MSB field to a new value. */
#define BW_TPM_CnSC_MSB(x, n, v) (BME_BFI32(HW_TPM_CnSC_ADDR(x, n), ((uint32_t)(v) << BP_TPM_CnSC_MSB), BP_TPM_CnSC_MSB, 1))
/*@}*/

/*!
 * @name Register TPM_CnSC, field CHIE[6] (RW)
 *
 * Enables channel interrupts.
 *
 * Values:
 * - 0 - Disable channel interrupts.
 * - 1 - Enable channel interrupts.
 */
/*@{*/
#define BP_TPM_CnSC_CHIE     (6U)          /*!< Bit position for TPM_CnSC_CHIE. */
#define BM_TPM_CnSC_CHIE     (0x00000040U) /*!< Bit mask for TPM_CnSC_CHIE. */
#define BS_TPM_CnSC_CHIE     (1U)          /*!< Bit field size in bits for TPM_CnSC_CHIE. */

/*! @brief Read current value of the TPM_CnSC_CHIE field. */
#define BR_TPM_CnSC_CHIE(x, n) (BME_UBFX32(HW_TPM_CnSC_ADDR(x, n), BP_TPM_CnSC_CHIE, BS_TPM_CnSC_CHIE))

/*! @brief Format value for bitfield TPM_CnSC_CHIE. */
#define BF_TPM_CnSC_CHIE(v)  ((uint32_t)((uint32_t)(v) << BP_TPM_CnSC_CHIE) & BM_TPM_CnSC_CHIE)

/*! @brief Set the CHIE field to a new value. */
#define BW_TPM_CnSC_CHIE(x, n, v) (BME_BFI32(HW_TPM_CnSC_ADDR(x, n), ((uint32_t)(v) << BP_TPM_CnSC_CHIE), BP_TPM_CnSC_CHIE, 1))
/*@}*/

/*!
 * @name Register TPM_CnSC, field CHF[7] (W1C)
 *
 * Set by hardware when an event occurs on the channel. CHF is cleared by
 * writing a 1 to the CHF bit. Writing a 0 to CHF has no effect. If another event
 * occurs between the CHF sets and the write operation, the write operation has no
 * effect; therefore, CHF remains set indicating another event has occurred. In this
 * case a CHF interrupt request is not lost due to the delay in clearing the
 * previous CHF.
 *
 * Values:
 * - 0 - No channel event has occurred.
 * - 1 - A channel event has occurred.
 */
/*@{*/
#define BP_TPM_CnSC_CHF      (7U)          /*!< Bit position for TPM_CnSC_CHF. */
#define BM_TPM_CnSC_CHF      (0x00000080U) /*!< Bit mask for TPM_CnSC_CHF. */
#define BS_TPM_CnSC_CHF      (1U)          /*!< Bit field size in bits for TPM_CnSC_CHF. */

/*! @brief Read current value of the TPM_CnSC_CHF field. */
#define BR_TPM_CnSC_CHF(x, n) (BME_UBFX32(HW_TPM_CnSC_ADDR(x, n), BP_TPM_CnSC_CHF, BS_TPM_CnSC_CHF))

/*! @brief Format value for bitfield TPM_CnSC_CHF. */
#define BF_TPM_CnSC_CHF(v)   ((uint32_t)((uint32_t)(v) << BP_TPM_CnSC_CHF) & BM_TPM_CnSC_CHF)

/*! @brief Set the CHF field to a new value. */
#define BW_TPM_CnSC_CHF(x, n, v) (BME_BFI32(HW_TPM_CnSC_ADDR(x, n), ((uint32_t)(v) << BP_TPM_CnSC_CHF), BP_TPM_CnSC_CHF, 1))
/*@}*/
/*******************************************************************************
 * HW_TPM_CnV - Channel (n) Value
 ******************************************************************************/

/*!
 * @brief HW_TPM_CnV - Channel (n) Value (RW)
 *
 * Reset value: 0x00000000U
 *
 * These registers contain the captured LPTPM counter value for the input modes
 * or the match value for the output modes. In input capture mode, any write to a
 * CnV register is ignored. In compare modes, writing to a CnV register latches
 * the value into a buffer. A CnV register is updated with the value of its write
 * buffer according to CnV Register Update .
 */
typedef union _hw_tpm_cnv
{
    uint32_t U;
    struct _hw_tpm_cnv_bitfields
    {
        uint32_t VAL : 16;             /*!< [15:0] Channel Value */
        uint32_t RESERVED0 : 16;       /*!< [31:16]  */
    } B;
} hw_tpm_cnv_t;

/*!
 * @name Constants and macros for entire TPM_CnV register
 */
/*@{*/
#define HW_TPM_CnV_COUNT (6U)

#define HW_TPM_CnV_ADDR(x, n)    ((x) + 0x10U + (0x8U * (n)))

#define HW_TPM_CnV(x, n)         (*(__IO hw_tpm_cnv_t *) HW_TPM_CnV_ADDR(x, n))
#define HW_TPM_CnV_RD(x, n)      (HW_TPM_CnV(x, n).U)
#define HW_TPM_CnV_WR(x, n, v)   (HW_TPM_CnV(x, n).U = (v))
#define HW_TPM_CnV_SET(x, n, v)  (BME_OR32(HW_TPM_CnV_ADDR(x, n), (uint32_t)(v)))
#define HW_TPM_CnV_CLR(x, n, v)  (BME_AND32(HW_TPM_CnV_ADDR(x, n), (uint32_t)(~(v))))
#define HW_TPM_CnV_TOG(x, n, v)  (BME_XOR32(HW_TPM_CnV_ADDR(x, n), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual TPM_CnV bitfields
 */

/*!
 * @name Register TPM_CnV, field VAL[15:0] (RW)
 *
 * Captured LPTPM counter value of the input modes or the match value for the
 * output modes. When writing this field, all bytes must be written at the same
 * time.
 */
/*@{*/
#define BP_TPM_CnV_VAL       (0U)          /*!< Bit position for TPM_CnV_VAL. */
#define BM_TPM_CnV_VAL       (0x0000FFFFU) /*!< Bit mask for TPM_CnV_VAL. */
#define BS_TPM_CnV_VAL       (16U)         /*!< Bit field size in bits for TPM_CnV_VAL. */

/*! @brief Read current value of the TPM_CnV_VAL field. */
#define BR_TPM_CnV_VAL(x, n) (BME_UBFX32(HW_TPM_CnV_ADDR(x, n), BP_TPM_CnV_VAL, BS_TPM_CnV_VAL))

/*! @brief Format value for bitfield TPM_CnV_VAL. */
#define BF_TPM_CnV_VAL(v)    ((uint32_t)((uint32_t)(v) << BP_TPM_CnV_VAL) & BM_TPM_CnV_VAL)

/*! @brief Set the VAL field to a new value. */
#define BW_TPM_CnV_VAL(x, n, v) (BME_BFI32(HW_TPM_CnV_ADDR(x, n), ((uint32_t)(v) << BP_TPM_CnV_VAL), BP_TPM_CnV_VAL, 16))
/*@}*/

/*******************************************************************************
 * HW_TPM_STATUS - Capture and Compare Status
 ******************************************************************************/

/*!
 * @brief HW_TPM_STATUS - Capture and Compare Status (RW)
 *
 * Reset value: 0x00000000U
 *
 * The STATUS register contains a copy of the status flag CHnF bit (in CnSC) for
 * each LPTPM channel, as well as the TOF bit (in SC), for software convenience.
 * Each CHnF bit in STATUS is a mirror of CHnF bit in CnSC. All CHnF bits can be
 * checked using only one read of STATUS. All CHnF bits can be cleared by
 * writing all ones to STATUS. Hardware sets the individual channel flags when an event
 * occurs on the channel. CHF is cleared by writing a 1 to the CHF bit. Writing
 * a 0 to CHF has no effect. If another event occurs between the flag setting and
 * the write operation, the write operation has no effect; therefore, CHF
 * remains set indicating another event has occurred. In this case a CHF interrupt
 * request is not lost due to the clearing sequence for a previous CHF.
 */
typedef union _hw_tpm_status
{
    uint32_t U;
    struct _hw_tpm_status_bitfields
    {
        uint32_t CH0F : 1;             /*!< [0] Channel 0 Flag */
        uint32_t CH1F : 1;             /*!< [1] Channel 1 Flag */
        uint32_t CH2F : 1;             /*!< [2] Channel 2 Flag */
        uint32_t CH3F : 1;             /*!< [3] Channel 3 Flag */
        uint32_t CH4F : 1;             /*!< [4] Channel 4 Flag */
        uint32_t CH5F : 1;             /*!< [5] Channel 5 Flag */
        uint32_t RESERVED0 : 2;        /*!< [7:6]  */
        uint32_t TOF : 1;              /*!< [8] Timer Overflow Flag */
        uint32_t RESERVED1 : 23;       /*!< [31:9]  */
    } B;
} hw_tpm_status_t;

/*!
 * @name Constants and macros for entire TPM_STATUS register
 */
/*@{*/
#define HW_TPM_STATUS_ADDR(x)    ((x) + 0x50U)

#define HW_TPM_STATUS(x)         (*(__IO hw_tpm_status_t *) HW_TPM_STATUS_ADDR(x))
#define HW_TPM_STATUS_RD(x)      (HW_TPM_STATUS(x).U)
#define HW_TPM_STATUS_WR(x, v)   (HW_TPM_STATUS(x).U = (v))
#define HW_TPM_STATUS_SET(x, v)  (BME_OR32(HW_TPM_STATUS_ADDR(x), (uint32_t)(v)))
#define HW_TPM_STATUS_CLR(x, v)  (BME_AND32(HW_TPM_STATUS_ADDR(x), (uint32_t)(~(v))))
#define HW_TPM_STATUS_TOG(x, v)  (BME_XOR32(HW_TPM_STATUS_ADDR(x), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual TPM_STATUS bitfields
 */

/*!
 * @name Register TPM_STATUS, field CH0F[0] (W1C)
 *
 * See the register description.
 *
 * Values:
 * - 0 - No channel event has occurred.
 * - 1 - A channel event has occurred.
 */
/*@{*/
#define BP_TPM_STATUS_CH0F   (0U)          /*!< Bit position for TPM_STATUS_CH0F. */
#define BM_TPM_STATUS_CH0F   (0x00000001U) /*!< Bit mask for TPM_STATUS_CH0F. */
#define BS_TPM_STATUS_CH0F   (1U)          /*!< Bit field size in bits for TPM_STATUS_CH0F. */

/*! @brief Read current value of the TPM_STATUS_CH0F field. */
#define BR_TPM_STATUS_CH0F(x) (BME_UBFX32(HW_TPM_STATUS_ADDR(x), BP_TPM_STATUS_CH0F, BS_TPM_STATUS_CH0F))

/*! @brief Format value for bitfield TPM_STATUS_CH0F. */
#define BF_TPM_STATUS_CH0F(v) ((uint32_t)((uint32_t)(v) << BP_TPM_STATUS_CH0F) & BM_TPM_STATUS_CH0F)

/*! @brief Set the CH0F field to a new value. */
#define BW_TPM_STATUS_CH0F(x, v) (BME_BFI32(HW_TPM_STATUS_ADDR(x), ((uint32_t)(v) << BP_TPM_STATUS_CH0F), BP_TPM_STATUS_CH0F, 1))
/*@}*/

/*!
 * @name Register TPM_STATUS, field CH1F[1] (W1C)
 *
 * See the register description.
 *
 * Values:
 * - 0 - No channel event has occurred.
 * - 1 - A channel event has occurred.
 */
/*@{*/
#define BP_TPM_STATUS_CH1F   (1U)          /*!< Bit position for TPM_STATUS_CH1F. */
#define BM_TPM_STATUS_CH1F   (0x00000002U) /*!< Bit mask for TPM_STATUS_CH1F. */
#define BS_TPM_STATUS_CH1F   (1U)          /*!< Bit field size in bits for TPM_STATUS_CH1F. */

/*! @brief Read current value of the TPM_STATUS_CH1F field. */
#define BR_TPM_STATUS_CH1F(x) (BME_UBFX32(HW_TPM_STATUS_ADDR(x), BP_TPM_STATUS_CH1F, BS_TPM_STATUS_CH1F))

/*! @brief Format value for bitfield TPM_STATUS_CH1F. */
#define BF_TPM_STATUS_CH1F(v) ((uint32_t)((uint32_t)(v) << BP_TPM_STATUS_CH1F) & BM_TPM_STATUS_CH1F)

/*! @brief Set the CH1F field to a new value. */
#define BW_TPM_STATUS_CH1F(x, v) (BME_BFI32(HW_TPM_STATUS_ADDR(x), ((uint32_t)(v) << BP_TPM_STATUS_CH1F), BP_TPM_STATUS_CH1F, 1))
/*@}*/

/*!
 * @name Register TPM_STATUS, field CH2F[2] (W1C)
 *
 * See the register description.
 *
 * Values:
 * - 0 - No channel event has occurred.
 * - 1 - A channel event has occurred.
 */
/*@{*/
#define BP_TPM_STATUS_CH2F   (2U)          /*!< Bit position for TPM_STATUS_CH2F. */
#define BM_TPM_STATUS_CH2F   (0x00000004U) /*!< Bit mask for TPM_STATUS_CH2F. */
#define BS_TPM_STATUS_CH2F   (1U)          /*!< Bit field size in bits for TPM_STATUS_CH2F. */

/*! @brief Read current value of the TPM_STATUS_CH2F field. */
#define BR_TPM_STATUS_CH2F(x) (BME_UBFX32(HW_TPM_STATUS_ADDR(x), BP_TPM_STATUS_CH2F, BS_TPM_STATUS_CH2F))

/*! @brief Format value for bitfield TPM_STATUS_CH2F. */
#define BF_TPM_STATUS_CH2F(v) ((uint32_t)((uint32_t)(v) << BP_TPM_STATUS_CH2F) & BM_TPM_STATUS_CH2F)

/*! @brief Set the CH2F field to a new value. */
#define BW_TPM_STATUS_CH2F(x, v) (BME_BFI32(HW_TPM_STATUS_ADDR(x), ((uint32_t)(v) << BP_TPM_STATUS_CH2F), BP_TPM_STATUS_CH2F, 1))
/*@}*/

/*!
 * @name Register TPM_STATUS, field CH3F[3] (W1C)
 *
 * See the register description.
 *
 * Values:
 * - 0 - No channel event has occurred.
 * - 1 - A channel event has occurred.
 */
/*@{*/
#define BP_TPM_STATUS_CH3F   (3U)          /*!< Bit position for TPM_STATUS_CH3F. */
#define BM_TPM_STATUS_CH3F   (0x00000008U) /*!< Bit mask for TPM_STATUS_CH3F. */
#define BS_TPM_STATUS_CH3F   (1U)          /*!< Bit field size in bits for TPM_STATUS_CH3F. */

/*! @brief Read current value of the TPM_STATUS_CH3F field. */
#define BR_TPM_STATUS_CH3F(x) (BME_UBFX32(HW_TPM_STATUS_ADDR(x), BP_TPM_STATUS_CH3F, BS_TPM_STATUS_CH3F))

/*! @brief Format value for bitfield TPM_STATUS_CH3F. */
#define BF_TPM_STATUS_CH3F(v) ((uint32_t)((uint32_t)(v) << BP_TPM_STATUS_CH3F) & BM_TPM_STATUS_CH3F)

/*! @brief Set the CH3F field to a new value. */
#define BW_TPM_STATUS_CH3F(x, v) (BME_BFI32(HW_TPM_STATUS_ADDR(x), ((uint32_t)(v) << BP_TPM_STATUS_CH3F), BP_TPM_STATUS_CH3F, 1))
/*@}*/

/*!
 * @name Register TPM_STATUS, field CH4F[4] (W1C)
 *
 * See the register description.
 *
 * Values:
 * - 0 - No channel event has occurred.
 * - 1 - A channel event has occurred.
 */
/*@{*/
#define BP_TPM_STATUS_CH4F   (4U)          /*!< Bit position for TPM_STATUS_CH4F. */
#define BM_TPM_STATUS_CH4F   (0x00000010U) /*!< Bit mask for TPM_STATUS_CH4F. */
#define BS_TPM_STATUS_CH4F   (1U)          /*!< Bit field size in bits for TPM_STATUS_CH4F. */

/*! @brief Read current value of the TPM_STATUS_CH4F field. */
#define BR_TPM_STATUS_CH4F(x) (BME_UBFX32(HW_TPM_STATUS_ADDR(x), BP_TPM_STATUS_CH4F, BS_TPM_STATUS_CH4F))

/*! @brief Format value for bitfield TPM_STATUS_CH4F. */
#define BF_TPM_STATUS_CH4F(v) ((uint32_t)((uint32_t)(v) << BP_TPM_STATUS_CH4F) & BM_TPM_STATUS_CH4F)

/*! @brief Set the CH4F field to a new value. */
#define BW_TPM_STATUS_CH4F(x, v) (BME_BFI32(HW_TPM_STATUS_ADDR(x), ((uint32_t)(v) << BP_TPM_STATUS_CH4F), BP_TPM_STATUS_CH4F, 1))
/*@}*/

/*!
 * @name Register TPM_STATUS, field CH5F[5] (W1C)
 *
 * See the register description.
 *
 * Values:
 * - 0 - No channel event has occurred.
 * - 1 - A channel event has occurred.
 */
/*@{*/
#define BP_TPM_STATUS_CH5F   (5U)          /*!< Bit position for TPM_STATUS_CH5F. */
#define BM_TPM_STATUS_CH5F   (0x00000020U) /*!< Bit mask for TPM_STATUS_CH5F. */
#define BS_TPM_STATUS_CH5F   (1U)          /*!< Bit field size in bits for TPM_STATUS_CH5F. */

/*! @brief Read current value of the TPM_STATUS_CH5F field. */
#define BR_TPM_STATUS_CH5F(x) (BME_UBFX32(HW_TPM_STATUS_ADDR(x), BP_TPM_STATUS_CH5F, BS_TPM_STATUS_CH5F))

/*! @brief Format value for bitfield TPM_STATUS_CH5F. */
#define BF_TPM_STATUS_CH5F(v) ((uint32_t)((uint32_t)(v) << BP_TPM_STATUS_CH5F) & BM_TPM_STATUS_CH5F)

/*! @brief Set the CH5F field to a new value. */
#define BW_TPM_STATUS_CH5F(x, v) (BME_BFI32(HW_TPM_STATUS_ADDR(x), ((uint32_t)(v) << BP_TPM_STATUS_CH5F), BP_TPM_STATUS_CH5F, 1))
/*@}*/

/*!
 * @name Register TPM_STATUS, field TOF[8] (W1C)
 *
 * See register description
 *
 * Values:
 * - 0 - LPTPM counter has not overflowed.
 * - 1 - LPTPM counter has overflowed.
 */
/*@{*/
#define BP_TPM_STATUS_TOF    (8U)          /*!< Bit position for TPM_STATUS_TOF. */
#define BM_TPM_STATUS_TOF    (0x00000100U) /*!< Bit mask for TPM_STATUS_TOF. */
#define BS_TPM_STATUS_TOF    (1U)          /*!< Bit field size in bits for TPM_STATUS_TOF. */

/*! @brief Read current value of the TPM_STATUS_TOF field. */
#define BR_TPM_STATUS_TOF(x) (BME_UBFX32(HW_TPM_STATUS_ADDR(x), BP_TPM_STATUS_TOF, BS_TPM_STATUS_TOF))

/*! @brief Format value for bitfield TPM_STATUS_TOF. */
#define BF_TPM_STATUS_TOF(v) ((uint32_t)((uint32_t)(v) << BP_TPM_STATUS_TOF) & BM_TPM_STATUS_TOF)

/*! @brief Set the TOF field to a new value. */
#define BW_TPM_STATUS_TOF(x, v) (BME_BFI32(HW_TPM_STATUS_ADDR(x), ((uint32_t)(v) << BP_TPM_STATUS_TOF), BP_TPM_STATUS_TOF, 1))
/*@}*/

/*******************************************************************************
 * HW_TPM_CONF - Configuration
 ******************************************************************************/

/*!
 * @brief HW_TPM_CONF - Configuration (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register selects the behavior in debug and wait modes and the use of an
 * external global time base.
 */
typedef union _hw_tpm_conf
{
    uint32_t U;
    struct _hw_tpm_conf_bitfields
    {
        uint32_t RESERVED0 : 5;        /*!< [4:0]  */
        uint32_t DOZEEN : 1;           /*!< [5] Doze Enable */
        uint32_t DBGMODE : 2;          /*!< [7:6] Debug Mode */
        uint32_t RESERVED1 : 1;        /*!< [8]  */
        uint32_t GTBEEN : 1;           /*!< [9] Global time base enable */
        uint32_t RESERVED2 : 6;        /*!< [15:10]  */
        uint32_t CSOT : 1;             /*!< [16] Counter Start on Trigger */
        uint32_t CSOO : 1;             /*!< [17] Counter Stop On Overflow */
        uint32_t CROT : 1;             /*!< [18] Counter Reload On Trigger */
        uint32_t RESERVED3 : 5;        /*!< [23:19]  */
        uint32_t TRGSEL : 4;           /*!< [27:24] Trigger Select */
        uint32_t RESERVED4 : 4;        /*!< [31:28]  */
    } B;
} hw_tpm_conf_t;

/*!
 * @name Constants and macros for entire TPM_CONF register
 */
/*@{*/
#define HW_TPM_CONF_ADDR(x)      ((x) + 0x84U)

#define HW_TPM_CONF(x)           (*(__IO hw_tpm_conf_t *) HW_TPM_CONF_ADDR(x))
#define HW_TPM_CONF_RD(x)        (HW_TPM_CONF(x).U)
#define HW_TPM_CONF_WR(x, v)     (HW_TPM_CONF(x).U = (v))
#define HW_TPM_CONF_SET(x, v)    (BME_OR32(HW_TPM_CONF_ADDR(x), (uint32_t)(v)))
#define HW_TPM_CONF_CLR(x, v)    (BME_AND32(HW_TPM_CONF_ADDR(x), (uint32_t)(~(v))))
#define HW_TPM_CONF_TOG(x, v)    (BME_XOR32(HW_TPM_CONF_ADDR(x), (uint32_t)(v)))
/*@}*/

/*
 * Constants & macros for individual TPM_CONF bitfields
 */

/*!
 * @name Register TPM_CONF, field DOZEEN[5] (RW)
 *
 * Configures the LPTPM behavior in wait mode.
 *
 * Values:
 * - 0 - Internal LPTPM counter continues in Doze mode.
 * - 1 - Internal LPTPM counter is paused and does not increment during Doze
 *     mode. Trigger inputs and input capture events are also ignored.
 */
/*@{*/
#define BP_TPM_CONF_DOZEEN   (5U)          /*!< Bit position for TPM_CONF_DOZEEN. */
#define BM_TPM_CONF_DOZEEN   (0x00000020U) /*!< Bit mask for TPM_CONF_DOZEEN. */
#define BS_TPM_CONF_DOZEEN   (1U)          /*!< Bit field size in bits for TPM_CONF_DOZEEN. */

/*! @brief Read current value of the TPM_CONF_DOZEEN field. */
#define BR_TPM_CONF_DOZEEN(x) (BME_UBFX32(HW_TPM_CONF_ADDR(x), BP_TPM_CONF_DOZEEN, BS_TPM_CONF_DOZEEN))

/*! @brief Format value for bitfield TPM_CONF_DOZEEN. */
#define BF_TPM_CONF_DOZEEN(v) ((uint32_t)((uint32_t)(v) << BP_TPM_CONF_DOZEEN) & BM_TPM_CONF_DOZEEN)

/*! @brief Set the DOZEEN field to a new value. */
#define BW_TPM_CONF_DOZEEN(x, v) (BME_BFI32(HW_TPM_CONF_ADDR(x), ((uint32_t)(v) << BP_TPM_CONF_DOZEEN), BP_TPM_CONF_DOZEEN, 1))
/*@}*/

/*!
 * @name Register TPM_CONF, field DBGMODE[7:6] (RW)
 *
 * Configures the LPTPM behavior in debug mode. All other configurations are
 * reserved.
 *
 * Values:
 * - 00 - LPTPM counter is paused and does not increment during debug mode.
 *     Trigger inputs and input capture events are also ignored.
 * - 11 - LPTPM counter continues in debug mode.
 */
/*@{*/
#define BP_TPM_CONF_DBGMODE  (6U)          /*!< Bit position for TPM_CONF_DBGMODE. */
#define BM_TPM_CONF_DBGMODE  (0x000000C0U) /*!< Bit mask for TPM_CONF_DBGMODE. */
#define BS_TPM_CONF_DBGMODE  (2U)          /*!< Bit field size in bits for TPM_CONF_DBGMODE. */

/*! @brief Read current value of the TPM_CONF_DBGMODE field. */
#define BR_TPM_CONF_DBGMODE(x) (BME_UBFX32(HW_TPM_CONF_ADDR(x), BP_TPM_CONF_DBGMODE, BS_TPM_CONF_DBGMODE))

/*! @brief Format value for bitfield TPM_CONF_DBGMODE. */
#define BF_TPM_CONF_DBGMODE(v) ((uint32_t)((uint32_t)(v) << BP_TPM_CONF_DBGMODE) & BM_TPM_CONF_DBGMODE)

/*! @brief Set the DBGMODE field to a new value. */
#define BW_TPM_CONF_DBGMODE(x, v) (BME_BFI32(HW_TPM_CONF_ADDR(x), ((uint32_t)(v) << BP_TPM_CONF_DBGMODE), BP_TPM_CONF_DBGMODE, 2))
/*@}*/

/*!
 * @name Register TPM_CONF, field GTBEEN[9] (RW)
 *
 * Configures the LPTPM to use an externally generated global time base counter.
 * When an externally generated timebase is used, the internal LPTPM counter is
 * not used by the channels but can be used to generate a periodic interrupt or
 * DMA request using the Modulo register and timer overflow flag.
 *
 * Values:
 * - 0 - All channels use the internally generated LPTPM counter as their
 *     timebase
 * - 1 - All channels use an externally generated global timebase as their
 *     timebase
 */
/*@{*/
#define BP_TPM_CONF_GTBEEN   (9U)          /*!< Bit position for TPM_CONF_GTBEEN. */
#define BM_TPM_CONF_GTBEEN   (0x00000200U) /*!< Bit mask for TPM_CONF_GTBEEN. */
#define BS_TPM_CONF_GTBEEN   (1U)          /*!< Bit field size in bits for TPM_CONF_GTBEEN. */

/*! @brief Read current value of the TPM_CONF_GTBEEN field. */
#define BR_TPM_CONF_GTBEEN(x) (BME_UBFX32(HW_TPM_CONF_ADDR(x), BP_TPM_CONF_GTBEEN, BS_TPM_CONF_GTBEEN))

/*! @brief Format value for bitfield TPM_CONF_GTBEEN. */
#define BF_TPM_CONF_GTBEEN(v) ((uint32_t)((uint32_t)(v) << BP_TPM_CONF_GTBEEN) & BM_TPM_CONF_GTBEEN)

/*! @brief Set the GTBEEN field to a new value. */
#define BW_TPM_CONF_GTBEEN(x, v) (BME_BFI32(HW_TPM_CONF_ADDR(x), ((uint32_t)(v) << BP_TPM_CONF_GTBEEN), BP_TPM_CONF_GTBEEN, 1))
/*@}*/

/*!
 * @name Register TPM_CONF, field CSOT[16] (RW)
 *
 * When set, the LPTPM counter will not start incrementing after it is enabled
 * until a rising edge on the selected trigger input is detected. If the LPTPM
 * counter is stopped due to an overflow, a rising edge on the selected trigger
 * input will also cause the LPTPM counter to start incrementing again. The trigger
 * input is ignored if the LPTPM counter is paused during debug mode or doze mode.
 * This field should only be changed when the LPTPM counter is disabled.
 *
 * Values:
 * - 0 - LPTPM counter starts to increment immediately, once it is enabled.
 * - 1 - LPTPM counter only starts to increment when it a rising edge on the
 *     selected input trigger is detected, after it has been enabled or after it has
 *     stopped due to overflow.
 */
/*@{*/
#define BP_TPM_CONF_CSOT     (16U)         /*!< Bit position for TPM_CONF_CSOT. */
#define BM_TPM_CONF_CSOT     (0x00010000U) /*!< Bit mask for TPM_CONF_CSOT. */
#define BS_TPM_CONF_CSOT     (1U)          /*!< Bit field size in bits for TPM_CONF_CSOT. */

/*! @brief Read current value of the TPM_CONF_CSOT field. */
#define BR_TPM_CONF_CSOT(x)  (BME_UBFX32(HW_TPM_CONF_ADDR(x), BP_TPM_CONF_CSOT, BS_TPM_CONF_CSOT))

/*! @brief Format value for bitfield TPM_CONF_CSOT. */
#define BF_TPM_CONF_CSOT(v)  ((uint32_t)((uint32_t)(v) << BP_TPM_CONF_CSOT) & BM_TPM_CONF_CSOT)

/*! @brief Set the CSOT field to a new value. */
#define BW_TPM_CONF_CSOT(x, v) (BME_BFI32(HW_TPM_CONF_ADDR(x), ((uint32_t)(v) << BP_TPM_CONF_CSOT), BP_TPM_CONF_CSOT, 1))
/*@}*/

/*!
 * @name Register TPM_CONF, field CSOO[17] (RW)
 *
 * When set, the LPTPM counter will stop incrementing once the counter equals
 * the MOD value and incremented (this also sets the TOF). Reloading the counter
 * with zero due to writing to the counter register or due to a trigger input does
 * not cause the counter to stop incrementing. Once the counter has stopped
 * incrementing, the counter will not start incrementing unless it is disabled and
 * then enabled again, or a rising edge on the selected trigger input is detected
 * when CSOT set. This field should only be changed when the LPTPM counter is
 * disabled.
 *
 * Values:
 * - 0 - LPTPM counter continues incrementing or decrementing after overflow
 * - 1 - LPTPM counter stops incrementing or decrementing after overflow.
 */
/*@{*/
#define BP_TPM_CONF_CSOO     (17U)         /*!< Bit position for TPM_CONF_CSOO. */
#define BM_TPM_CONF_CSOO     (0x00020000U) /*!< Bit mask for TPM_CONF_CSOO. */
#define BS_TPM_CONF_CSOO     (1U)          /*!< Bit field size in bits for TPM_CONF_CSOO. */

/*! @brief Read current value of the TPM_CONF_CSOO field. */
#define BR_TPM_CONF_CSOO(x)  (BME_UBFX32(HW_TPM_CONF_ADDR(x), BP_TPM_CONF_CSOO, BS_TPM_CONF_CSOO))

/*! @brief Format value for bitfield TPM_CONF_CSOO. */
#define BF_TPM_CONF_CSOO(v)  ((uint32_t)((uint32_t)(v) << BP_TPM_CONF_CSOO) & BM_TPM_CONF_CSOO)

/*! @brief Set the CSOO field to a new value. */
#define BW_TPM_CONF_CSOO(x, v) (BME_BFI32(HW_TPM_CONF_ADDR(x), ((uint32_t)(v) << BP_TPM_CONF_CSOO), BP_TPM_CONF_CSOO, 1))
/*@}*/

/*!
 * @name Register TPM_CONF, field CROT[18] (RW)
 *
 * When set, the LPTPM counter will reload with zero (and initialize PWM outputs
 * to their default value) when a rising edge is detected on the selected
 * trigger input. The trigger input is ignored if the LPTPM counter is paused during
 * debug mode or doze mode. This field should only be changed when the LPTPM
 * counter is disabled.
 *
 * Values:
 * - 0 - Counter is not reloaded due to a rising edge on the selected input
 *     trigger
 * - 1 - Counter is reloaded when a rising edge is detected on the selected
 *     input trigger
 */
/*@{*/
#define BP_TPM_CONF_CROT     (18U)         /*!< Bit position for TPM_CONF_CROT. */
#define BM_TPM_CONF_CROT     (0x00040000U) /*!< Bit mask for TPM_CONF_CROT. */
#define BS_TPM_CONF_CROT     (1U)          /*!< Bit field size in bits for TPM_CONF_CROT. */

/*! @brief Read current value of the TPM_CONF_CROT field. */
#define BR_TPM_CONF_CROT(x)  (BME_UBFX32(HW_TPM_CONF_ADDR(x), BP_TPM_CONF_CROT, BS_TPM_CONF_CROT))

/*! @brief Format value for bitfield TPM_CONF_CROT. */
#define BF_TPM_CONF_CROT(v)  ((uint32_t)((uint32_t)(v) << BP_TPM_CONF_CROT) & BM_TPM_CONF_CROT)

/*! @brief Set the CROT field to a new value. */
#define BW_TPM_CONF_CROT(x, v) (BME_BFI32(HW_TPM_CONF_ADDR(x), ((uint32_t)(v) << BP_TPM_CONF_CROT), BP_TPM_CONF_CROT, 1))
/*@}*/

/*!
 * @name Register TPM_CONF, field TRGSEL[27:24] (RW)
 *
 * Selects the input trigger to use for starting the counter and/or reloading
 * the counter. This field should only be changed when the LPTPM counter is
 * disabled. See Chip configuration section for available options.
 */
/*@{*/
#define BP_TPM_CONF_TRGSEL   (24U)         /*!< Bit position for TPM_CONF_TRGSEL. */
#define BM_TPM_CONF_TRGSEL   (0x0F000000U) /*!< Bit mask for TPM_CONF_TRGSEL. */
#define BS_TPM_CONF_TRGSEL   (4U)          /*!< Bit field size in bits for TPM_CONF_TRGSEL. */

/*! @brief Read current value of the TPM_CONF_TRGSEL field. */
#define BR_TPM_CONF_TRGSEL(x) (BME_UBFX32(HW_TPM_CONF_ADDR(x), BP_TPM_CONF_TRGSEL, BS_TPM_CONF_TRGSEL))

/*! @brief Format value for bitfield TPM_CONF_TRGSEL. */
#define BF_TPM_CONF_TRGSEL(v) ((uint32_t)((uint32_t)(v) << BP_TPM_CONF_TRGSEL) & BM_TPM_CONF_TRGSEL)

/*! @brief Set the TRGSEL field to a new value. */
#define BW_TPM_CONF_TRGSEL(x, v) (BME_BFI32(HW_TPM_CONF_ADDR(x), ((uint32_t)(v) << BP_TPM_CONF_TRGSEL), BP_TPM_CONF_TRGSEL, 4))
/*@}*/

/*******************************************************************************
 * hw_tpm_t - module struct
 ******************************************************************************/
/*!
 * @brief All TPM module registers.
 */
#pragma pack(1)
typedef struct _hw_tpm
{
    __IO hw_tpm_sc_t SC;                   /*!< [0x0] Status and Control */
    __IO hw_tpm_cnt_t CNT;                 /*!< [0x4] Counter */
    __IO hw_tpm_mod_t MOD;                 /*!< [0x8] Modulo */
    struct {
        __IO hw_tpm_cnsc_t CnSC;           /*!< [0xC] Channel (n) Status and Control */
        __IO hw_tpm_cnv_t CnV;             /*!< [0x10] Channel (n) Value */
    } CONTROLS[6];
    uint8_t _reserved0[20];
    __IO hw_tpm_status_t STATUS;           /*!< [0x50] Capture and Compare Status */
    uint8_t _reserved1[48];
    __IO hw_tpm_conf_t CONF;               /*!< [0x84] Configuration */
} hw_tpm_t;
#pragma pack()

/*! @brief Macro to access all TPM registers. */
/*! @param x TPM module instance base address. */
/*! @return Reference (not a pointer) to the registers struct. To get a pointer to the struct,
 *     use the '&' operator, like <code>&HW_TPM(TPM0_BASE)</code>. */
#define HW_TPM(x)      (*(hw_tpm_t *)(x))

#endif /* __HW_TPM_REGISTERS_H__ */
/* v33/140401/2.1.0 */
/* EOF */

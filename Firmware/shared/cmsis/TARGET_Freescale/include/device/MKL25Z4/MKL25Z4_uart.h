/*
 * Copyright (c) 2014, Freescale Semiconductor, Inc.
 * All rights reserved.
 *
 * THIS SOFTWARE IS PROVIDED BY FREESCALE "AS IS" AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
 * SHALL FREESCALE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
 * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
 * OF SUCH DAMAGE.
 */
/*
 * WARNING! DO NOT EDIT THIS FILE DIRECTLY!
 *
 * This file was generated automatically and any changes may be lost.
 */
#ifndef __HW_UART_REGISTERS_H__
#define __HW_UART_REGISTERS_H__

#include "MKL25Z4.h"
#include "fsl_bitband.h"

/*
 * MKL25Z4 UART
 *
 * Universal Asynchronous Receiver/Transmitter (UART)
 *
 * Registers defined in this header file:
 * - HW_UART_BDH - UART Baud Rate Register: High
 * - HW_UART_BDL - UART Baud Rate Register: Low
 * - HW_UART_C1 - UART Control Register 1
 * - HW_UART_C2 - UART Control Register 2
 * - HW_UART_S1 - UART Status Register 1
 * - HW_UART_S2 - UART Status Register 2
 * - HW_UART_C3 - UART Control Register 3
 * - HW_UART_D - UART Data Register
 * - HW_UART_C4 - UART Control Register 4
 *
 * - hw_uart_t - Struct containing all module registers.
 */

#define HW_UART_INSTANCE_COUNT (2U) /*!< Number of instances of the UART module. */
#define HW_UART1 (1U) /*!< Instance number for UART1. */
#define HW_UART2 (2U) /*!< Instance number for UART2. */

/*******************************************************************************
 * HW_UART_BDH - UART Baud Rate Register: High
 ******************************************************************************/

/*!
 * @brief HW_UART_BDH - UART Baud Rate Register: High (RW)
 *
 * Reset value: 0x00U
 *
 * This register, along with UART_BDL, controls the prescale divisor for UART
 * baud rate generation. To update the 13-bit baud rate setting [SBR12:SBR0], first
 * write to UART_BDH to buffer the high half of the new value and then write to
 * UART_BDL. The working value in UART_BDH does not change until UART_BDL is
 * written.
 */
typedef union _hw_uart_bdh
{
    uint8_t U;
    struct _hw_uart_bdh_bitfields
    {
        uint8_t SBR : 5;               /*!< [4:0] Baud Rate Modulo Divisor. */
        uint8_t SBNS : 1;              /*!< [5] Stop Bit Number Select */
        uint8_t RXEDGIE : 1;           /*!< [6] RxD Input Active Edge Interrupt Enable
                                        * (for RXEDGIF) */
        uint8_t LBKDIE : 1;            /*!< [7] LIN Break Detect Interrupt Enable (for
                                        * LBKDIF) */
    } B;
} hw_uart_bdh_t;

/*!
 * @name Constants and macros for entire UART_BDH register
 */
/*@{*/
#define HW_UART_BDH_ADDR(x)      ((x) + 0x0U)

#define HW_UART_BDH(x)           (*(__IO hw_uart_bdh_t *) HW_UART_BDH_ADDR(x))
#define HW_UART_BDH_RD(x)        (HW_UART_BDH(x).U)
#define HW_UART_BDH_WR(x, v)     (HW_UART_BDH(x).U = (v))
#define HW_UART_BDH_SET(x, v)    (BME_OR8(HW_UART_BDH_ADDR(x), (uint8_t)(v)))
#define HW_UART_BDH_CLR(x, v)    (BME_AND8(HW_UART_BDH_ADDR(x), (uint8_t)(~(v))))
#define HW_UART_BDH_TOG(x, v)    (BME_XOR8(HW_UART_BDH_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual UART_BDH bitfields
 */

/*!
 * @name Register UART_BDH, field SBR[4:0] (RW)
 *
 * The 13 bits in SBR[12:0] are referred to collectively as BR, and they set the
 * modulo divide rate for the UART baud rate generator. When BR is cleared, the
 * UART baud rate generator is disabled to reduce supply current. When BR is 1 -
 * 8191, the UART baud rate equals BUSCLK/(16*BR).
 */
/*@{*/
#define BP_UART_BDH_SBR      (0U)          /*!< Bit position for UART_BDH_SBR. */
#define BM_UART_BDH_SBR      (0x1FU)       /*!< Bit mask for UART_BDH_SBR. */
#define BS_UART_BDH_SBR      (5U)          /*!< Bit field size in bits for UART_BDH_SBR. */

/*! @brief Read current value of the UART_BDH_SBR field. */
#define BR_UART_BDH_SBR(x)   (BME_UBFX8(HW_UART_BDH_ADDR(x), BP_UART_BDH_SBR, BS_UART_BDH_SBR))

/*! @brief Format value for bitfield UART_BDH_SBR. */
#define BF_UART_BDH_SBR(v)   ((uint8_t)((uint8_t)(v) << BP_UART_BDH_SBR) & BM_UART_BDH_SBR)

/*! @brief Set the SBR field to a new value. */
#define BW_UART_BDH_SBR(x, v) (BME_BFI8(HW_UART_BDH_ADDR(x), ((uint8_t)(v) << BP_UART_BDH_SBR), BP_UART_BDH_SBR, 5))
/*@}*/

/*!
 * @name Register UART_BDH, field SBNS[5] (RW)
 *
 * SBNS determines whether data characters are one or two stop bits.
 *
 * Values:
 * - 0 - One stop bit.
 * - 1 - Two stop bit.
 */
/*@{*/
#define BP_UART_BDH_SBNS     (5U)          /*!< Bit position for UART_BDH_SBNS. */
#define BM_UART_BDH_SBNS     (0x20U)       /*!< Bit mask for UART_BDH_SBNS. */
#define BS_UART_BDH_SBNS     (1U)          /*!< Bit field size in bits for UART_BDH_SBNS. */

/*! @brief Read current value of the UART_BDH_SBNS field. */
#define BR_UART_BDH_SBNS(x)  (BME_UBFX8(HW_UART_BDH_ADDR(x), BP_UART_BDH_SBNS, BS_UART_BDH_SBNS))

/*! @brief Format value for bitfield UART_BDH_SBNS. */
#define BF_UART_BDH_SBNS(v)  ((uint8_t)((uint8_t)(v) << BP_UART_BDH_SBNS) & BM_UART_BDH_SBNS)

/*! @brief Set the SBNS field to a new value. */
#define BW_UART_BDH_SBNS(x, v) (BME_BFI8(HW_UART_BDH_ADDR(x), ((uint8_t)(v) << BP_UART_BDH_SBNS), BP_UART_BDH_SBNS, 1))
/*@}*/

/*!
 * @name Register UART_BDH, field RXEDGIE[6] (RW)
 *
 * Values:
 * - 0 - Hardware interrupts from UART_S2[RXEDGIF] disabled (use polling).
 * - 1 - Hardware interrupt requested when UART_S2[RXEDGIF] flag is 1.
 */
/*@{*/
#define BP_UART_BDH_RXEDGIE  (6U)          /*!< Bit position for UART_BDH_RXEDGIE. */
#define BM_UART_BDH_RXEDGIE  (0x40U)       /*!< Bit mask for UART_BDH_RXEDGIE. */
#define BS_UART_BDH_RXEDGIE  (1U)          /*!< Bit field size in bits for UART_BDH_RXEDGIE. */

/*! @brief Read current value of the UART_BDH_RXEDGIE field. */
#define BR_UART_BDH_RXEDGIE(x) (BME_UBFX8(HW_UART_BDH_ADDR(x), BP_UART_BDH_RXEDGIE, BS_UART_BDH_RXEDGIE))

/*! @brief Format value for bitfield UART_BDH_RXEDGIE. */
#define BF_UART_BDH_RXEDGIE(v) ((uint8_t)((uint8_t)(v) << BP_UART_BDH_RXEDGIE) & BM_UART_BDH_RXEDGIE)

/*! @brief Set the RXEDGIE field to a new value. */
#define BW_UART_BDH_RXEDGIE(x, v) (BME_BFI8(HW_UART_BDH_ADDR(x), ((uint8_t)(v) << BP_UART_BDH_RXEDGIE), BP_UART_BDH_RXEDGIE, 1))
/*@}*/

/*!
 * @name Register UART_BDH, field LBKDIE[7] (RW)
 *
 * Values:
 * - 0 - Hardware interrupts from UART_S2[LBKDIF] disabled (use polling).
 * - 1 - Hardware interrupt requested when UART_S2[LBKDIF] flag is 1.
 */
/*@{*/
#define BP_UART_BDH_LBKDIE   (7U)          /*!< Bit position for UART_BDH_LBKDIE. */
#define BM_UART_BDH_LBKDIE   (0x80U)       /*!< Bit mask for UART_BDH_LBKDIE. */
#define BS_UART_BDH_LBKDIE   (1U)          /*!< Bit field size in bits for UART_BDH_LBKDIE. */

/*! @brief Read current value of the UART_BDH_LBKDIE field. */
#define BR_UART_BDH_LBKDIE(x) (BME_UBFX8(HW_UART_BDH_ADDR(x), BP_UART_BDH_LBKDIE, BS_UART_BDH_LBKDIE))

/*! @brief Format value for bitfield UART_BDH_LBKDIE. */
#define BF_UART_BDH_LBKDIE(v) ((uint8_t)((uint8_t)(v) << BP_UART_BDH_LBKDIE) & BM_UART_BDH_LBKDIE)

/*! @brief Set the LBKDIE field to a new value. */
#define BW_UART_BDH_LBKDIE(x, v) (BME_BFI8(HW_UART_BDH_ADDR(x), ((uint8_t)(v) << BP_UART_BDH_LBKDIE), BP_UART_BDH_LBKDIE, 1))
/*@}*/

/*******************************************************************************
 * HW_UART_BDL - UART Baud Rate Register: Low
 ******************************************************************************/

/*!
 * @brief HW_UART_BDL - UART Baud Rate Register: Low (RW)
 *
 * Reset value: 0x04U
 *
 * This register, along with UART_BDH, control the prescale divisor for UART
 * baud rate generation. To update the 13-bit baud rate setting [SBR12:SBR0], first
 * write to UART_BDH to buffer the high half of the new value and then write to
 * UART_BDL. The working value in UART_BDH does not change until UART_BDL is
 * written. UART_BDL is reset to a non-zero value, so after reset the baud rate
 * generator remains disabled until the first time the receiver or transmitter is
 * enabled; that is, UART_C2[RE] or UART_C2[TE] bits are written to 1.
 */
typedef union _hw_uart_bdl
{
    uint8_t U;
    struct _hw_uart_bdl_bitfields
    {
        uint8_t SBR : 8;               /*!< [7:0] Baud Rate Modulo Divisor */
    } B;
} hw_uart_bdl_t;

/*!
 * @name Constants and macros for entire UART_BDL register
 */
/*@{*/
#define HW_UART_BDL_ADDR(x)      ((x) + 0x1U)

#define HW_UART_BDL(x)           (*(__IO hw_uart_bdl_t *) HW_UART_BDL_ADDR(x))
#define HW_UART_BDL_RD(x)        (HW_UART_BDL(x).U)
#define HW_UART_BDL_WR(x, v)     (HW_UART_BDL(x).U = (v))
#define HW_UART_BDL_SET(x, v)    (BME_OR8(HW_UART_BDL_ADDR(x), (uint8_t)(v)))
#define HW_UART_BDL_CLR(x, v)    (BME_AND8(HW_UART_BDL_ADDR(x), (uint8_t)(~(v))))
#define HW_UART_BDL_TOG(x, v)    (BME_XOR8(HW_UART_BDL_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual UART_BDL bitfields
 */

/*!
 * @name Register UART_BDL, field SBR[7:0] (RW)
 *
 * These 13 bits in SBR[12:0] are referred to collectively as BR. They set the
 * modulo divide rate for the UART baud rate generator. When BR is cleared, the
 * UART baud rate generator is disabled to reduce supply current. When BR is 1 -
 * 8191, the UART baud rate equals BUSCLK/(16*BR).
 */
/*@{*/
#define BP_UART_BDL_SBR      (0U)          /*!< Bit position for UART_BDL_SBR. */
#define BM_UART_BDL_SBR      (0xFFU)       /*!< Bit mask for UART_BDL_SBR. */
#define BS_UART_BDL_SBR      (8U)          /*!< Bit field size in bits for UART_BDL_SBR. */

/*! @brief Read current value of the UART_BDL_SBR field. */
#define BR_UART_BDL_SBR(x)   (HW_UART_BDL(x).U)

/*! @brief Format value for bitfield UART_BDL_SBR. */
#define BF_UART_BDL_SBR(v)   ((uint8_t)((uint8_t)(v) << BP_UART_BDL_SBR) & BM_UART_BDL_SBR)

/*! @brief Set the SBR field to a new value. */
#define BW_UART_BDL_SBR(x, v) (HW_UART_BDL_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_UART_C1 - UART Control Register 1
 ******************************************************************************/

/*!
 * @brief HW_UART_C1 - UART Control Register 1 (RW)
 *
 * Reset value: 0x00U
 *
 * This read/write register controls various optional features of the UART
 * system.
 */
typedef union _hw_uart_c1
{
    uint8_t U;
    struct _hw_uart_c1_bitfields
    {
        uint8_t PT : 1;                /*!< [0] Parity Type */
        uint8_t PE : 1;                /*!< [1] Parity Enable */
        uint8_t ILT : 1;               /*!< [2] Idle Line Type Select */
        uint8_t WAKE : 1;              /*!< [3] Receiver Wakeup Method Select */
        uint8_t M : 1;                 /*!< [4] 9-Bit or 8-Bit Mode Select */
        uint8_t RSRC : 1;              /*!< [5] Receiver Source Select */
        uint8_t UARTSWAI : 1;          /*!< [6] UART Stops in Wait Mode */
        uint8_t LOOPS : 1;             /*!< [7] Loop Mode Select */
    } B;
} hw_uart_c1_t;

/*!
 * @name Constants and macros for entire UART_C1 register
 */
/*@{*/
#define HW_UART_C1_ADDR(x)       ((x) + 0x2U)

#define HW_UART_C1(x)            (*(__IO hw_uart_c1_t *) HW_UART_C1_ADDR(x))
#define HW_UART_C1_RD(x)         (HW_UART_C1(x).U)
#define HW_UART_C1_WR(x, v)      (HW_UART_C1(x).U = (v))
#define HW_UART_C1_SET(x, v)     (BME_OR8(HW_UART_C1_ADDR(x), (uint8_t)(v)))
#define HW_UART_C1_CLR(x, v)     (BME_AND8(HW_UART_C1_ADDR(x), (uint8_t)(~(v))))
#define HW_UART_C1_TOG(x, v)     (BME_XOR8(HW_UART_C1_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual UART_C1 bitfields
 */

/*!
 * @name Register UART_C1, field PT[0] (RW)
 *
 * Provided parity is enabled (PE = 1), this bit selects even or odd parity. Odd
 * parity means the total number of 1s in the data character, including the
 * parity bit, is odd. Even parity means the total number of 1s in the data
 * character, including the parity bit, is even.
 *
 * Values:
 * - 0 - Even parity.
 * - 1 - Odd parity.
 */
/*@{*/
#define BP_UART_C1_PT        (0U)          /*!< Bit position for UART_C1_PT. */
#define BM_UART_C1_PT        (0x01U)       /*!< Bit mask for UART_C1_PT. */
#define BS_UART_C1_PT        (1U)          /*!< Bit field size in bits for UART_C1_PT. */

/*! @brief Read current value of the UART_C1_PT field. */
#define BR_UART_C1_PT(x)     (BME_UBFX8(HW_UART_C1_ADDR(x), BP_UART_C1_PT, BS_UART_C1_PT))

/*! @brief Format value for bitfield UART_C1_PT. */
#define BF_UART_C1_PT(v)     ((uint8_t)((uint8_t)(v) << BP_UART_C1_PT) & BM_UART_C1_PT)

/*! @brief Set the PT field to a new value. */
#define BW_UART_C1_PT(x, v)  (BME_BFI8(HW_UART_C1_ADDR(x), ((uint8_t)(v) << BP_UART_C1_PT), BP_UART_C1_PT, 1))
/*@}*/

/*!
 * @name Register UART_C1, field PE[1] (RW)
 *
 * Enables hardware parity generation and checking. When parity is enabled, the
 * most significant bit (msb) of the data character, eighth or ninth data bit, is
 * treated as the parity bit.
 *
 * Values:
 * - 0 - No hardware parity generation or checking.
 * - 1 - Parity enabled.
 */
/*@{*/
#define BP_UART_C1_PE        (1U)          /*!< Bit position for UART_C1_PE. */
#define BM_UART_C1_PE        (0x02U)       /*!< Bit mask for UART_C1_PE. */
#define BS_UART_C1_PE        (1U)          /*!< Bit field size in bits for UART_C1_PE. */

/*! @brief Read current value of the UART_C1_PE field. */
#define BR_UART_C1_PE(x)     (BME_UBFX8(HW_UART_C1_ADDR(x), BP_UART_C1_PE, BS_UART_C1_PE))

/*! @brief Format value for bitfield UART_C1_PE. */
#define BF_UART_C1_PE(v)     ((uint8_t)((uint8_t)(v) << BP_UART_C1_PE) & BM_UART_C1_PE)

/*! @brief Set the PE field to a new value. */
#define BW_UART_C1_PE(x, v)  (BME_BFI8(HW_UART_C1_ADDR(x), ((uint8_t)(v) << BP_UART_C1_PE), BP_UART_C1_PE, 1))
/*@}*/

/*!
 * @name Register UART_C1, field ILT[2] (RW)
 *
 * Setting this bit to 1 ensures that the stop bits and logic 1 bits at the end
 * of a character do not count toward the 10 or 11 bit times of logic high level
 * needed by the idle line detection logic.
 *
 * Values:
 * - 0 - Idle character bit count starts after start bit.
 * - 1 - Idle character bit count starts after stop bit.
 */
/*@{*/
#define BP_UART_C1_ILT       (2U)          /*!< Bit position for UART_C1_ILT. */
#define BM_UART_C1_ILT       (0x04U)       /*!< Bit mask for UART_C1_ILT. */
#define BS_UART_C1_ILT       (1U)          /*!< Bit field size in bits for UART_C1_ILT. */

/*! @brief Read current value of the UART_C1_ILT field. */
#define BR_UART_C1_ILT(x)    (BME_UBFX8(HW_UART_C1_ADDR(x), BP_UART_C1_ILT, BS_UART_C1_ILT))

/*! @brief Format value for bitfield UART_C1_ILT. */
#define BF_UART_C1_ILT(v)    ((uint8_t)((uint8_t)(v) << BP_UART_C1_ILT) & BM_UART_C1_ILT)

/*! @brief Set the ILT field to a new value. */
#define BW_UART_C1_ILT(x, v) (BME_BFI8(HW_UART_C1_ADDR(x), ((uint8_t)(v) << BP_UART_C1_ILT), BP_UART_C1_ILT, 1))
/*@}*/

/*!
 * @name Register UART_C1, field WAKE[3] (RW)
 *
 * Values:
 * - 0 - Idle-line wakeup.
 * - 1 - Address-mark wakeup.
 */
/*@{*/
#define BP_UART_C1_WAKE      (3U)          /*!< Bit position for UART_C1_WAKE. */
#define BM_UART_C1_WAKE      (0x08U)       /*!< Bit mask for UART_C1_WAKE. */
#define BS_UART_C1_WAKE      (1U)          /*!< Bit field size in bits for UART_C1_WAKE. */

/*! @brief Read current value of the UART_C1_WAKE field. */
#define BR_UART_C1_WAKE(x)   (BME_UBFX8(HW_UART_C1_ADDR(x), BP_UART_C1_WAKE, BS_UART_C1_WAKE))

/*! @brief Format value for bitfield UART_C1_WAKE. */
#define BF_UART_C1_WAKE(v)   ((uint8_t)((uint8_t)(v) << BP_UART_C1_WAKE) & BM_UART_C1_WAKE)

/*! @brief Set the WAKE field to a new value. */
#define BW_UART_C1_WAKE(x, v) (BME_BFI8(HW_UART_C1_ADDR(x), ((uint8_t)(v) << BP_UART_C1_WAKE), BP_UART_C1_WAKE, 1))
/*@}*/

/*!
 * @name Register UART_C1, field M[4] (RW)
 *
 * Values:
 * - 0 - Normal - start + 8 data bits (lsb first) + stop.
 * - 1 - Receiver and transmitter use 9-bit data characters start + 8 data bits
 *     (lsb first) + 9th data bit + stop.
 */
/*@{*/
#define BP_UART_C1_M         (4U)          /*!< Bit position for UART_C1_M. */
#define BM_UART_C1_M         (0x10U)       /*!< Bit mask for UART_C1_M. */
#define BS_UART_C1_M         (1U)          /*!< Bit field size in bits for UART_C1_M. */

/*! @brief Read current value of the UART_C1_M field. */
#define BR_UART_C1_M(x)      (BME_UBFX8(HW_UART_C1_ADDR(x), BP_UART_C1_M, BS_UART_C1_M))

/*! @brief Format value for bitfield UART_C1_M. */
#define BF_UART_C1_M(v)      ((uint8_t)((uint8_t)(v) << BP_UART_C1_M) & BM_UART_C1_M)

/*! @brief Set the M field to a new value. */
#define BW_UART_C1_M(x, v)   (BME_BFI8(HW_UART_C1_ADDR(x), ((uint8_t)(v) << BP_UART_C1_M), BP_UART_C1_M, 1))
/*@}*/

/*!
 * @name Register UART_C1, field RSRC[5] (RW)
 *
 * This bit has no meaning or effect unless the LOOPS bit is set to 1. When
 * LOOPS is set, the receiver input is internally connected to the TxD pin and RSRC
 * determines whether this connection is also connected to the transmitter output.
 *
 * Values:
 * - 0 - Provided LOOPS is set, RSRC is cleared, selects internal loop back mode
 *     and the UART does not use the RxD pins.
 * - 1 - Single-wire UART mode where the TxD pin is connected to the transmitter
 *     output and receiver input.
 */
/*@{*/
#define BP_UART_C1_RSRC      (5U)          /*!< Bit position for UART_C1_RSRC. */
#define BM_UART_C1_RSRC      (0x20U)       /*!< Bit mask for UART_C1_RSRC. */
#define BS_UART_C1_RSRC      (1U)          /*!< Bit field size in bits for UART_C1_RSRC. */

/*! @brief Read current value of the UART_C1_RSRC field. */
#define BR_UART_C1_RSRC(x)   (BME_UBFX8(HW_UART_C1_ADDR(x), BP_UART_C1_RSRC, BS_UART_C1_RSRC))

/*! @brief Format value for bitfield UART_C1_RSRC. */
#define BF_UART_C1_RSRC(v)   ((uint8_t)((uint8_t)(v) << BP_UART_C1_RSRC) & BM_UART_C1_RSRC)

/*! @brief Set the RSRC field to a new value. */
#define BW_UART_C1_RSRC(x, v) (BME_BFI8(HW_UART_C1_ADDR(x), ((uint8_t)(v) << BP_UART_C1_RSRC), BP_UART_C1_RSRC, 1))
/*@}*/

/*!
 * @name Register UART_C1, field UARTSWAI[6] (RW)
 *
 * Values:
 * - 0 - UART clocks continue to run in wait mode so the UART can be the source
 *     of an interrupt that wakes up the CPU.
 * - 1 - UART clocks freeze while CPU is in wait mode.
 */
/*@{*/
#define BP_UART_C1_UARTSWAI  (6U)          /*!< Bit position for UART_C1_UARTSWAI. */
#define BM_UART_C1_UARTSWAI  (0x40U)       /*!< Bit mask for UART_C1_UARTSWAI. */
#define BS_UART_C1_UARTSWAI  (1U)          /*!< Bit field size in bits for UART_C1_UARTSWAI. */

/*! @brief Read current value of the UART_C1_UARTSWAI field. */
#define BR_UART_C1_UARTSWAI(x) (BME_UBFX8(HW_UART_C1_ADDR(x), BP_UART_C1_UARTSWAI, BS_UART_C1_UARTSWAI))

/*! @brief Format value for bitfield UART_C1_UARTSWAI. */
#define BF_UART_C1_UARTSWAI(v) ((uint8_t)((uint8_t)(v) << BP_UART_C1_UARTSWAI) & BM_UART_C1_UARTSWAI)

/*! @brief Set the UARTSWAI field to a new value. */
#define BW_UART_C1_UARTSWAI(x, v) (BME_BFI8(HW_UART_C1_ADDR(x), ((uint8_t)(v) << BP_UART_C1_UARTSWAI), BP_UART_C1_UARTSWAI, 1))
/*@}*/

/*!
 * @name Register UART_C1, field LOOPS[7] (RW)
 *
 * Selects between loop back modes and normal 2-pin full-duplex modes. When
 * LOOPS is set, the transmitter output is internally connected to the receiver input.
 *
 * Values:
 * - 0 - Normal operation - RxD and TxD use separate pins.
 * - 1 - Loop mode or single-wire mode where transmitter outputs are internally
 *     connected to receiver input. (See RSRC bit.) RxD pin is not used by UART.
 */
/*@{*/
#define BP_UART_C1_LOOPS     (7U)          /*!< Bit position for UART_C1_LOOPS. */
#define BM_UART_C1_LOOPS     (0x80U)       /*!< Bit mask for UART_C1_LOOPS. */
#define BS_UART_C1_LOOPS     (1U)          /*!< Bit field size in bits for UART_C1_LOOPS. */

/*! @brief Read current value of the UART_C1_LOOPS field. */
#define BR_UART_C1_LOOPS(x)  (BME_UBFX8(HW_UART_C1_ADDR(x), BP_UART_C1_LOOPS, BS_UART_C1_LOOPS))

/*! @brief Format value for bitfield UART_C1_LOOPS. */
#define BF_UART_C1_LOOPS(v)  ((uint8_t)((uint8_t)(v) << BP_UART_C1_LOOPS) & BM_UART_C1_LOOPS)

/*! @brief Set the LOOPS field to a new value. */
#define BW_UART_C1_LOOPS(x, v) (BME_BFI8(HW_UART_C1_ADDR(x), ((uint8_t)(v) << BP_UART_C1_LOOPS), BP_UART_C1_LOOPS, 1))
/*@}*/

/*******************************************************************************
 * HW_UART_C2 - UART Control Register 2
 ******************************************************************************/

/*!
 * @brief HW_UART_C2 - UART Control Register 2 (RW)
 *
 * Reset value: 0x00U
 *
 * This register can be read or written at any time.
 */
typedef union _hw_uart_c2
{
    uint8_t U;
    struct _hw_uart_c2_bitfields
    {
        uint8_t SBK : 1;               /*!< [0] Send Break */
        uint8_t RWU : 1;               /*!< [1] Receiver Wakeup Control */
        uint8_t RE : 1;                /*!< [2] Receiver Enable */
        uint8_t TE : 1;                /*!< [3] Transmitter Enable */
        uint8_t ILIE : 1;              /*!< [4] Idle Line Interrupt Enable for IDLE */
        uint8_t RIE : 1;               /*!< [5] Receiver Interrupt Enable for RDRF */
        uint8_t TCIE : 1;              /*!< [6] Transmission Complete Interrupt Enable for
                                        * TC */
        uint8_t TIE : 1;               /*!< [7] Transmit Interrupt Enable for TDRE */
    } B;
} hw_uart_c2_t;

/*!
 * @name Constants and macros for entire UART_C2 register
 */
/*@{*/
#define HW_UART_C2_ADDR(x)       ((x) + 0x3U)

#define HW_UART_C2(x)            (*(__IO hw_uart_c2_t *) HW_UART_C2_ADDR(x))
#define HW_UART_C2_RD(x)         (HW_UART_C2(x).U)
#define HW_UART_C2_WR(x, v)      (HW_UART_C2(x).U = (v))
#define HW_UART_C2_SET(x, v)     (BME_OR8(HW_UART_C2_ADDR(x), (uint8_t)(v)))
#define HW_UART_C2_CLR(x, v)     (BME_AND8(HW_UART_C2_ADDR(x), (uint8_t)(~(v))))
#define HW_UART_C2_TOG(x, v)     (BME_XOR8(HW_UART_C2_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual UART_C2 bitfields
 */

/*!
 * @name Register UART_C2, field SBK[0] (RW)
 *
 * Writing a 1 and then a 0 to SBK queues a break character in the transmit data
 * stream. Additional break characters of 10 or 11 or 12, 13 or 14 or 15 if
 * BRK13 = 1, bit times of logic 0 are queued as long as SBK is set. Depending on the
 * timing of the set and clear of SBK relative to the information currently
 * being transmitted, a second break character may be queued before software clears
 * SBK.
 *
 * Values:
 * - 0 - Normal transmitter operation.
 * - 1 - Queue break character(s) to be sent.
 */
/*@{*/
#define BP_UART_C2_SBK       (0U)          /*!< Bit position for UART_C2_SBK. */
#define BM_UART_C2_SBK       (0x01U)       /*!< Bit mask for UART_C2_SBK. */
#define BS_UART_C2_SBK       (1U)          /*!< Bit field size in bits for UART_C2_SBK. */

/*! @brief Read current value of the UART_C2_SBK field. */
#define BR_UART_C2_SBK(x)    (BME_UBFX8(HW_UART_C2_ADDR(x), BP_UART_C2_SBK, BS_UART_C2_SBK))

/*! @brief Format value for bitfield UART_C2_SBK. */
#define BF_UART_C2_SBK(v)    ((uint8_t)((uint8_t)(v) << BP_UART_C2_SBK) & BM_UART_C2_SBK)

/*! @brief Set the SBK field to a new value. */
#define BW_UART_C2_SBK(x, v) (BME_BFI8(HW_UART_C2_ADDR(x), ((uint8_t)(v) << BP_UART_C2_SBK), BP_UART_C2_SBK, 1))
/*@}*/

/*!
 * @name Register UART_C2, field RWU[1] (RW)
 *
 * This bit can be written to 1 to place the UART receiver in a standby state
 * where it waits for automatic hardware detection of a selected wakeup condition.
 * The wakeup condition is an idle line between messages, WAKE = 0, idle-line
 * wakeup, or a logic 1 in the most significant data bit in a character, WAKE = 1,
 * address-mark wakeup. Application software sets RWU and, normally, a selected
 * hardware condition automatically clears RWU.
 *
 * Values:
 * - 0 - Normal UART receiver operation.
 * - 1 - UART receiver in standby waiting for wakeup condition.
 */
/*@{*/
#define BP_UART_C2_RWU       (1U)          /*!< Bit position for UART_C2_RWU. */
#define BM_UART_C2_RWU       (0x02U)       /*!< Bit mask for UART_C2_RWU. */
#define BS_UART_C2_RWU       (1U)          /*!< Bit field size in bits for UART_C2_RWU. */

/*! @brief Read current value of the UART_C2_RWU field. */
#define BR_UART_C2_RWU(x)    (BME_UBFX8(HW_UART_C2_ADDR(x), BP_UART_C2_RWU, BS_UART_C2_RWU))

/*! @brief Format value for bitfield UART_C2_RWU. */
#define BF_UART_C2_RWU(v)    ((uint8_t)((uint8_t)(v) << BP_UART_C2_RWU) & BM_UART_C2_RWU)

/*! @brief Set the RWU field to a new value. */
#define BW_UART_C2_RWU(x, v) (BME_BFI8(HW_UART_C2_ADDR(x), ((uint8_t)(v) << BP_UART_C2_RWU), BP_UART_C2_RWU, 1))
/*@}*/

/*!
 * @name Register UART_C2, field RE[2] (RW)
 *
 * When the UART receiver is off, the RxD pin reverts to being a general-purpose
 * port I/O pin. If LOOPS is set the RxD pin reverts to being a general-purpose
 * I/O pin even if RE is set.
 *
 * Values:
 * - 0 - Receiver off.
 * - 1 - Receiver on.
 */
/*@{*/
#define BP_UART_C2_RE        (2U)          /*!< Bit position for UART_C2_RE. */
#define BM_UART_C2_RE        (0x04U)       /*!< Bit mask for UART_C2_RE. */
#define BS_UART_C2_RE        (1U)          /*!< Bit field size in bits for UART_C2_RE. */

/*! @brief Read current value of the UART_C2_RE field. */
#define BR_UART_C2_RE(x)     (BME_UBFX8(HW_UART_C2_ADDR(x), BP_UART_C2_RE, BS_UART_C2_RE))

/*! @brief Format value for bitfield UART_C2_RE. */
#define BF_UART_C2_RE(v)     ((uint8_t)((uint8_t)(v) << BP_UART_C2_RE) & BM_UART_C2_RE)

/*! @brief Set the RE field to a new value. */
#define BW_UART_C2_RE(x, v)  (BME_BFI8(HW_UART_C2_ADDR(x), ((uint8_t)(v) << BP_UART_C2_RE), BP_UART_C2_RE, 1))
/*@}*/

/*!
 * @name Register UART_C2, field TE[3] (RW)
 *
 * TE must be 1 to use the UART transmitter. When TE is set, the UART forces the
 * TxD pin to act as an output for the UART system. When the UART is configured
 * for single-wire operation (LOOPS = RSRC = 1), TXDIR controls the direction of
 * traffic on the single UART communication line (TxD pin). TE can also queue an
 * idle character by clearing TE then setting TE while a transmission is in
 * progress. When TE is written to 0, the transmitter keeps control of the port TxD
 * pin until any data, queued idle, or queued break character finishes transmitting
 * before allowing the pin to revert to a general-purpose I/O pin.
 *
 * Values:
 * - 0 - Transmitter off.
 * - 1 - Transmitter on.
 */
/*@{*/
#define BP_UART_C2_TE        (3U)          /*!< Bit position for UART_C2_TE. */
#define BM_UART_C2_TE        (0x08U)       /*!< Bit mask for UART_C2_TE. */
#define BS_UART_C2_TE        (1U)          /*!< Bit field size in bits for UART_C2_TE. */

/*! @brief Read current value of the UART_C2_TE field. */
#define BR_UART_C2_TE(x)     (BME_UBFX8(HW_UART_C2_ADDR(x), BP_UART_C2_TE, BS_UART_C2_TE))

/*! @brief Format value for bitfield UART_C2_TE. */
#define BF_UART_C2_TE(v)     ((uint8_t)((uint8_t)(v) << BP_UART_C2_TE) & BM_UART_C2_TE)

/*! @brief Set the TE field to a new value. */
#define BW_UART_C2_TE(x, v)  (BME_BFI8(HW_UART_C2_ADDR(x), ((uint8_t)(v) << BP_UART_C2_TE), BP_UART_C2_TE, 1))
/*@}*/

/*!
 * @name Register UART_C2, field ILIE[4] (RW)
 *
 * Values:
 * - 0 - Hardware interrupts from IDLE disabled; use polling.
 * - 1 - Hardware interrupt requested when IDLE flag is 1.
 */
/*@{*/
#define BP_UART_C2_ILIE      (4U)          /*!< Bit position for UART_C2_ILIE. */
#define BM_UART_C2_ILIE      (0x10U)       /*!< Bit mask for UART_C2_ILIE. */
#define BS_UART_C2_ILIE      (1U)          /*!< Bit field size in bits for UART_C2_ILIE. */

/*! @brief Read current value of the UART_C2_ILIE field. */
#define BR_UART_C2_ILIE(x)   (BME_UBFX8(HW_UART_C2_ADDR(x), BP_UART_C2_ILIE, BS_UART_C2_ILIE))

/*! @brief Format value for bitfield UART_C2_ILIE. */
#define BF_UART_C2_ILIE(v)   ((uint8_t)((uint8_t)(v) << BP_UART_C2_ILIE) & BM_UART_C2_ILIE)

/*! @brief Set the ILIE field to a new value. */
#define BW_UART_C2_ILIE(x, v) (BME_BFI8(HW_UART_C2_ADDR(x), ((uint8_t)(v) << BP_UART_C2_ILIE), BP_UART_C2_ILIE, 1))
/*@}*/

/*!
 * @name Register UART_C2, field RIE[5] (RW)
 *
 * Values:
 * - 0 - Hardware interrupts from RDRF disabled; use polling.
 * - 1 - Hardware interrupt requested when RDRF flag is 1.
 */
/*@{*/
#define BP_UART_C2_RIE       (5U)          /*!< Bit position for UART_C2_RIE. */
#define BM_UART_C2_RIE       (0x20U)       /*!< Bit mask for UART_C2_RIE. */
#define BS_UART_C2_RIE       (1U)          /*!< Bit field size in bits for UART_C2_RIE. */

/*! @brief Read current value of the UART_C2_RIE field. */
#define BR_UART_C2_RIE(x)    (BME_UBFX8(HW_UART_C2_ADDR(x), BP_UART_C2_RIE, BS_UART_C2_RIE))

/*! @brief Format value for bitfield UART_C2_RIE. */
#define BF_UART_C2_RIE(v)    ((uint8_t)((uint8_t)(v) << BP_UART_C2_RIE) & BM_UART_C2_RIE)

/*! @brief Set the RIE field to a new value. */
#define BW_UART_C2_RIE(x, v) (BME_BFI8(HW_UART_C2_ADDR(x), ((uint8_t)(v) << BP_UART_C2_RIE), BP_UART_C2_RIE, 1))
/*@}*/

/*!
 * @name Register UART_C2, field TCIE[6] (RW)
 *
 * Values:
 * - 0 - Hardware interrupts from TC disabled; use polling.
 * - 1 - Hardware interrupt requested when TC flag is 1.
 */
/*@{*/
#define BP_UART_C2_TCIE      (6U)          /*!< Bit position for UART_C2_TCIE. */
#define BM_UART_C2_TCIE      (0x40U)       /*!< Bit mask for UART_C2_TCIE. */
#define BS_UART_C2_TCIE      (1U)          /*!< Bit field size in bits for UART_C2_TCIE. */

/*! @brief Read current value of the UART_C2_TCIE field. */
#define BR_UART_C2_TCIE(x)   (BME_UBFX8(HW_UART_C2_ADDR(x), BP_UART_C2_TCIE, BS_UART_C2_TCIE))

/*! @brief Format value for bitfield UART_C2_TCIE. */
#define BF_UART_C2_TCIE(v)   ((uint8_t)((uint8_t)(v) << BP_UART_C2_TCIE) & BM_UART_C2_TCIE)

/*! @brief Set the TCIE field to a new value. */
#define BW_UART_C2_TCIE(x, v) (BME_BFI8(HW_UART_C2_ADDR(x), ((uint8_t)(v) << BP_UART_C2_TCIE), BP_UART_C2_TCIE, 1))
/*@}*/

/*!
 * @name Register UART_C2, field TIE[7] (RW)
 *
 * Values:
 * - 0 - Hardware interrupts from TDRE disabled; use polling.
 * - 1 - Hardware interrupt requested when TDRE flag is 1.
 */
/*@{*/
#define BP_UART_C2_TIE       (7U)          /*!< Bit position for UART_C2_TIE. */
#define BM_UART_C2_TIE       (0x80U)       /*!< Bit mask for UART_C2_TIE. */
#define BS_UART_C2_TIE       (1U)          /*!< Bit field size in bits for UART_C2_TIE. */

/*! @brief Read current value of the UART_C2_TIE field. */
#define BR_UART_C2_TIE(x)    (BME_UBFX8(HW_UART_C2_ADDR(x), BP_UART_C2_TIE, BS_UART_C2_TIE))

/*! @brief Format value for bitfield UART_C2_TIE. */
#define BF_UART_C2_TIE(v)    ((uint8_t)((uint8_t)(v) << BP_UART_C2_TIE) & BM_UART_C2_TIE)

/*! @brief Set the TIE field to a new value. */
#define BW_UART_C2_TIE(x, v) (BME_BFI8(HW_UART_C2_ADDR(x), ((uint8_t)(v) << BP_UART_C2_TIE), BP_UART_C2_TIE, 1))
/*@}*/

/*******************************************************************************
 * HW_UART_S1 - UART Status Register 1
 ******************************************************************************/

/*!
 * @brief HW_UART_S1 - UART Status Register 1 (RO)
 *
 * Reset value: 0xC0U
 *
 * This register has eight read-only status flags. Writes have no effect.
 * Special software sequences, which do not involve writing to this register, clear
 * these status flags.
 */
typedef union _hw_uart_s1
{
    uint8_t U;
    struct _hw_uart_s1_bitfields
    {
        uint8_t PF : 1;                /*!< [0] Parity Error Flag */
        uint8_t FE : 1;                /*!< [1] Framing Error Flag */
        uint8_t NF : 1;                /*!< [2] Noise Flag */
        uint8_t OR : 1;                /*!< [3] Receiver Overrun Flag */
        uint8_t IDLE : 1;              /*!< [4] Idle Line Flag */
        uint8_t RDRF : 1;              /*!< [5] Receive Data Register Full Flag */
        uint8_t TC : 1;                /*!< [6] Transmission Complete Flag */
        uint8_t TDRE : 1;              /*!< [7] Transmit Data Register Empty Flag */
    } B;
} hw_uart_s1_t;

/*!
 * @name Constants and macros for entire UART_S1 register
 */
/*@{*/
#define HW_UART_S1_ADDR(x)       ((x) + 0x4U)

#define HW_UART_S1(x)            (*(__I hw_uart_s1_t *) HW_UART_S1_ADDR(x))
#define HW_UART_S1_RD(x)         (HW_UART_S1(x).U)
/*@}*/

/*
 * Constants & macros for individual UART_S1 bitfields
 */

/*!
 * @name Register UART_S1, field PF[0] (RO)
 *
 * PF is set at the same time as RDRF when parity is enabled (PE = 1) and the
 * parity bit in the received character does not agree with the expected parity
 * value. To clear PF, read UART_S1 and then read the UART data register (UART_D).
 *
 * Values:
 * - 0 - No parity error.
 * - 1 - Parity error.
 */
/*@{*/
#define BP_UART_S1_PF        (0U)          /*!< Bit position for UART_S1_PF. */
#define BM_UART_S1_PF        (0x01U)       /*!< Bit mask for UART_S1_PF. */
#define BS_UART_S1_PF        (1U)          /*!< Bit field size in bits for UART_S1_PF. */

/*! @brief Read current value of the UART_S1_PF field. */
#define BR_UART_S1_PF(x)     (BME_UBFX8(HW_UART_S1_ADDR(x), BP_UART_S1_PF, BS_UART_S1_PF))
/*@}*/

/*!
 * @name Register UART_S1, field FE[1] (RO)
 *
 * FE is set at the same time as RDRF when the receiver detects a logic 0 where
 * the stop bits was expected. This suggests the receiver was not properly
 * aligned to a character frame. To clear FE, read UART_S1 with FE set and then read
 * the UART data register (UART_D).
 *
 * Values:
 * - 0 - No framing error detected. This does not guarantee the framing is
 *     correct.
 * - 1 - Framing error.
 */
/*@{*/
#define BP_UART_S1_FE        (1U)          /*!< Bit position for UART_S1_FE. */
#define BM_UART_S1_FE        (0x02U)       /*!< Bit mask for UART_S1_FE. */
#define BS_UART_S1_FE        (1U)          /*!< Bit field size in bits for UART_S1_FE. */

/*! @brief Read current value of the UART_S1_FE field. */
#define BR_UART_S1_FE(x)     (BME_UBFX8(HW_UART_S1_ADDR(x), BP_UART_S1_FE, BS_UART_S1_FE))
/*@}*/

/*!
 * @name Register UART_S1, field NF[2] (RO)
 *
 * The advanced sampling technique used in the receiver takes seven samples
 * during the start bit and three samples in each data bit and the stop bits. If any
 * of these samples disagrees with the rest of the samples within any bit time in
 * the frame, the flag NF is set at the same time as RDRF is set for the
 * character. To clear NF, read UART_S1 and then read the UART data register (UART_D).
 *
 * Values:
 * - 0 - No noise detected.
 * - 1 - Noise detected in the received character in UART_D.
 */
/*@{*/
#define BP_UART_S1_NF        (2U)          /*!< Bit position for UART_S1_NF. */
#define BM_UART_S1_NF        (0x04U)       /*!< Bit mask for UART_S1_NF. */
#define BS_UART_S1_NF        (1U)          /*!< Bit field size in bits for UART_S1_NF. */

/*! @brief Read current value of the UART_S1_NF field. */
#define BR_UART_S1_NF(x)     (BME_UBFX8(HW_UART_S1_ADDR(x), BP_UART_S1_NF, BS_UART_S1_NF))
/*@}*/

/*!
 * @name Register UART_S1, field OR[3] (RO)
 *
 * OR is set when a new serial character is ready to be transferred to the
 * receive data register (buffer), but the previously received character has not been
 * read from UART_D yet. In this case, the new character, and all associated
 * error information, is lost because there is no room to move it into UART_D. To
 * clear OR, read UART_S1 with OR set and then read the UART data register (UART_D).
 *
 * Values:
 * - 0 - No overrun.
 * - 1 - Receive overrun (new UART data lost).
 */
/*@{*/
#define BP_UART_S1_OR        (3U)          /*!< Bit position for UART_S1_OR. */
#define BM_UART_S1_OR        (0x08U)       /*!< Bit mask for UART_S1_OR. */
#define BS_UART_S1_OR        (1U)          /*!< Bit field size in bits for UART_S1_OR. */

/*! @brief Read current value of the UART_S1_OR field. */
#define BR_UART_S1_OR(x)     (BME_UBFX8(HW_UART_S1_ADDR(x), BP_UART_S1_OR, BS_UART_S1_OR))
/*@}*/

/*!
 * @name Register UART_S1, field IDLE[4] (RO)
 *
 * IDLE is set when the UART receive line becomes idle for a full character time
 * after a period of activity. When ILT is cleared, the receiver starts counting
 * idle bit times after the start bit. If the receive character is all 1s, these
 * bit times and the stop bits time count toward the full character time of
 * logic high, 10 or 11 bit times depending on the M control bit, needed for the
 * receiver to detect an idle line. When ILT is set, the receiver doesn't start
 * counting idle bit times until after the stop bits. The stop bits and any logic high
 * bit times at the end of the previous character do not count toward the full
 * character time of logic high needed for the receiver to detect an idle line. To
 * clear IDLE, read UART_S1 with IDLE set and then read the UART data register
 * (UART_D). After IDLE has been cleared, it cannot become set again until after a
 * new character has been received and RDRF has been set. IDLE is set only once
 * even if the receive line remains idle for an extended period.
 *
 * Values:
 * - 0 - No idle line detected.
 * - 1 - Idle line was detected.
 */
/*@{*/
#define BP_UART_S1_IDLE      (4U)          /*!< Bit position for UART_S1_IDLE. */
#define BM_UART_S1_IDLE      (0x10U)       /*!< Bit mask for UART_S1_IDLE. */
#define BS_UART_S1_IDLE      (1U)          /*!< Bit field size in bits for UART_S1_IDLE. */

/*! @brief Read current value of the UART_S1_IDLE field. */
#define BR_UART_S1_IDLE(x)   (BME_UBFX8(HW_UART_S1_ADDR(x), BP_UART_S1_IDLE, BS_UART_S1_IDLE))
/*@}*/

/*!
 * @name Register UART_S1, field RDRF[5] (RO)
 *
 * RDRF becomes set when a character transfers from the receive shifter into the
 * receive data register (UART_D). To clear RDRF, read UART_S1 with RDRF set and
 * then read the UART data register (UART_D).
 *
 * Values:
 * - 0 - Receive data register empty.
 * - 1 - Receive data register full.
 */
/*@{*/
#define BP_UART_S1_RDRF      (5U)          /*!< Bit position for UART_S1_RDRF. */
#define BM_UART_S1_RDRF      (0x20U)       /*!< Bit mask for UART_S1_RDRF. */
#define BS_UART_S1_RDRF      (1U)          /*!< Bit field size in bits for UART_S1_RDRF. */

/*! @brief Read current value of the UART_S1_RDRF field. */
#define BR_UART_S1_RDRF(x)   (BME_UBFX8(HW_UART_S1_ADDR(x), BP_UART_S1_RDRF, BS_UART_S1_RDRF))
/*@}*/

/*!
 * @name Register UART_S1, field TC[6] (RO)
 *
 * TC is set out of reset and when TDRE is set and no data, preamble, or break
 * character is being transmitted. TC is cleared automatically by reading UART_S1
 * with TC set and then doing one of the following: Write to the UART data
 * register (UART_D) to transmit new data Queue a preamble by changing TE from 0 to 1
 * Queue a break character by writing 1 to UART_C2[SBK]
 *
 * Values:
 * - 0 - Transmitter active (sending data, a preamble, or a break).
 * - 1 - Transmitter idle (transmission activity complete).
 */
/*@{*/
#define BP_UART_S1_TC        (6U)          /*!< Bit position for UART_S1_TC. */
#define BM_UART_S1_TC        (0x40U)       /*!< Bit mask for UART_S1_TC. */
#define BS_UART_S1_TC        (1U)          /*!< Bit field size in bits for UART_S1_TC. */

/*! @brief Read current value of the UART_S1_TC field. */
#define BR_UART_S1_TC(x)     (BME_UBFX8(HW_UART_S1_ADDR(x), BP_UART_S1_TC, BS_UART_S1_TC))
/*@}*/

/*!
 * @name Register UART_S1, field TDRE[7] (RO)
 *
 * TDRE is set out of reset and when a transmit data value transfers from the
 * transmit data buffer to the transmit shifter, leaving room for a new character
 * in the buffer. To clear TDRE, read UART_S1 with TDRE set and then write to the
 * UART data register (UART_D).
 *
 * Values:
 * - 0 - Transmit data register (buffer) full.
 * - 1 - Transmit data register (buffer) empty.
 */
/*@{*/
#define BP_UART_S1_TDRE      (7U)          /*!< Bit position for UART_S1_TDRE. */
#define BM_UART_S1_TDRE      (0x80U)       /*!< Bit mask for UART_S1_TDRE. */
#define BS_UART_S1_TDRE      (1U)          /*!< Bit field size in bits for UART_S1_TDRE. */

/*! @brief Read current value of the UART_S1_TDRE field. */
#define BR_UART_S1_TDRE(x)   (BME_UBFX8(HW_UART_S1_ADDR(x), BP_UART_S1_TDRE, BS_UART_S1_TDRE))
/*@}*/

/*******************************************************************************
 * HW_UART_S2 - UART Status Register 2
 ******************************************************************************/

/*!
 * @brief HW_UART_S2 - UART Status Register 2 (RW)
 *
 * Reset value: 0x00U
 *
 * This register contains one read-only status flag. When using an internal
 * oscillator in a LIN system, it is necessary to raise the break detection threshold
 * one bit time. Under the worst case timing conditions allowed in LIN, it is
 * possible that a 0x00 data character can appear to be 10.26 bit times long at a
 * slave running 14% faster than the master. This would trigger normal break
 * detection circuitry designed to detect a 10-bit break symbol. When the LBKDE bit is
 * set, framing errors are inhibited and the break detection threshold changes
 * from 10 bits to 11 bits, preventing false detection of a 0x00 data character as
 * a LIN break symbol.
 */
typedef union _hw_uart_s2
{
    uint8_t U;
    struct _hw_uart_s2_bitfields
    {
        uint8_t RAF : 1;               /*!< [0] Receiver Active Flag */
        uint8_t LBKDE : 1;             /*!< [1] LIN Break Detection Enable */
        uint8_t BRK13 : 1;             /*!< [2] Break Character Generation Length */
        uint8_t RWUID : 1;             /*!< [3] Receive Wake Up Idle Detect */
        uint8_t RXINV : 1;             /*!< [4] Receive Data Inversion */
        uint8_t RESERVED0 : 1;         /*!< [5]  */
        uint8_t RXEDGIF : 1;           /*!< [6] RxD Pin Active Edge Interrupt Flag */
        uint8_t LBKDIF : 1;            /*!< [7] LIN Break Detect Interrupt Flag */
    } B;
} hw_uart_s2_t;

/*!
 * @name Constants and macros for entire UART_S2 register
 */
/*@{*/
#define HW_UART_S2_ADDR(x)       ((x) + 0x5U)

#define HW_UART_S2(x)            (*(__IO hw_uart_s2_t *) HW_UART_S2_ADDR(x))
#define HW_UART_S2_RD(x)         (HW_UART_S2(x).U)
#define HW_UART_S2_WR(x, v)      (HW_UART_S2(x).U = (v))
#define HW_UART_S2_SET(x, v)     (BME_OR8(HW_UART_S2_ADDR(x), (uint8_t)(v)))
#define HW_UART_S2_CLR(x, v)     (BME_AND8(HW_UART_S2_ADDR(x), (uint8_t)(~(v))))
#define HW_UART_S2_TOG(x, v)     (BME_XOR8(HW_UART_S2_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual UART_S2 bitfields
 */

/*!
 * @name Register UART_S2, field RAF[0] (RO)
 *
 * RAF is set when the UART receiver detects the beginning of a valid start bit,
 * and RAF is cleared automatically when the receiver detects an idle line. This
 * status flag can be used to check whether an UART character is being received
 * before instructing the MCU to go to stop mode.
 *
 * Values:
 * - 0 - UART receiver idle waiting for a start bit.
 * - 1 - UART receiver active (RxD input not idle).
 */
/*@{*/
#define BP_UART_S2_RAF       (0U)          /*!< Bit position for UART_S2_RAF. */
#define BM_UART_S2_RAF       (0x01U)       /*!< Bit mask for UART_S2_RAF. */
#define BS_UART_S2_RAF       (1U)          /*!< Bit field size in bits for UART_S2_RAF. */

/*! @brief Read current value of the UART_S2_RAF field. */
#define BR_UART_S2_RAF(x)    (BME_UBFX8(HW_UART_S2_ADDR(x), BP_UART_S2_RAF, BS_UART_S2_RAF))
/*@}*/

/*!
 * @name Register UART_S2, field LBKDE[1] (RW)
 *
 * LBKDE selects a longer break character detection length. While LBKDE is set,
 * framing error (FE) and receive data register full (RDRF) flags are prevented
 * from setting.
 *
 * Values:
 * - 0 - Break character is detected at length 10 bit times (if M = 0, SBNS = 0)
 *     or 11 (if M = 1, SBNS = 0 or M = 0, SBNS = 1) or 12 (if M = 1, SBNS = 1).
 * - 1 - Break character is detected at length of 11 bit times (if M = 0, SBNS =
 *     0) or 12 (if M = 1, SBNS = 0 or M = 0, SBNS = 1) or 13 (if M = 1, SBNS =
 *     1).
 */
/*@{*/
#define BP_UART_S2_LBKDE     (1U)          /*!< Bit position for UART_S2_LBKDE. */
#define BM_UART_S2_LBKDE     (0x02U)       /*!< Bit mask for UART_S2_LBKDE. */
#define BS_UART_S2_LBKDE     (1U)          /*!< Bit field size in bits for UART_S2_LBKDE. */

/*! @brief Read current value of the UART_S2_LBKDE field. */
#define BR_UART_S2_LBKDE(x)  (BME_UBFX8(HW_UART_S2_ADDR(x), BP_UART_S2_LBKDE, BS_UART_S2_LBKDE))

/*! @brief Format value for bitfield UART_S2_LBKDE. */
#define BF_UART_S2_LBKDE(v)  ((uint8_t)((uint8_t)(v) << BP_UART_S2_LBKDE) & BM_UART_S2_LBKDE)

/*! @brief Set the LBKDE field to a new value. */
#define BW_UART_S2_LBKDE(x, v) (BME_BFI8(HW_UART_S2_ADDR(x), ((uint8_t)(v) << BP_UART_S2_LBKDE), BP_UART_S2_LBKDE, 1))
/*@}*/

/*!
 * @name Register UART_S2, field BRK13[2] (RW)
 *
 * BRK13 selects a longer transmitted break character length. Detection of a
 * framing error is not affected by the state of this bit.
 *
 * Values:
 * - 0 - Break character is transmitted with length of 10 bit times (if M = 0,
 *     SBNS = 0) or 11 (if M = 1, SBNS = 0 or M = 0, SBNS = 1) or 12 (if M = 1,
 *     SBNS = 1).
 * - 1 - Break character is transmitted with length of 13 bit times (if M = 0,
 *     SBNS = 0) or 14 (if M = 1, SBNS = 0 or M = 0, SBNS = 1) or 15 (if M = 1,
 *     SBNS = 1).
 */
/*@{*/
#define BP_UART_S2_BRK13     (2U)          /*!< Bit position for UART_S2_BRK13. */
#define BM_UART_S2_BRK13     (0x04U)       /*!< Bit mask for UART_S2_BRK13. */
#define BS_UART_S2_BRK13     (1U)          /*!< Bit field size in bits for UART_S2_BRK13. */

/*! @brief Read current value of the UART_S2_BRK13 field. */
#define BR_UART_S2_BRK13(x)  (BME_UBFX8(HW_UART_S2_ADDR(x), BP_UART_S2_BRK13, BS_UART_S2_BRK13))

/*! @brief Format value for bitfield UART_S2_BRK13. */
#define BF_UART_S2_BRK13(v)  ((uint8_t)((uint8_t)(v) << BP_UART_S2_BRK13) & BM_UART_S2_BRK13)

/*! @brief Set the BRK13 field to a new value. */
#define BW_UART_S2_BRK13(x, v) (BME_BFI8(HW_UART_S2_ADDR(x), ((uint8_t)(v) << BP_UART_S2_BRK13), BP_UART_S2_BRK13, 1))
/*@}*/

/*!
 * @name Register UART_S2, field RWUID[3] (RW)
 *
 * RWUID controls whether the idle character that wakes up the receiver sets the
 * IDLE bit.
 *
 * Values:
 * - 0 - During receive standby state (RWU = 1), the IDLE bit does not get set
 *     upon detection of an idle character.
 * - 1 - During receive standby state (RWU = 1), the IDLE bit gets set upon
 *     detection of an idle character.
 */
/*@{*/
#define BP_UART_S2_RWUID     (3U)          /*!< Bit position for UART_S2_RWUID. */
#define BM_UART_S2_RWUID     (0x08U)       /*!< Bit mask for UART_S2_RWUID. */
#define BS_UART_S2_RWUID     (1U)          /*!< Bit field size in bits for UART_S2_RWUID. */

/*! @brief Read current value of the UART_S2_RWUID field. */
#define BR_UART_S2_RWUID(x)  (BME_UBFX8(HW_UART_S2_ADDR(x), BP_UART_S2_RWUID, BS_UART_S2_RWUID))

/*! @brief Format value for bitfield UART_S2_RWUID. */
#define BF_UART_S2_RWUID(v)  ((uint8_t)((uint8_t)(v) << BP_UART_S2_RWUID) & BM_UART_S2_RWUID)

/*! @brief Set the RWUID field to a new value. */
#define BW_UART_S2_RWUID(x, v) (BME_BFI8(HW_UART_S2_ADDR(x), ((uint8_t)(v) << BP_UART_S2_RWUID), BP_UART_S2_RWUID, 1))
/*@}*/

/*!
 * @name Register UART_S2, field RXINV[4] (RW)
 *
 * Setting this bit reverses the polarity of the received data input. Setting
 * RXINV inverts the RxD input for all cases: data bits, start and stop bits,
 * break, and idle.
 *
 * Values:
 * - 0 - Receive data not inverted.
 * - 1 - Receive data inverted.
 */
/*@{*/
#define BP_UART_S2_RXINV     (4U)          /*!< Bit position for UART_S2_RXINV. */
#define BM_UART_S2_RXINV     (0x10U)       /*!< Bit mask for UART_S2_RXINV. */
#define BS_UART_S2_RXINV     (1U)          /*!< Bit field size in bits for UART_S2_RXINV. */

/*! @brief Read current value of the UART_S2_RXINV field. */
#define BR_UART_S2_RXINV(x)  (BME_UBFX8(HW_UART_S2_ADDR(x), BP_UART_S2_RXINV, BS_UART_S2_RXINV))

/*! @brief Format value for bitfield UART_S2_RXINV. */
#define BF_UART_S2_RXINV(v)  ((uint8_t)((uint8_t)(v) << BP_UART_S2_RXINV) & BM_UART_S2_RXINV)

/*! @brief Set the RXINV field to a new value. */
#define BW_UART_S2_RXINV(x, v) (BME_BFI8(HW_UART_S2_ADDR(x), ((uint8_t)(v) << BP_UART_S2_RXINV), BP_UART_S2_RXINV, 1))
/*@}*/

/*!
 * @name Register UART_S2, field RXEDGIF[6] (RW)
 *
 * RXEDGIF is set when an active edge, falling if RXINV = 0, rising if RXINV=1,
 * on the RxD pin occurs. RXEDGIF is cleared by writing a 1 to it.
 *
 * Values:
 * - 0 - No active edge on the receive pin has occurred.
 * - 1 - An active edge on the receive pin has occurred.
 */
/*@{*/
#define BP_UART_S2_RXEDGIF   (6U)          /*!< Bit position for UART_S2_RXEDGIF. */
#define BM_UART_S2_RXEDGIF   (0x40U)       /*!< Bit mask for UART_S2_RXEDGIF. */
#define BS_UART_S2_RXEDGIF   (1U)          /*!< Bit field size in bits for UART_S2_RXEDGIF. */

/*! @brief Read current value of the UART_S2_RXEDGIF field. */
#define BR_UART_S2_RXEDGIF(x) (BME_UBFX8(HW_UART_S2_ADDR(x), BP_UART_S2_RXEDGIF, BS_UART_S2_RXEDGIF))

/*! @brief Format value for bitfield UART_S2_RXEDGIF. */
#define BF_UART_S2_RXEDGIF(v) ((uint8_t)((uint8_t)(v) << BP_UART_S2_RXEDGIF) & BM_UART_S2_RXEDGIF)

/*! @brief Set the RXEDGIF field to a new value. */
#define BW_UART_S2_RXEDGIF(x, v) (BME_BFI8(HW_UART_S2_ADDR(x), ((uint8_t)(v) << BP_UART_S2_RXEDGIF), BP_UART_S2_RXEDGIF, 1))
/*@}*/

/*!
 * @name Register UART_S2, field LBKDIF[7] (RW)
 *
 * LBKDIF is set when the LIN break detect circuitry is enabled and a LIN break
 * character is detected. LBKDIF is cleared by writing a 1 to it.
 *
 * Values:
 * - 0 - No LIN break character has been detected.
 * - 1 - LIN break character has been detected.
 */
/*@{*/
#define BP_UART_S2_LBKDIF    (7U)          /*!< Bit position for UART_S2_LBKDIF. */
#define BM_UART_S2_LBKDIF    (0x80U)       /*!< Bit mask for UART_S2_LBKDIF. */
#define BS_UART_S2_LBKDIF    (1U)          /*!< Bit field size in bits for UART_S2_LBKDIF. */

/*! @brief Read current value of the UART_S2_LBKDIF field. */
#define BR_UART_S2_LBKDIF(x) (BME_UBFX8(HW_UART_S2_ADDR(x), BP_UART_S2_LBKDIF, BS_UART_S2_LBKDIF))

/*! @brief Format value for bitfield UART_S2_LBKDIF. */
#define BF_UART_S2_LBKDIF(v) ((uint8_t)((uint8_t)(v) << BP_UART_S2_LBKDIF) & BM_UART_S2_LBKDIF)

/*! @brief Set the LBKDIF field to a new value. */
#define BW_UART_S2_LBKDIF(x, v) (BME_BFI8(HW_UART_S2_ADDR(x), ((uint8_t)(v) << BP_UART_S2_LBKDIF), BP_UART_S2_LBKDIF, 1))
/*@}*/

/*******************************************************************************
 * HW_UART_C3 - UART Control Register 3
 ******************************************************************************/

/*!
 * @brief HW_UART_C3 - UART Control Register 3 (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_uart_c3
{
    uint8_t U;
    struct _hw_uart_c3_bitfields
    {
        uint8_t PEIE : 1;              /*!< [0] Parity Error Interrupt Enable */
        uint8_t FEIE : 1;              /*!< [1] Framing Error Interrupt Enable */
        uint8_t NEIE : 1;              /*!< [2] Noise Error Interrupt Enable */
        uint8_t ORIE : 1;              /*!< [3] Overrun Interrupt Enable */
        uint8_t TXINV : 1;             /*!< [4] Transmit Data Inversion */
        uint8_t TXDIR : 1;             /*!< [5] TxD Pin Direction in Single-Wire Mode */
        uint8_t T8 : 1;                /*!< [6] Ninth Data Bit for Transmitter */
        uint8_t R8 : 1;                /*!< [7] Ninth Data Bit for Receiver */
    } B;
} hw_uart_c3_t;

/*!
 * @name Constants and macros for entire UART_C3 register
 */
/*@{*/
#define HW_UART_C3_ADDR(x)       ((x) + 0x6U)

#define HW_UART_C3(x)            (*(__IO hw_uart_c3_t *) HW_UART_C3_ADDR(x))
#define HW_UART_C3_RD(x)         (HW_UART_C3(x).U)
#define HW_UART_C3_WR(x, v)      (HW_UART_C3(x).U = (v))
#define HW_UART_C3_SET(x, v)     (BME_OR8(HW_UART_C3_ADDR(x), (uint8_t)(v)))
#define HW_UART_C3_CLR(x, v)     (BME_AND8(HW_UART_C3_ADDR(x), (uint8_t)(~(v))))
#define HW_UART_C3_TOG(x, v)     (BME_XOR8(HW_UART_C3_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual UART_C3 bitfields
 */

/*!
 * @name Register UART_C3, field PEIE[0] (RW)
 *
 * This bit enables the parity error flag (PF) to generate hardware interrupt
 * requests.
 *
 * Values:
 * - 0 - PF interrupts disabled; use polling).
 * - 1 - Hardware interrupt requested when PF is set.
 */
/*@{*/
#define BP_UART_C3_PEIE      (0U)          /*!< Bit position for UART_C3_PEIE. */
#define BM_UART_C3_PEIE      (0x01U)       /*!< Bit mask for UART_C3_PEIE. */
#define BS_UART_C3_PEIE      (1U)          /*!< Bit field size in bits for UART_C3_PEIE. */

/*! @brief Read current value of the UART_C3_PEIE field. */
#define BR_UART_C3_PEIE(x)   (BME_UBFX8(HW_UART_C3_ADDR(x), BP_UART_C3_PEIE, BS_UART_C3_PEIE))

/*! @brief Format value for bitfield UART_C3_PEIE. */
#define BF_UART_C3_PEIE(v)   ((uint8_t)((uint8_t)(v) << BP_UART_C3_PEIE) & BM_UART_C3_PEIE)

/*! @brief Set the PEIE field to a new value. */
#define BW_UART_C3_PEIE(x, v) (BME_BFI8(HW_UART_C3_ADDR(x), ((uint8_t)(v) << BP_UART_C3_PEIE), BP_UART_C3_PEIE, 1))
/*@}*/

/*!
 * @name Register UART_C3, field FEIE[1] (RW)
 *
 * This bit enables the framing error flag (FE) to generate hardware interrupt
 * requests.
 *
 * Values:
 * - 0 - FE interrupts disabled; use polling).
 * - 1 - Hardware interrupt requested when FE is set.
 */
/*@{*/
#define BP_UART_C3_FEIE      (1U)          /*!< Bit position for UART_C3_FEIE. */
#define BM_UART_C3_FEIE      (0x02U)       /*!< Bit mask for UART_C3_FEIE. */
#define BS_UART_C3_FEIE      (1U)          /*!< Bit field size in bits for UART_C3_FEIE. */

/*! @brief Read current value of the UART_C3_FEIE field. */
#define BR_UART_C3_FEIE(x)   (BME_UBFX8(HW_UART_C3_ADDR(x), BP_UART_C3_FEIE, BS_UART_C3_FEIE))

/*! @brief Format value for bitfield UART_C3_FEIE. */
#define BF_UART_C3_FEIE(v)   ((uint8_t)((uint8_t)(v) << BP_UART_C3_FEIE) & BM_UART_C3_FEIE)

/*! @brief Set the FEIE field to a new value. */
#define BW_UART_C3_FEIE(x, v) (BME_BFI8(HW_UART_C3_ADDR(x), ((uint8_t)(v) << BP_UART_C3_FEIE), BP_UART_C3_FEIE, 1))
/*@}*/

/*!
 * @name Register UART_C3, field NEIE[2] (RW)
 *
 * This bit enables the noise flag (NF) to generate hardware interrupt requests.
 *
 * Values:
 * - 0 - NF interrupts disabled; use polling).
 * - 1 - Hardware interrupt requested when NF is set.
 */
/*@{*/
#define BP_UART_C3_NEIE      (2U)          /*!< Bit position for UART_C3_NEIE. */
#define BM_UART_C3_NEIE      (0x04U)       /*!< Bit mask for UART_C3_NEIE. */
#define BS_UART_C3_NEIE      (1U)          /*!< Bit field size in bits for UART_C3_NEIE. */

/*! @brief Read current value of the UART_C3_NEIE field. */
#define BR_UART_C3_NEIE(x)   (BME_UBFX8(HW_UART_C3_ADDR(x), BP_UART_C3_NEIE, BS_UART_C3_NEIE))

/*! @brief Format value for bitfield UART_C3_NEIE. */
#define BF_UART_C3_NEIE(v)   ((uint8_t)((uint8_t)(v) << BP_UART_C3_NEIE) & BM_UART_C3_NEIE)

/*! @brief Set the NEIE field to a new value. */
#define BW_UART_C3_NEIE(x, v) (BME_BFI8(HW_UART_C3_ADDR(x), ((uint8_t)(v) << BP_UART_C3_NEIE), BP_UART_C3_NEIE, 1))
/*@}*/

/*!
 * @name Register UART_C3, field ORIE[3] (RW)
 *
 * This bit enables the overrun flag (OR) to generate hardware interrupt
 * requests.
 *
 * Values:
 * - 0 - OR interrupts disabled; use polling.
 * - 1 - Hardware interrupt requested when OR is set.
 */
/*@{*/
#define BP_UART_C3_ORIE      (3U)          /*!< Bit position for UART_C3_ORIE. */
#define BM_UART_C3_ORIE      (0x08U)       /*!< Bit mask for UART_C3_ORIE. */
#define BS_UART_C3_ORIE      (1U)          /*!< Bit field size in bits for UART_C3_ORIE. */

/*! @brief Read current value of the UART_C3_ORIE field. */
#define BR_UART_C3_ORIE(x)   (BME_UBFX8(HW_UART_C3_ADDR(x), BP_UART_C3_ORIE, BS_UART_C3_ORIE))

/*! @brief Format value for bitfield UART_C3_ORIE. */
#define BF_UART_C3_ORIE(v)   ((uint8_t)((uint8_t)(v) << BP_UART_C3_ORIE) & BM_UART_C3_ORIE)

/*! @brief Set the ORIE field to a new value. */
#define BW_UART_C3_ORIE(x, v) (BME_BFI8(HW_UART_C3_ADDR(x), ((uint8_t)(v) << BP_UART_C3_ORIE), BP_UART_C3_ORIE, 1))
/*@}*/

/*!
 * @name Register UART_C3, field TXINV[4] (RW)
 *
 * Setting this bit reverses the polarity of the transmitted data output.
 * Setting TXINV inverts the TxD output for all cases: data bits, start and stop bits,
 * break, and idle.
 *
 * Values:
 * - 0 - Transmit data not inverted.
 * - 1 - Transmit data inverted.
 */
/*@{*/
#define BP_UART_C3_TXINV     (4U)          /*!< Bit position for UART_C3_TXINV. */
#define BM_UART_C3_TXINV     (0x10U)       /*!< Bit mask for UART_C3_TXINV. */
#define BS_UART_C3_TXINV     (1U)          /*!< Bit field size in bits for UART_C3_TXINV. */

/*! @brief Read current value of the UART_C3_TXINV field. */
#define BR_UART_C3_TXINV(x)  (BME_UBFX8(HW_UART_C3_ADDR(x), BP_UART_C3_TXINV, BS_UART_C3_TXINV))

/*! @brief Format value for bitfield UART_C3_TXINV. */
#define BF_UART_C3_TXINV(v)  ((uint8_t)((uint8_t)(v) << BP_UART_C3_TXINV) & BM_UART_C3_TXINV)

/*! @brief Set the TXINV field to a new value. */
#define BW_UART_C3_TXINV(x, v) (BME_BFI8(HW_UART_C3_ADDR(x), ((uint8_t)(v) << BP_UART_C3_TXINV), BP_UART_C3_TXINV, 1))
/*@}*/

/*!
 * @name Register UART_C3, field TXDIR[5] (RW)
 *
 * When the UART is configured for single-wire half-duplex operation (LOOPS =
 * RSRC = 1), this bit determines the direction of data at the TxD pin.
 *
 * Values:
 * - 0 - TxD pin is an input in single-wire mode.
 * - 1 - TxD pin is an output in single-wire mode.
 */
/*@{*/
#define BP_UART_C3_TXDIR     (5U)          /*!< Bit position for UART_C3_TXDIR. */
#define BM_UART_C3_TXDIR     (0x20U)       /*!< Bit mask for UART_C3_TXDIR. */
#define BS_UART_C3_TXDIR     (1U)          /*!< Bit field size in bits for UART_C3_TXDIR. */

/*! @brief Read current value of the UART_C3_TXDIR field. */
#define BR_UART_C3_TXDIR(x)  (BME_UBFX8(HW_UART_C3_ADDR(x), BP_UART_C3_TXDIR, BS_UART_C3_TXDIR))

/*! @brief Format value for bitfield UART_C3_TXDIR. */
#define BF_UART_C3_TXDIR(v)  ((uint8_t)((uint8_t)(v) << BP_UART_C3_TXDIR) & BM_UART_C3_TXDIR)

/*! @brief Set the TXDIR field to a new value. */
#define BW_UART_C3_TXDIR(x, v) (BME_BFI8(HW_UART_C3_ADDR(x), ((uint8_t)(v) << BP_UART_C3_TXDIR), BP_UART_C3_TXDIR, 1))
/*@}*/

/*!
 * @name Register UART_C3, field T8[6] (RW)
 *
 * When the UART is configured for 9-bit data (M = 1), T8 may be thought of as a
 * ninth transmit data bit to the left of the msb of the data in the UART_D
 * register. When writing 9-bit data, the entire 9-bit value is transferred to the
 * UART shift register after UART_D is written so T8 should be written, if it needs
 * to change from its previous value, before UART_D is written. If T8 does not
 * need to change in the new value, such as when it is used to generate mark or
 * space parity, it need not be written each time UART_D is written.
 */
/*@{*/
#define BP_UART_C3_T8        (6U)          /*!< Bit position for UART_C3_T8. */
#define BM_UART_C3_T8        (0x40U)       /*!< Bit mask for UART_C3_T8. */
#define BS_UART_C3_T8        (1U)          /*!< Bit field size in bits for UART_C3_T8. */

/*! @brief Read current value of the UART_C3_T8 field. */
#define BR_UART_C3_T8(x)     (BME_UBFX8(HW_UART_C3_ADDR(x), BP_UART_C3_T8, BS_UART_C3_T8))

/*! @brief Format value for bitfield UART_C3_T8. */
#define BF_UART_C3_T8(v)     ((uint8_t)((uint8_t)(v) << BP_UART_C3_T8) & BM_UART_C3_T8)

/*! @brief Set the T8 field to a new value. */
#define BW_UART_C3_T8(x, v)  (BME_BFI8(HW_UART_C3_ADDR(x), ((uint8_t)(v) << BP_UART_C3_T8), BP_UART_C3_T8, 1))
/*@}*/

/*!
 * @name Register UART_C3, field R8[7] (RO)
 *
 * When the UART is configured for 9-bit data (M = 1), R8 can be thought of as a
 * ninth receive data bit to the left of the msb of the buffered data in the
 * UART_D register. When reading 9-bit data, read R8 before reading UART_D because
 * reading UART_D completes automatic flag clearing sequences that could allow R8
 * and UART_D to be overwritten with new data.
 */
/*@{*/
#define BP_UART_C3_R8        (7U)          /*!< Bit position for UART_C3_R8. */
#define BM_UART_C3_R8        (0x80U)       /*!< Bit mask for UART_C3_R8. */
#define BS_UART_C3_R8        (1U)          /*!< Bit field size in bits for UART_C3_R8. */

/*! @brief Read current value of the UART_C3_R8 field. */
#define BR_UART_C3_R8(x)     (BME_UBFX8(HW_UART_C3_ADDR(x), BP_UART_C3_R8, BS_UART_C3_R8))
/*@}*/

/*******************************************************************************
 * HW_UART_D - UART Data Register
 ******************************************************************************/

/*!
 * @brief HW_UART_D - UART Data Register (RW)
 *
 * Reset value: 0x00U
 *
 * This register is actually two separate registers. Reads return the contents
 * of the read-only receive data buffer and writes go to the write-only transmit
 * data buffer. Reads and writes of this register are also involved in the
 * automatic flag clearing mechanisms for the UART status flags.
 */
typedef union _hw_uart_d
{
    uint8_t U;
    struct _hw_uart_d_bitfields
    {
        uint8_t R0T0 : 1;              /*!< [0]  */
        uint8_t R1T1 : 1;              /*!< [1]  */
        uint8_t R2T2 : 1;              /*!< [2]  */
        uint8_t R3T3 : 1;              /*!< [3]  */
        uint8_t R4T4 : 1;              /*!< [4]  */
        uint8_t R5T5 : 1;              /*!< [5]  */
        uint8_t R6T6 : 1;              /*!< [6]  */
        uint8_t R7T7 : 1;              /*!< [7]  */
    } B;
} hw_uart_d_t;

/*!
 * @name Constants and macros for entire UART_D register
 */
/*@{*/
#define HW_UART_D_ADDR(x)        ((x) + 0x7U)

#define HW_UART_D(x)             (*(__IO hw_uart_d_t *) HW_UART_D_ADDR(x))
#define HW_UART_D_RD(x)          (HW_UART_D(x).U)
#define HW_UART_D_WR(x, v)       (HW_UART_D(x).U = (v))
#define HW_UART_D_SET(x, v)      (BME_OR8(HW_UART_D_ADDR(x), (uint8_t)(v)))
#define HW_UART_D_CLR(x, v)      (BME_AND8(HW_UART_D_ADDR(x), (uint8_t)(~(v))))
#define HW_UART_D_TOG(x, v)      (BME_XOR8(HW_UART_D_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual UART_D bitfields
 */

/*!
 * @name Register UART_D, field R0T0[0] (RW)
 *
 * Read receive data buffer 0 or write transmit data buffer 0.
 */
/*@{*/
#define BP_UART_D_R0T0       (0U)          /*!< Bit position for UART_D_R0T0. */
#define BM_UART_D_R0T0       (0x01U)       /*!< Bit mask for UART_D_R0T0. */
#define BS_UART_D_R0T0       (1U)          /*!< Bit field size in bits for UART_D_R0T0. */

/*! @brief Read current value of the UART_D_R0T0 field. */
#define BR_UART_D_R0T0(x)    (BME_UBFX8(HW_UART_D_ADDR(x), BP_UART_D_R0T0, BS_UART_D_R0T0))

/*! @brief Format value for bitfield UART_D_R0T0. */
#define BF_UART_D_R0T0(v)    ((uint8_t)((uint8_t)(v) << BP_UART_D_R0T0) & BM_UART_D_R0T0)

/*! @brief Set the R0T0 field to a new value. */
#define BW_UART_D_R0T0(x, v) (BME_BFI8(HW_UART_D_ADDR(x), ((uint8_t)(v) << BP_UART_D_R0T0), BP_UART_D_R0T0, 1))
/*@}*/

/*!
 * @name Register UART_D, field R1T1[1] (RW)
 *
 * Read receive data buffer 1 or write transmit data buffer 1.
 */
/*@{*/
#define BP_UART_D_R1T1       (1U)          /*!< Bit position for UART_D_R1T1. */
#define BM_UART_D_R1T1       (0x02U)       /*!< Bit mask for UART_D_R1T1. */
#define BS_UART_D_R1T1       (1U)          /*!< Bit field size in bits for UART_D_R1T1. */

/*! @brief Read current value of the UART_D_R1T1 field. */
#define BR_UART_D_R1T1(x)    (BME_UBFX8(HW_UART_D_ADDR(x), BP_UART_D_R1T1, BS_UART_D_R1T1))

/*! @brief Format value for bitfield UART_D_R1T1. */
#define BF_UART_D_R1T1(v)    ((uint8_t)((uint8_t)(v) << BP_UART_D_R1T1) & BM_UART_D_R1T1)

/*! @brief Set the R1T1 field to a new value. */
#define BW_UART_D_R1T1(x, v) (BME_BFI8(HW_UART_D_ADDR(x), ((uint8_t)(v) << BP_UART_D_R1T1), BP_UART_D_R1T1, 1))
/*@}*/

/*!
 * @name Register UART_D, field R2T2[2] (RW)
 *
 * Read receive data buffer 2 or write transmit data buffer 2.
 */
/*@{*/
#define BP_UART_D_R2T2       (2U)          /*!< Bit position for UART_D_R2T2. */
#define BM_UART_D_R2T2       (0x04U)       /*!< Bit mask for UART_D_R2T2. */
#define BS_UART_D_R2T2       (1U)          /*!< Bit field size in bits for UART_D_R2T2. */

/*! @brief Read current value of the UART_D_R2T2 field. */
#define BR_UART_D_R2T2(x)    (BME_UBFX8(HW_UART_D_ADDR(x), BP_UART_D_R2T2, BS_UART_D_R2T2))

/*! @brief Format value for bitfield UART_D_R2T2. */
#define BF_UART_D_R2T2(v)    ((uint8_t)((uint8_t)(v) << BP_UART_D_R2T2) & BM_UART_D_R2T2)

/*! @brief Set the R2T2 field to a new value. */
#define BW_UART_D_R2T2(x, v) (BME_BFI8(HW_UART_D_ADDR(x), ((uint8_t)(v) << BP_UART_D_R2T2), BP_UART_D_R2T2, 1))
/*@}*/

/*!
 * @name Register UART_D, field R3T3[3] (RW)
 *
 * Read receive data buffer 3 or write transmit data buffer 3.
 */
/*@{*/
#define BP_UART_D_R3T3       (3U)          /*!< Bit position for UART_D_R3T3. */
#define BM_UART_D_R3T3       (0x08U)       /*!< Bit mask for UART_D_R3T3. */
#define BS_UART_D_R3T3       (1U)          /*!< Bit field size in bits for UART_D_R3T3. */

/*! @brief Read current value of the UART_D_R3T3 field. */
#define BR_UART_D_R3T3(x)    (BME_UBFX8(HW_UART_D_ADDR(x), BP_UART_D_R3T3, BS_UART_D_R3T3))

/*! @brief Format value for bitfield UART_D_R3T3. */
#define BF_UART_D_R3T3(v)    ((uint8_t)((uint8_t)(v) << BP_UART_D_R3T3) & BM_UART_D_R3T3)

/*! @brief Set the R3T3 field to a new value. */
#define BW_UART_D_R3T3(x, v) (BME_BFI8(HW_UART_D_ADDR(x), ((uint8_t)(v) << BP_UART_D_R3T3), BP_UART_D_R3T3, 1))
/*@}*/

/*!
 * @name Register UART_D, field R4T4[4] (RW)
 *
 * Read receive data buffer 4 or write transmit data buffer 4.
 */
/*@{*/
#define BP_UART_D_R4T4       (4U)          /*!< Bit position for UART_D_R4T4. */
#define BM_UART_D_R4T4       (0x10U)       /*!< Bit mask for UART_D_R4T4. */
#define BS_UART_D_R4T4       (1U)          /*!< Bit field size in bits for UART_D_R4T4. */

/*! @brief Read current value of the UART_D_R4T4 field. */
#define BR_UART_D_R4T4(x)    (BME_UBFX8(HW_UART_D_ADDR(x), BP_UART_D_R4T4, BS_UART_D_R4T4))

/*! @brief Format value for bitfield UART_D_R4T4. */
#define BF_UART_D_R4T4(v)    ((uint8_t)((uint8_t)(v) << BP_UART_D_R4T4) & BM_UART_D_R4T4)

/*! @brief Set the R4T4 field to a new value. */
#define BW_UART_D_R4T4(x, v) (BME_BFI8(HW_UART_D_ADDR(x), ((uint8_t)(v) << BP_UART_D_R4T4), BP_UART_D_R4T4, 1))
/*@}*/

/*!
 * @name Register UART_D, field R5T5[5] (RW)
 *
 * Read receive data buffer 5 or write transmit data buffer 5.
 */
/*@{*/
#define BP_UART_D_R5T5       (5U)          /*!< Bit position for UART_D_R5T5. */
#define BM_UART_D_R5T5       (0x20U)       /*!< Bit mask for UART_D_R5T5. */
#define BS_UART_D_R5T5       (1U)          /*!< Bit field size in bits for UART_D_R5T5. */

/*! @brief Read current value of the UART_D_R5T5 field. */
#define BR_UART_D_R5T5(x)    (BME_UBFX8(HW_UART_D_ADDR(x), BP_UART_D_R5T5, BS_UART_D_R5T5))

/*! @brief Format value for bitfield UART_D_R5T5. */
#define BF_UART_D_R5T5(v)    ((uint8_t)((uint8_t)(v) << BP_UART_D_R5T5) & BM_UART_D_R5T5)

/*! @brief Set the R5T5 field to a new value. */
#define BW_UART_D_R5T5(x, v) (BME_BFI8(HW_UART_D_ADDR(x), ((uint8_t)(v) << BP_UART_D_R5T5), BP_UART_D_R5T5, 1))
/*@}*/

/*!
 * @name Register UART_D, field R6T6[6] (RW)
 *
 * Read receive data buffer 6 or write transmit data buffer 6.
 */
/*@{*/
#define BP_UART_D_R6T6       (6U)          /*!< Bit position for UART_D_R6T6. */
#define BM_UART_D_R6T6       (0x40U)       /*!< Bit mask for UART_D_R6T6. */
#define BS_UART_D_R6T6       (1U)          /*!< Bit field size in bits for UART_D_R6T6. */

/*! @brief Read current value of the UART_D_R6T6 field. */
#define BR_UART_D_R6T6(x)    (BME_UBFX8(HW_UART_D_ADDR(x), BP_UART_D_R6T6, BS_UART_D_R6T6))

/*! @brief Format value for bitfield UART_D_R6T6. */
#define BF_UART_D_R6T6(v)    ((uint8_t)((uint8_t)(v) << BP_UART_D_R6T6) & BM_UART_D_R6T6)

/*! @brief Set the R6T6 field to a new value. */
#define BW_UART_D_R6T6(x, v) (BME_BFI8(HW_UART_D_ADDR(x), ((uint8_t)(v) << BP_UART_D_R6T6), BP_UART_D_R6T6, 1))
/*@}*/

/*!
 * @name Register UART_D, field R7T7[7] (RW)
 *
 * Read receive data buffer 7 or write transmit data buffer 7.
 */
/*@{*/
#define BP_UART_D_R7T7       (7U)          /*!< Bit position for UART_D_R7T7. */
#define BM_UART_D_R7T7       (0x80U)       /*!< Bit mask for UART_D_R7T7. */
#define BS_UART_D_R7T7       (1U)          /*!< Bit field size in bits for UART_D_R7T7. */

/*! @brief Read current value of the UART_D_R7T7 field. */
#define BR_UART_D_R7T7(x)    (BME_UBFX8(HW_UART_D_ADDR(x), BP_UART_D_R7T7, BS_UART_D_R7T7))

/*! @brief Format value for bitfield UART_D_R7T7. */
#define BF_UART_D_R7T7(v)    ((uint8_t)((uint8_t)(v) << BP_UART_D_R7T7) & BM_UART_D_R7T7)

/*! @brief Set the R7T7 field to a new value. */
#define BW_UART_D_R7T7(x, v) (BME_BFI8(HW_UART_D_ADDR(x), ((uint8_t)(v) << BP_UART_D_R7T7), BP_UART_D_R7T7, 1))
/*@}*/

/*******************************************************************************
 * HW_UART_C4 - UART Control Register 4
 ******************************************************************************/

/*!
 * @brief HW_UART_C4 - UART Control Register 4 (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_uart_c4
{
    uint8_t U;
    struct _hw_uart_c4_bitfields
    {
        uint8_t RESERVED0 : 5;         /*!< [4:0]  */
        uint8_t RDMAS : 1;             /*!< [5] Receiver Full DMA Select */
        uint8_t RESERVED1 : 1;         /*!< [6]  */
        uint8_t TDMAS : 1;             /*!< [7] Transmitter DMA Select */
    } B;
} hw_uart_c4_t;

/*!
 * @name Constants and macros for entire UART_C4 register
 */
/*@{*/
#define HW_UART_C4_ADDR(x)       ((x) + 0x8U)

#define HW_UART_C4(x)            (*(__IO hw_uart_c4_t *) HW_UART_C4_ADDR(x))
#define HW_UART_C4_RD(x)         (HW_UART_C4(x).U)
#define HW_UART_C4_WR(x, v)      (HW_UART_C4(x).U = (v))
#define HW_UART_C4_SET(x, v)     (BME_OR8(HW_UART_C4_ADDR(x), (uint8_t)(v)))
#define HW_UART_C4_CLR(x, v)     (BME_AND8(HW_UART_C4_ADDR(x), (uint8_t)(~(v))))
#define HW_UART_C4_TOG(x, v)     (BME_XOR8(HW_UART_C4_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual UART_C4 bitfields
 */

/*!
 * @name Register UART_C4, field RDMAS[5] (RW)
 *
 * RDMAS configures the receiver data register full flag, RDRF, to generate
 * interrupt or DMA requests if RIE is set. If RIE is cleared, the RDRF DMA and RDRF
 * interrupt request signals are not asserted when the RDRF flag is set,
 * regardless of the state of RDMAS.
 *
 * Values:
 * - 0 - If RIE is set and the RDRF flag is set, the RDRF interrupt request
 *     signal is asserted to request interrupt service.
 * - 1 - If RIE is set and the RDRF flag is set, the RDRF DMA request signal is
 *     asserted to request a DMA transfer.
 */
/*@{*/
#define BP_UART_C4_RDMAS     (5U)          /*!< Bit position for UART_C4_RDMAS. */
#define BM_UART_C4_RDMAS     (0x20U)       /*!< Bit mask for UART_C4_RDMAS. */
#define BS_UART_C4_RDMAS     (1U)          /*!< Bit field size in bits for UART_C4_RDMAS. */

/*! @brief Read current value of the UART_C4_RDMAS field. */
#define BR_UART_C4_RDMAS(x)  (BME_UBFX8(HW_UART_C4_ADDR(x), BP_UART_C4_RDMAS, BS_UART_C4_RDMAS))

/*! @brief Format value for bitfield UART_C4_RDMAS. */
#define BF_UART_C4_RDMAS(v)  ((uint8_t)((uint8_t)(v) << BP_UART_C4_RDMAS) & BM_UART_C4_RDMAS)

/*! @brief Set the RDMAS field to a new value. */
#define BW_UART_C4_RDMAS(x, v) (BME_BFI8(HW_UART_C4_ADDR(x), ((uint8_t)(v) << BP_UART_C4_RDMAS), BP_UART_C4_RDMAS, 1))
/*@}*/

/*!
 * @name Register UART_C4, field TDMAS[7] (RW)
 *
 * TDMAS configures the transmit data register empty flag, TDRE, to generate
 * interrupt or DMA requests if TIE is set. If UART_C2[TIE] is cleared, TDRE DMA and
 * TDRE interrupt request signals are not asserted when the TDRE flag is set,
 * regardless of the state of TDMAS. If UART_C2[TIE] and TDMAS are both set, then
 * UART_C2[TCIE] must be cleared, and UART_D must not be written outside of
 * servicing of a DMA request.
 *
 * Values:
 * - 0 - If TIE is set and the TDRE flag is set, the TDRE interrupt request
 *     signal is asserted to request interrupt service.
 * - 1 - If TIE is set and the TDRE flag is set, the TDRE DMA request signal is
 *     asserted to request a DMA transfer.
 */
/*@{*/
#define BP_UART_C4_TDMAS     (7U)          /*!< Bit position for UART_C4_TDMAS. */
#define BM_UART_C4_TDMAS     (0x80U)       /*!< Bit mask for UART_C4_TDMAS. */
#define BS_UART_C4_TDMAS     (1U)          /*!< Bit field size in bits for UART_C4_TDMAS. */

/*! @brief Read current value of the UART_C4_TDMAS field. */
#define BR_UART_C4_TDMAS(x)  (BME_UBFX8(HW_UART_C4_ADDR(x), BP_UART_C4_TDMAS, BS_UART_C4_TDMAS))

/*! @brief Format value for bitfield UART_C4_TDMAS. */
#define BF_UART_C4_TDMAS(v)  ((uint8_t)((uint8_t)(v) << BP_UART_C4_TDMAS) & BM_UART_C4_TDMAS)

/*! @brief Set the TDMAS field to a new value. */
#define BW_UART_C4_TDMAS(x, v) (BME_BFI8(HW_UART_C4_ADDR(x), ((uint8_t)(v) << BP_UART_C4_TDMAS), BP_UART_C4_TDMAS, 1))
/*@}*/

/*******************************************************************************
 * hw_uart_t - module struct
 ******************************************************************************/
/*!
 * @brief All UART module registers.
 */
#pragma pack(1)
typedef struct _hw_uart
{
    __IO hw_uart_bdh_t BDH;                /*!< [0x0] UART Baud Rate Register: High */
    __IO hw_uart_bdl_t BDL;                /*!< [0x1] UART Baud Rate Register: Low */
    __IO hw_uart_c1_t C1;                  /*!< [0x2] UART Control Register 1 */
    __IO hw_uart_c2_t C2;                  /*!< [0x3] UART Control Register 2 */
    __I hw_uart_s1_t S1;                   /*!< [0x4] UART Status Register 1 */
    __IO hw_uart_s2_t S2;                  /*!< [0x5] UART Status Register 2 */
    __IO hw_uart_c3_t C3;                  /*!< [0x6] UART Control Register 3 */
    __IO hw_uart_d_t D;                    /*!< [0x7] UART Data Register */
    __IO hw_uart_c4_t C4;                  /*!< [0x8] UART Control Register 4 */
} hw_uart_t;
#pragma pack()

/*! @brief Macro to access all UART registers. */
/*! @param x UART module instance base address. */
/*! @return Reference (not a pointer) to the registers struct. To get a pointer to the struct,
 *     use the '&' operator, like <code>&HW_UART(UART1_BASE)</code>. */
#define HW_UART(x)     (*(hw_uart_t *)(x))

#endif /* __HW_UART_REGISTERS_H__ */
/* v33/140401/2.1.0 */
/* EOF */

/*
 * Copyright (c) 2014, Freescale Semiconductor, Inc.
 * All rights reserved.
 *
 * THIS SOFTWARE IS PROVIDED BY FREESCALE "AS IS" AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
 * SHALL FREESCALE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
 * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
 * OF SUCH DAMAGE.
 */
/*
 * WARNING! DO NOT EDIT THIS FILE DIRECTLY!
 *
 * This file was generated automatically and any changes may be lost.
 */
#ifndef __HW_ADC_REGISTERS_H__
#define __HW_ADC_REGISTERS_H__

#include "MK20D5.h"
#include "fsl_bitband.h"

/*
 * MK20D5 ADC
 *
 * Analog-to-Digital Converter
 *
 * Registers defined in this header file:
 * - HW_ADC_SC1n - ADC status and control registers 1
 * - HW_ADC_CFG1 - ADC configuration register 1
 * - HW_ADC_CFG2 - Configuration register 2
 * - HW_ADC_Rn - ADC data result register
 * - HW_ADC_CV1 - Compare value registers
 * - HW_ADC_CV2 - Compare value registers
 * - HW_ADC_SC2 - Status and control register 2
 * - HW_ADC_SC3 - Status and control register 3
 * - HW_ADC_OFS - ADC offset correction register
 * - HW_ADC_PG - ADC plus-side gain register
 * - HW_ADC_CLPD - ADC plus-side general calibration value register
 * - HW_ADC_CLPS - ADC plus-side general calibration value register
 * - HW_ADC_CLP4 - ADC plus-side general calibration value register
 * - HW_ADC_CLP3 - ADC plus-side general calibration value register
 * - HW_ADC_CLP2 - ADC plus-side general calibration value register
 * - HW_ADC_CLP1 - ADC plus-side general calibration value register
 * - HW_ADC_CLP0 - ADC plus-side general calibration value register
 *
 * - hw_adc_t - Struct containing all module registers.
 */

#define HW_ADC_INSTANCE_COUNT (1U) /*!< Number of instances of the ADC module. */

/*******************************************************************************
 * HW_ADC_SC1n - ADC status and control registers 1
 ******************************************************************************/

/*!
 * @brief HW_ADC_SC1n - ADC status and control registers 1 (RW)
 *
 * Reset value: 0x0000001FU
 *
 * The SC1A register is used for both software and hardware trigger modes of
 * operation. To allow sequential conversions of the ADC to be triggered by internal
 * peripherals, the ADC can have more then one status and control register: one
 * for each conversion. The SC1B-SC1n registers indicate potentially multiple SC1
 * registers for use only in hardware trigger mode. Refer to the Chip
 * Configuration information about the number of SC1n registers specific to this device.
 * The SC1n registers have identical fields, and are used in a "ping-pong" approach
 * to control ADC operation. At any one point in time, only one of the SC1n
 * registers is actively controlling ADC conversions. Updating SC1A while SC1n is
 * actively controlling a conversion is allowed (and vice-versa for any of the SC1n
 * registers specific to this MCU). Writing SC1A while SC1A is actively
 * controlling a conversion aborts the current conversion. In software trigger mode
 * (ADTRG=0), writes to the SC1A register subsequently initiate a new conversion (if
 * the ADCH bits are equal to a value other than all 1s). Similarly, writing any of
 * the SC1n registers while that specific SC1n register is actively controlling
 * a conversion aborts the current conversion. None of the SC1B-SC1n registers
 * are used for software trigger operation and therefore writes to the SC1B - SC1n
 * registers do not initiate a new conversion.
 */
typedef union _hw_adc_sc1n
{
    uint32_t U;
    struct _hw_adc_sc1n_bitfields
    {
        uint32_t ADCH : 5;             /*!< [4:0] Input channel select */
        uint32_t RESERVED0 : 1;        /*!< [5]  */
        uint32_t AIEN : 1;             /*!< [6] Interrupt enable */
        uint32_t COCO : 1;             /*!< [7] Conversion complete flag */
        uint32_t RESERVED1 : 24;       /*!< [31:8]  */
    } B;
} hw_adc_sc1n_t;

/*!
 * @name Constants and macros for entire ADC_SC1n register
 */
/*@{*/
#define HW_ADC_SC1n_COUNT (2U)

#define HW_ADC_SC1n_ADDR(x, n)   ((x) + 0x0U + (0x4U * (n)))

#define HW_ADC_SC1n(x, n)        (*(__IO hw_adc_sc1n_t *) HW_ADC_SC1n_ADDR(x, n))
#define HW_ADC_SC1n_RD(x, n)     (HW_ADC_SC1n(x, n).U)
#define HW_ADC_SC1n_WR(x, n, v)  (HW_ADC_SC1n(x, n).U = (v))
#define HW_ADC_SC1n_SET(x, n, v) (HW_ADC_SC1n_WR(x, n, HW_ADC_SC1n_RD(x, n) |  (v)))
#define HW_ADC_SC1n_CLR(x, n, v) (HW_ADC_SC1n_WR(x, n, HW_ADC_SC1n_RD(x, n) & ~(v)))
#define HW_ADC_SC1n_TOG(x, n, v) (HW_ADC_SC1n_WR(x, n, HW_ADC_SC1n_RD(x, n) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual ADC_SC1n bitfields
 */

/*!
 * @name Register ADC_SC1n, field ADCH[4:0] (RW)
 *
 * Values:
 * - 00000 - AD0 is selected as input.
 * - 00001 - AD1 is selected as input.
 * - 00010 - AD2 is selected as input.
 * - 00011 - AD3 is selected as input.
 * - 00100 - AD4 is selected as input.
 * - 00101 - AD5 is selected as input.
 * - 00110 - AD6 is selected as input.
 * - 00111 - AD7 is selected as input.
 * - 01000 - AD8 is selected as input.
 * - 01001 - AD9 is selected as input.
 * - 01010 - AD10 is selected as input.
 * - 01011 - AD11 is selected as input.
 * - 01100 - AD12 is selected as input.
 * - 01101 - AD13 is selected as input.
 * - 01110 - AD14 is selected as input.
 * - 01111 - AD15 is selected as input.
 * - 10000 - AD16 is selected as input.
 * - 10001 - AD17 is selected as input.
 * - 10010 - AD18 is selected as input.
 * - 10011 - AD19 is selected as input.
 * - 10100 - AD20 is selected as input.
 * - 10101 - AD21 is selected as input.
 * - 10110 - AD22 is selected as input.
 * - 10111 - AD23 is selected as input.
 * - 11000 - Reserved.
 * - 11001 - Reserved.
 * - 11010 - Temp sensor (single-ended) is selected as input.
 * - 11011 - Bandgap (single-ended) is selected as input.
 * - 11100 - Reserved.
 * - 11101 - VREFSH is selected as input. Voltage reference selected is
 *     determined by the REFSEL bits in the SC2 register.
 * - 11110 - VREFSL is selected as input. Voltage reference selected is
 *     determined by the REFSEL bits in the SC2 register.
 * - 11111 - Module disabled.
 */
/*@{*/
#define BP_ADC_SC1n_ADCH     (0U)          /*!< Bit position for ADC_SC1n_ADCH. */
#define BM_ADC_SC1n_ADCH     (0x0000001FU) /*!< Bit mask for ADC_SC1n_ADCH. */
#define BS_ADC_SC1n_ADCH     (5U)          /*!< Bit field size in bits for ADC_SC1n_ADCH. */

/*! @brief Read current value of the ADC_SC1n_ADCH field. */
#define BR_ADC_SC1n_ADCH(x, n) (HW_ADC_SC1n(x, n).B.ADCH)

/*! @brief Format value for bitfield ADC_SC1n_ADCH. */
#define BF_ADC_SC1n_ADCH(v)  ((uint32_t)((uint32_t)(v) << BP_ADC_SC1n_ADCH) & BM_ADC_SC1n_ADCH)

/*! @brief Set the ADCH field to a new value. */
#define BW_ADC_SC1n_ADCH(x, n, v) (HW_ADC_SC1n_WR(x, n, (HW_ADC_SC1n_RD(x, n) & ~BM_ADC_SC1n_ADCH) | BF_ADC_SC1n_ADCH(v)))
/*@}*/

/*!
 * @name Register ADC_SC1n, field AIEN[6] (RW)
 *
 * Values:
 * - 0 - Conversion complete interrupt disabled.
 * - 1 - Conversion complete interrupt enabled.
 */
/*@{*/
#define BP_ADC_SC1n_AIEN     (6U)          /*!< Bit position for ADC_SC1n_AIEN. */
#define BM_ADC_SC1n_AIEN     (0x00000040U) /*!< Bit mask for ADC_SC1n_AIEN. */
#define BS_ADC_SC1n_AIEN     (1U)          /*!< Bit field size in bits for ADC_SC1n_AIEN. */

/*! @brief Read current value of the ADC_SC1n_AIEN field. */
#define BR_ADC_SC1n_AIEN(x, n) (BITBAND_ACCESS32(HW_ADC_SC1n_ADDR(x, n), BP_ADC_SC1n_AIEN))

/*! @brief Format value for bitfield ADC_SC1n_AIEN. */
#define BF_ADC_SC1n_AIEN(v)  ((uint32_t)((uint32_t)(v) << BP_ADC_SC1n_AIEN) & BM_ADC_SC1n_AIEN)

/*! @brief Set the AIEN field to a new value. */
#define BW_ADC_SC1n_AIEN(x, n, v) (BITBAND_ACCESS32(HW_ADC_SC1n_ADDR(x, n), BP_ADC_SC1n_AIEN) = (v))
/*@}*/

/*!
 * @name Register ADC_SC1n, field COCO[7] (RO)
 *
 * Values:
 * - 0 - Conversion not completed.
 * - 1 - Conversion completed.
 */
/*@{*/
#define BP_ADC_SC1n_COCO     (7U)          /*!< Bit position for ADC_SC1n_COCO. */
#define BM_ADC_SC1n_COCO     (0x00000080U) /*!< Bit mask for ADC_SC1n_COCO. */
#define BS_ADC_SC1n_COCO     (1U)          /*!< Bit field size in bits for ADC_SC1n_COCO. */

/*! @brief Read current value of the ADC_SC1n_COCO field. */
#define BR_ADC_SC1n_COCO(x, n) (BITBAND_ACCESS32(HW_ADC_SC1n_ADDR(x, n), BP_ADC_SC1n_COCO))
/*@}*/

/*******************************************************************************
 * HW_ADC_CFG1 - ADC configuration register 1
 ******************************************************************************/

/*!
 * @brief HW_ADC_CFG1 - ADC configuration register 1 (RW)
 *
 * Reset value: 0x00000000U
 *
 * CFG1 register selects the mode of operation, clock source, clock divide, and
 * configure for low power or long sample time.
 */
typedef union _hw_adc_cfg1
{
    uint32_t U;
    struct _hw_adc_cfg1_bitfields
    {
        uint32_t ADICLK : 2;           /*!< [1:0] Input clock select */
        uint32_t MODE : 2;             /*!< [3:2] Conversion mode selection */
        uint32_t ADLSMP : 1;           /*!< [4] Sample time configuration */
        uint32_t ADIV : 2;             /*!< [6:5] Clock divide select */
        uint32_t ADLPC : 1;            /*!< [7] Low-power configuration */
        uint32_t RESERVED0 : 24;       /*!< [31:8]  */
    } B;
} hw_adc_cfg1_t;

/*!
 * @name Constants and macros for entire ADC_CFG1 register
 */
/*@{*/
#define HW_ADC_CFG1_ADDR(x)      ((x) + 0x8U)

#define HW_ADC_CFG1(x)           (*(__IO hw_adc_cfg1_t *) HW_ADC_CFG1_ADDR(x))
#define HW_ADC_CFG1_RD(x)        (HW_ADC_CFG1(x).U)
#define HW_ADC_CFG1_WR(x, v)     (HW_ADC_CFG1(x).U = (v))
#define HW_ADC_CFG1_SET(x, v)    (HW_ADC_CFG1_WR(x, HW_ADC_CFG1_RD(x) |  (v)))
#define HW_ADC_CFG1_CLR(x, v)    (HW_ADC_CFG1_WR(x, HW_ADC_CFG1_RD(x) & ~(v)))
#define HW_ADC_CFG1_TOG(x, v)    (HW_ADC_CFG1_WR(x, HW_ADC_CFG1_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual ADC_CFG1 bitfields
 */

/*!
 * @name Register ADC_CFG1, field ADICLK[1:0] (RW)
 *
 * ADICLK bits select the input clock source to generate the internal clock,
 * ADCK. Note that when the ADACK clock source is selected, it is not required to be
 * active prior to conversion start. When it is selected and it is not active
 * prior to a conversion start (ADACKEN=0), the asynchronous clock is activated at
 * the start of a conversion and shuts off when conversions are terminated. In
 * this case, there is an associated clock startup delay each time the clock source
 * is re-activated.
 *
 * Values:
 * - 00 - Bus clock.
 * - 01 - Bus clock divided by 2.
 * - 10 - Alternate clock (ALTCLK).
 * - 11 - Asynchronous clock (ADACK).
 */
/*@{*/
#define BP_ADC_CFG1_ADICLK   (0U)          /*!< Bit position for ADC_CFG1_ADICLK. */
#define BM_ADC_CFG1_ADICLK   (0x00000003U) /*!< Bit mask for ADC_CFG1_ADICLK. */
#define BS_ADC_CFG1_ADICLK   (2U)          /*!< Bit field size in bits for ADC_CFG1_ADICLK. */

/*! @brief Read current value of the ADC_CFG1_ADICLK field. */
#define BR_ADC_CFG1_ADICLK(x) (HW_ADC_CFG1(x).B.ADICLK)

/*! @brief Format value for bitfield ADC_CFG1_ADICLK. */
#define BF_ADC_CFG1_ADICLK(v) ((uint32_t)((uint32_t)(v) << BP_ADC_CFG1_ADICLK) & BM_ADC_CFG1_ADICLK)

/*! @brief Set the ADICLK field to a new value. */
#define BW_ADC_CFG1_ADICLK(x, v) (HW_ADC_CFG1_WR(x, (HW_ADC_CFG1_RD(x) & ~BM_ADC_CFG1_ADICLK) | BF_ADC_CFG1_ADICLK(v)))
/*@}*/

/*!
 * @name Register ADC_CFG1, field MODE[3:2] (RW)
 *
 * MODE bits are used to select the ADC resolution mode.
 *
 * Values:
 * - 00 - It is single-ended 8-bit conversion.
 * - 01 - It is single-ended 12-bit conversion.
 * - 10 - It is single-ended 10-bit conversion.
 * - 11 - It is single-ended 16-bit conversion.
 */
/*@{*/
#define BP_ADC_CFG1_MODE     (2U)          /*!< Bit position for ADC_CFG1_MODE. */
#define BM_ADC_CFG1_MODE     (0x0000000CU) /*!< Bit mask for ADC_CFG1_MODE. */
#define BS_ADC_CFG1_MODE     (2U)          /*!< Bit field size in bits for ADC_CFG1_MODE. */

/*! @brief Read current value of the ADC_CFG1_MODE field. */
#define BR_ADC_CFG1_MODE(x)  (HW_ADC_CFG1(x).B.MODE)

/*! @brief Format value for bitfield ADC_CFG1_MODE. */
#define BF_ADC_CFG1_MODE(v)  ((uint32_t)((uint32_t)(v) << BP_ADC_CFG1_MODE) & BM_ADC_CFG1_MODE)

/*! @brief Set the MODE field to a new value. */
#define BW_ADC_CFG1_MODE(x, v) (HW_ADC_CFG1_WR(x, (HW_ADC_CFG1_RD(x) & ~BM_ADC_CFG1_MODE) | BF_ADC_CFG1_MODE(v)))
/*@}*/

/*!
 * @name Register ADC_CFG1, field ADLSMP[4] (RW)
 *
 * ADLSMP selects between different sample times based on the conversion mode
 * selected. This bit adjusts the sample period to allow higher impedance inputs to
 * be accurately sampled or to maximize conversion speed for lower impedance
 * inputs. Longer sample times can also be used to lower overall power consumption
 * if continuous conversions are enabled and high conversion rates are not
 * required. When ADLSMP=1, the long sample time select bits, (ADLSTS[1:0]), can select
 * the extent of the long sample time.
 *
 * Values:
 * - 0 - Short sample time.
 * - 1 - Long sample time.
 */
/*@{*/
#define BP_ADC_CFG1_ADLSMP   (4U)          /*!< Bit position for ADC_CFG1_ADLSMP. */
#define BM_ADC_CFG1_ADLSMP   (0x00000010U) /*!< Bit mask for ADC_CFG1_ADLSMP. */
#define BS_ADC_CFG1_ADLSMP   (1U)          /*!< Bit field size in bits for ADC_CFG1_ADLSMP. */

/*! @brief Read current value of the ADC_CFG1_ADLSMP field. */
#define BR_ADC_CFG1_ADLSMP(x) (BITBAND_ACCESS32(HW_ADC_CFG1_ADDR(x), BP_ADC_CFG1_ADLSMP))

/*! @brief Format value for bitfield ADC_CFG1_ADLSMP. */
#define BF_ADC_CFG1_ADLSMP(v) ((uint32_t)((uint32_t)(v) << BP_ADC_CFG1_ADLSMP) & BM_ADC_CFG1_ADLSMP)

/*! @brief Set the ADLSMP field to a new value. */
#define BW_ADC_CFG1_ADLSMP(x, v) (BITBAND_ACCESS32(HW_ADC_CFG1_ADDR(x), BP_ADC_CFG1_ADLSMP) = (v))
/*@}*/

/*!
 * @name Register ADC_CFG1, field ADIV[6:5] (RW)
 *
 * ADIV selects the divide ratio used by the ADC to generate the internal clock
 * ADCK.
 *
 * Values:
 * - 00 - The divide ratio is 1 and the clock rate is input clock.
 * - 01 - The divide ratio is 2 and the clock rate is (input clock)/2.
 * - 10 - The divide ratio is 4 and the clock rate is (input clock)/4.
 * - 11 - The divide ratio is 8 and the clock rate is (input clock)/8.
 */
/*@{*/
#define BP_ADC_CFG1_ADIV     (5U)          /*!< Bit position for ADC_CFG1_ADIV. */
#define BM_ADC_CFG1_ADIV     (0x00000060U) /*!< Bit mask for ADC_CFG1_ADIV. */
#define BS_ADC_CFG1_ADIV     (2U)          /*!< Bit field size in bits for ADC_CFG1_ADIV. */

/*! @brief Read current value of the ADC_CFG1_ADIV field. */
#define BR_ADC_CFG1_ADIV(x)  (HW_ADC_CFG1(x).B.ADIV)

/*! @brief Format value for bitfield ADC_CFG1_ADIV. */
#define BF_ADC_CFG1_ADIV(v)  ((uint32_t)((uint32_t)(v) << BP_ADC_CFG1_ADIV) & BM_ADC_CFG1_ADIV)

/*! @brief Set the ADIV field to a new value. */
#define BW_ADC_CFG1_ADIV(x, v) (HW_ADC_CFG1_WR(x, (HW_ADC_CFG1_RD(x) & ~BM_ADC_CFG1_ADIV) | BF_ADC_CFG1_ADIV(v)))
/*@}*/

/*!
 * @name Register ADC_CFG1, field ADLPC[7] (RW)
 *
 * ADLPC controls the power configuration of the successive approximation
 * converter. This optimizes power consumption when higher sample rates are not
 * required.
 *
 * Values:
 * - 0 - Normal power configuration.
 * - 1 - Low power configuration. The power is reduced at the expense of maximum
 *     clock speed.
 */
/*@{*/
#define BP_ADC_CFG1_ADLPC    (7U)          /*!< Bit position for ADC_CFG1_ADLPC. */
#define BM_ADC_CFG1_ADLPC    (0x00000080U) /*!< Bit mask for ADC_CFG1_ADLPC. */
#define BS_ADC_CFG1_ADLPC    (1U)          /*!< Bit field size in bits for ADC_CFG1_ADLPC. */

/*! @brief Read current value of the ADC_CFG1_ADLPC field. */
#define BR_ADC_CFG1_ADLPC(x) (BITBAND_ACCESS32(HW_ADC_CFG1_ADDR(x), BP_ADC_CFG1_ADLPC))

/*! @brief Format value for bitfield ADC_CFG1_ADLPC. */
#define BF_ADC_CFG1_ADLPC(v) ((uint32_t)((uint32_t)(v) << BP_ADC_CFG1_ADLPC) & BM_ADC_CFG1_ADLPC)

/*! @brief Set the ADLPC field to a new value. */
#define BW_ADC_CFG1_ADLPC(x, v) (BITBAND_ACCESS32(HW_ADC_CFG1_ADDR(x), BP_ADC_CFG1_ADLPC) = (v))
/*@}*/

/*******************************************************************************
 * HW_ADC_CFG2 - Configuration register 2
 ******************************************************************************/

/*!
 * @brief HW_ADC_CFG2 - Configuration register 2 (RW)
 *
 * Reset value: 0x00000000U
 *
 * CFG2 register selects the special high speed configuration for very high
 * speed conversions and selects the long sample time duration during long sample
 * mode.
 */
typedef union _hw_adc_cfg2
{
    uint32_t U;
    struct _hw_adc_cfg2_bitfields
    {
        uint32_t ADLSTS : 2;           /*!< [1:0] Long sample time select */
        uint32_t ADHSC : 1;            /*!< [2] High speed configuration */
        uint32_t ADACKEN : 1;          /*!< [3] Asynchronous clock output enable */
        uint32_t MUXSEL : 1;           /*!< [4] ADC Mux select */
        uint32_t RESERVED0 : 27;       /*!< [31:5]  */
    } B;
} hw_adc_cfg2_t;

/*!
 * @name Constants and macros for entire ADC_CFG2 register
 */
/*@{*/
#define HW_ADC_CFG2_ADDR(x)      ((x) + 0xCU)

#define HW_ADC_CFG2(x)           (*(__IO hw_adc_cfg2_t *) HW_ADC_CFG2_ADDR(x))
#define HW_ADC_CFG2_RD(x)        (HW_ADC_CFG2(x).U)
#define HW_ADC_CFG2_WR(x, v)     (HW_ADC_CFG2(x).U = (v))
#define HW_ADC_CFG2_SET(x, v)    (HW_ADC_CFG2_WR(x, HW_ADC_CFG2_RD(x) |  (v)))
#define HW_ADC_CFG2_CLR(x, v)    (HW_ADC_CFG2_WR(x, HW_ADC_CFG2_RD(x) & ~(v)))
#define HW_ADC_CFG2_TOG(x, v)    (HW_ADC_CFG2_WR(x, HW_ADC_CFG2_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual ADC_CFG2 bitfields
 */

/*!
 * @name Register ADC_CFG2, field ADLSTS[1:0] (RW)
 *
 * ADLSTS selects between the extended sample times when long sample time is
 * selected (ADLSMP=1). This allows higher impedance inputs to be accurately sampled
 * or to maximize conversion speed for lower impedance inputs. Longer sample
 * times can also be used to lower overall power consumption when continuous
 * conversions are enabled if high conversion rates are not required.
 *
 * Values:
 * - 00 - Default longest sample time (20 extra ADCK cycles; 24 ADCK cycles
 *     total).
 * - 01 - 12 extra ADCK cycles; 16 ADCK cycles total sample time.
 * - 10 - 6 extra ADCK cycles; 10 ADCK cycles total sample time.
 * - 11 - 2 extra ADCK cycles; 6 ADCK cycles total sample time.
 */
/*@{*/
#define BP_ADC_CFG2_ADLSTS   (0U)          /*!< Bit position for ADC_CFG2_ADLSTS. */
#define BM_ADC_CFG2_ADLSTS   (0x00000003U) /*!< Bit mask for ADC_CFG2_ADLSTS. */
#define BS_ADC_CFG2_ADLSTS   (2U)          /*!< Bit field size in bits for ADC_CFG2_ADLSTS. */

/*! @brief Read current value of the ADC_CFG2_ADLSTS field. */
#define BR_ADC_CFG2_ADLSTS(x) (HW_ADC_CFG2(x).B.ADLSTS)

/*! @brief Format value for bitfield ADC_CFG2_ADLSTS. */
#define BF_ADC_CFG2_ADLSTS(v) ((uint32_t)((uint32_t)(v) << BP_ADC_CFG2_ADLSTS) & BM_ADC_CFG2_ADLSTS)

/*! @brief Set the ADLSTS field to a new value. */
#define BW_ADC_CFG2_ADLSTS(x, v) (HW_ADC_CFG2_WR(x, (HW_ADC_CFG2_RD(x) & ~BM_ADC_CFG2_ADLSTS) | BF_ADC_CFG2_ADLSTS(v)))
/*@}*/

/*!
 * @name Register ADC_CFG2, field ADHSC[2] (RW)
 *
 * ADHSC configures the ADC for very high speed operation. The conversion
 * sequence is altered (2 ADCK cycles added to the conversion time) to allow higher
 * speed conversion clocks.
 *
 * Values:
 * - 0 - Normal conversion sequence selected.
 * - 1 - High speed conversion sequence selected (2 additional ADCK cycles to
 *     total conversion time).
 */
/*@{*/
#define BP_ADC_CFG2_ADHSC    (2U)          /*!< Bit position for ADC_CFG2_ADHSC. */
#define BM_ADC_CFG2_ADHSC    (0x00000004U) /*!< Bit mask for ADC_CFG2_ADHSC. */
#define BS_ADC_CFG2_ADHSC    (1U)          /*!< Bit field size in bits for ADC_CFG2_ADHSC. */

/*! @brief Read current value of the ADC_CFG2_ADHSC field. */
#define BR_ADC_CFG2_ADHSC(x) (BITBAND_ACCESS32(HW_ADC_CFG2_ADDR(x), BP_ADC_CFG2_ADHSC))

/*! @brief Format value for bitfield ADC_CFG2_ADHSC. */
#define BF_ADC_CFG2_ADHSC(v) ((uint32_t)((uint32_t)(v) << BP_ADC_CFG2_ADHSC) & BM_ADC_CFG2_ADHSC)

/*! @brief Set the ADHSC field to a new value. */
#define BW_ADC_CFG2_ADHSC(x, v) (BITBAND_ACCESS32(HW_ADC_CFG2_ADDR(x), BP_ADC_CFG2_ADHSC) = (v))
/*@}*/

/*!
 * @name Register ADC_CFG2, field ADACKEN[3] (RW)
 *
 * ADACKEN enables the ADC's asynchronous clock source and the clock source
 * output regardless of the conversion and input clock select (ADICLK bits) status of
 * the ADC. Based on MCU configuration, the asynchronous clock may be used by
 * other modules (see Chip Configuration information). Setting this bit allows the
 * clock to be used even while the ADC is idle or operating from a different
 * clock source. Also, latency of initiating a single or first-continuous conversion
 * with the asynchronous clock selected is reduced since the ADACK clock is
 * already operational.
 *
 * Values:
 * - 0 - Asynchronous clock output disabled; Asynchronous clock only enabled if
 *     selected by ADICLK and a conversion is active.
 * - 1 - Asynchronous clock and clock output enabled regardless of the state of
 *     the ADC.
 */
/*@{*/
#define BP_ADC_CFG2_ADACKEN  (3U)          /*!< Bit position for ADC_CFG2_ADACKEN. */
#define BM_ADC_CFG2_ADACKEN  (0x00000008U) /*!< Bit mask for ADC_CFG2_ADACKEN. */
#define BS_ADC_CFG2_ADACKEN  (1U)          /*!< Bit field size in bits for ADC_CFG2_ADACKEN. */

/*! @brief Read current value of the ADC_CFG2_ADACKEN field. */
#define BR_ADC_CFG2_ADACKEN(x) (BITBAND_ACCESS32(HW_ADC_CFG2_ADDR(x), BP_ADC_CFG2_ADACKEN))

/*! @brief Format value for bitfield ADC_CFG2_ADACKEN. */
#define BF_ADC_CFG2_ADACKEN(v) ((uint32_t)((uint32_t)(v) << BP_ADC_CFG2_ADACKEN) & BM_ADC_CFG2_ADACKEN)

/*! @brief Set the ADACKEN field to a new value. */
#define BW_ADC_CFG2_ADACKEN(x, v) (BITBAND_ACCESS32(HW_ADC_CFG2_ADDR(x), BP_ADC_CFG2_ADACKEN) = (v))
/*@}*/

/*!
 * @name Register ADC_CFG2, field MUXSEL[4] (RW)
 *
 * ADC Mux select bit is used to change the ADC mux setting to select between
 * alternate sets of ADC channels.
 *
 * Values:
 * - 0 - ADxxa channels are selected.
 * - 1 - ADxxb channels are selected.
 */
/*@{*/
#define BP_ADC_CFG2_MUXSEL   (4U)          /*!< Bit position for ADC_CFG2_MUXSEL. */
#define BM_ADC_CFG2_MUXSEL   (0x00000010U) /*!< Bit mask for ADC_CFG2_MUXSEL. */
#define BS_ADC_CFG2_MUXSEL   (1U)          /*!< Bit field size in bits for ADC_CFG2_MUXSEL. */

/*! @brief Read current value of the ADC_CFG2_MUXSEL field. */
#define BR_ADC_CFG2_MUXSEL(x) (BITBAND_ACCESS32(HW_ADC_CFG2_ADDR(x), BP_ADC_CFG2_MUXSEL))

/*! @brief Format value for bitfield ADC_CFG2_MUXSEL. */
#define BF_ADC_CFG2_MUXSEL(v) ((uint32_t)((uint32_t)(v) << BP_ADC_CFG2_MUXSEL) & BM_ADC_CFG2_MUXSEL)

/*! @brief Set the MUXSEL field to a new value. */
#define BW_ADC_CFG2_MUXSEL(x, v) (BITBAND_ACCESS32(HW_ADC_CFG2_ADDR(x), BP_ADC_CFG2_MUXSEL) = (v))
/*@}*/

/*******************************************************************************
 * HW_ADC_Rn - ADC data result register
 ******************************************************************************/

/*!
 * @brief HW_ADC_Rn - ADC data result register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The data result registers (Rn) contain the result of an ADC conversion of the
 * channel selected by the corresponding status and channel control register
 * (SC1A:SC1n). For every status and channel control register, there is a
 * corresponding data result register. Unused bits in the Rn register are cleared in
 * unsigned right justified modes and carry the sign bit (MSB) in sign extended 2's
 * complement modes. The following table describes the behavior of the data result
 * registers in the different modes of operation. Data result register description
 * Conversion mode D15 D14 D13 D12 D11 D10 D9 D8 D7 D6 D5 D4 D3 D2 D1 D0 Format
 * 16-bit differential S D D D D D D D D D D D D D D D Signed 2's complement
 * 16-bit single-ended D D D D D D D D D D D D D D D D Unsigned right justified
 * 12-bit single-ended 0 0 0 0 D D D D D D D D D D D D Unsigned right justified 10-bit
 * single-ended 0 0 0 0 0 0 D D D D D D D D D D Unsigned right justified 8-bit
 * single-ended 0 0 0 0 0 0 0 0 D D D D D D D D Unsigned right justified S: Sign
 * bit or sign bit extension; D: Data (2's complement data if indicated)
 */
typedef union _hw_adc_rn
{
    uint32_t U;
    struct _hw_adc_rn_bitfields
    {
        uint32_t D : 16;               /*!< [15:0] Data result */
        uint32_t RESERVED0 : 16;       /*!< [31:16]  */
    } B;
} hw_adc_rn_t;

/*!
 * @name Constants and macros for entire ADC_Rn register
 */
/*@{*/
#define HW_ADC_Rn_COUNT (2U)

#define HW_ADC_Rn_ADDR(x, n)     ((x) + 0x10U + (0x4U * (n)))

#define HW_ADC_Rn(x, n)          (*(__I hw_adc_rn_t *) HW_ADC_Rn_ADDR(x, n))
#define HW_ADC_Rn_RD(x, n)       (HW_ADC_Rn(x, n).U)
/*@}*/

/*
 * Constants & macros for individual ADC_Rn bitfields
 */

/*!
 * @name Register ADC_Rn, field D[15:0] (RO)
 */
/*@{*/
#define BP_ADC_Rn_D          (0U)          /*!< Bit position for ADC_Rn_D. */
#define BM_ADC_Rn_D          (0x0000FFFFU) /*!< Bit mask for ADC_Rn_D. */
#define BS_ADC_Rn_D          (16U)         /*!< Bit field size in bits for ADC_Rn_D. */

/*! @brief Read current value of the ADC_Rn_D field. */
#define BR_ADC_Rn_D(x, n)    (HW_ADC_Rn(x, n).B.D)
/*@}*/

/*******************************************************************************
 * HW_ADC_CV1 - Compare value registers
 ******************************************************************************/

/*!
 * @brief HW_ADC_CV1 - Compare value registers (RW)
 *
 * Reset value: 0x00000000U
 *
 * The compare value registers (CV1 and CV2) contain a compare value used to
 * compare with the conversion result when the compare function is enabled (ACFE=1).
 * This register is formatted the same for both bit position definition and
 * value format (unsigned or sign-extended 2's complement) as the data result
 * registers (Rn) in the different modes of operation. Therefore, the compare function
 * only uses the compare value register bits that are related to the ADC mode of
 * operation. The compare value 2 register (CV2) is utilized only when the compare
 * range function is enabled (ACREN=1).
 */
typedef union _hw_adc_cv1
{
    uint32_t U;
    struct _hw_adc_cv1_bitfields
    {
        uint32_t CV : 16;              /*!< [15:0] Compare value */
        uint32_t RESERVED0 : 16;       /*!< [31:16]  */
    } B;
} hw_adc_cv1_t;

/*!
 * @name Constants and macros for entire ADC_CV1 register
 */
/*@{*/
#define HW_ADC_CV1_ADDR(x)       ((x) + 0x18U)

#define HW_ADC_CV1(x)            (*(__IO hw_adc_cv1_t *) HW_ADC_CV1_ADDR(x))
#define HW_ADC_CV1_RD(x)         (HW_ADC_CV1(x).U)
#define HW_ADC_CV1_WR(x, v)      (HW_ADC_CV1(x).U = (v))
#define HW_ADC_CV1_SET(x, v)     (HW_ADC_CV1_WR(x, HW_ADC_CV1_RD(x) |  (v)))
#define HW_ADC_CV1_CLR(x, v)     (HW_ADC_CV1_WR(x, HW_ADC_CV1_RD(x) & ~(v)))
#define HW_ADC_CV1_TOG(x, v)     (HW_ADC_CV1_WR(x, HW_ADC_CV1_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual ADC_CV1 bitfields
 */

/*!
 * @name Register ADC_CV1, field CV[15:0] (RW)
 */
/*@{*/
#define BP_ADC_CV1_CV        (0U)          /*!< Bit position for ADC_CV1_CV. */
#define BM_ADC_CV1_CV        (0x0000FFFFU) /*!< Bit mask for ADC_CV1_CV. */
#define BS_ADC_CV1_CV        (16U)         /*!< Bit field size in bits for ADC_CV1_CV. */

/*! @brief Read current value of the ADC_CV1_CV field. */
#define BR_ADC_CV1_CV(x)     (HW_ADC_CV1(x).B.CV)

/*! @brief Format value for bitfield ADC_CV1_CV. */
#define BF_ADC_CV1_CV(v)     ((uint32_t)((uint32_t)(v) << BP_ADC_CV1_CV) & BM_ADC_CV1_CV)

/*! @brief Set the CV field to a new value. */
#define BW_ADC_CV1_CV(x, v)  (HW_ADC_CV1_WR(x, (HW_ADC_CV1_RD(x) & ~BM_ADC_CV1_CV) | BF_ADC_CV1_CV(v)))
/*@}*/

/*******************************************************************************
 * HW_ADC_CV2 - Compare value registers
 ******************************************************************************/

/*!
 * @brief HW_ADC_CV2 - Compare value registers (RW)
 *
 * Reset value: 0x00000000U
 *
 * The compare value registers (CV1 and CV2) contain a compare value used to
 * compare with the conversion result when the compare function is enabled (ACFE=1).
 * This register is formatted the same for both bit position definition and
 * value format (unsigned or sign-extended 2's complement) as the data result
 * registers (Rn) in the different modes of operation. Therefore, the compare function
 * only uses the compare value register bits that are related to the ADC mode of
 * operation. The compare value 2 register (CV2) is utilized only when the compare
 * range function is enabled (ACREN=1).
 */
typedef union _hw_adc_cv2
{
    uint32_t U;
    struct _hw_adc_cv2_bitfields
    {
        uint32_t CV : 16;              /*!< [15:0] Compare value */
        uint32_t RESERVED0 : 16;       /*!< [31:16]  */
    } B;
} hw_adc_cv2_t;

/*!
 * @name Constants and macros for entire ADC_CV2 register
 */
/*@{*/
#define HW_ADC_CV2_ADDR(x)       ((x) + 0x1CU)

#define HW_ADC_CV2(x)            (*(__IO hw_adc_cv2_t *) HW_ADC_CV2_ADDR(x))
#define HW_ADC_CV2_RD(x)         (HW_ADC_CV2(x).U)
#define HW_ADC_CV2_WR(x, v)      (HW_ADC_CV2(x).U = (v))
#define HW_ADC_CV2_SET(x, v)     (HW_ADC_CV2_WR(x, HW_ADC_CV2_RD(x) |  (v)))
#define HW_ADC_CV2_CLR(x, v)     (HW_ADC_CV2_WR(x, HW_ADC_CV2_RD(x) & ~(v)))
#define HW_ADC_CV2_TOG(x, v)     (HW_ADC_CV2_WR(x, HW_ADC_CV2_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual ADC_CV2 bitfields
 */

/*!
 * @name Register ADC_CV2, field CV[15:0] (RW)
 */
/*@{*/
#define BP_ADC_CV2_CV        (0U)          /*!< Bit position for ADC_CV2_CV. */
#define BM_ADC_CV2_CV        (0x0000FFFFU) /*!< Bit mask for ADC_CV2_CV. */
#define BS_ADC_CV2_CV        (16U)         /*!< Bit field size in bits for ADC_CV2_CV. */

/*! @brief Read current value of the ADC_CV2_CV field. */
#define BR_ADC_CV2_CV(x)     (HW_ADC_CV2(x).B.CV)

/*! @brief Format value for bitfield ADC_CV2_CV. */
#define BF_ADC_CV2_CV(v)     ((uint32_t)((uint32_t)(v) << BP_ADC_CV2_CV) & BM_ADC_CV2_CV)

/*! @brief Set the CV field to a new value. */
#define BW_ADC_CV2_CV(x, v)  (HW_ADC_CV2_WR(x, (HW_ADC_CV2_RD(x) & ~BM_ADC_CV2_CV) | BF_ADC_CV2_CV(v)))
/*@}*/

/*******************************************************************************
 * HW_ADC_SC2 - Status and control register 2
 ******************************************************************************/

/*!
 * @brief HW_ADC_SC2 - Status and control register 2 (RW)
 *
 * Reset value: 0x00000000U
 *
 * The SC2 register contains the conversion active, hardware/software trigger
 * select, compare function and voltage reference select of the ADC module.
 */
typedef union _hw_adc_sc2
{
    uint32_t U;
    struct _hw_adc_sc2_bitfields
    {
        uint32_t REFSEL : 2;           /*!< [1:0] Voltage reference selection */
        uint32_t DMAEN : 1;            /*!< [2] DMA enable */
        uint32_t ACREN : 1;            /*!< [3] Compare function range enable */
        uint32_t ACFGT : 1;            /*!< [4] Compare function greater than enable */
        uint32_t ACFE : 1;             /*!< [5] Compare function enable */
        uint32_t ADTRG : 1;            /*!< [6] Conversion trigger select */
        uint32_t ADACT : 1;            /*!< [7] Conversion active */
        uint32_t RESERVED0 : 24;       /*!< [31:8]  */
    } B;
} hw_adc_sc2_t;

/*!
 * @name Constants and macros for entire ADC_SC2 register
 */
/*@{*/
#define HW_ADC_SC2_ADDR(x)       ((x) + 0x20U)

#define HW_ADC_SC2(x)            (*(__IO hw_adc_sc2_t *) HW_ADC_SC2_ADDR(x))
#define HW_ADC_SC2_RD(x)         (HW_ADC_SC2(x).U)
#define HW_ADC_SC2_WR(x, v)      (HW_ADC_SC2(x).U = (v))
#define HW_ADC_SC2_SET(x, v)     (HW_ADC_SC2_WR(x, HW_ADC_SC2_RD(x) |  (v)))
#define HW_ADC_SC2_CLR(x, v)     (HW_ADC_SC2_WR(x, HW_ADC_SC2_RD(x) & ~(v)))
#define HW_ADC_SC2_TOG(x, v)     (HW_ADC_SC2_WR(x, HW_ADC_SC2_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual ADC_SC2 bitfields
 */

/*!
 * @name Register ADC_SC2, field REFSEL[1:0] (RW)
 *
 * REFSEL bits select the voltage reference source used for conversions.
 *
 * Values:
 * - 00 - Default voltage reference pin pair (external pins VREFH and VREFL)
 * - 01 - Alternate reference pair (VALTH and VALTL). This pair may be
 *     additional external pins or internal sources depending on MCU configuration.
 *     Consult the Chip Configuration information for details specific to this MCU.
 * - 10 - Reserved
 * - 11 - Reserved
 */
/*@{*/
#define BP_ADC_SC2_REFSEL    (0U)          /*!< Bit position for ADC_SC2_REFSEL. */
#define BM_ADC_SC2_REFSEL    (0x00000003U) /*!< Bit mask for ADC_SC2_REFSEL. */
#define BS_ADC_SC2_REFSEL    (2U)          /*!< Bit field size in bits for ADC_SC2_REFSEL. */

/*! @brief Read current value of the ADC_SC2_REFSEL field. */
#define BR_ADC_SC2_REFSEL(x) (HW_ADC_SC2(x).B.REFSEL)

/*! @brief Format value for bitfield ADC_SC2_REFSEL. */
#define BF_ADC_SC2_REFSEL(v) ((uint32_t)((uint32_t)(v) << BP_ADC_SC2_REFSEL) & BM_ADC_SC2_REFSEL)

/*! @brief Set the REFSEL field to a new value. */
#define BW_ADC_SC2_REFSEL(x, v) (HW_ADC_SC2_WR(x, (HW_ADC_SC2_RD(x) & ~BM_ADC_SC2_REFSEL) | BF_ADC_SC2_REFSEL(v)))
/*@}*/

/*!
 * @name Register ADC_SC2, field DMAEN[2] (RW)
 *
 * Values:
 * - 0 - DMA is disabled.
 * - 1 - DMA is enabled and will assert the ADC DMA request during a ADC
 *     conversion complete event noted by the assertion of any of the ADC COCO flags.
 */
/*@{*/
#define BP_ADC_SC2_DMAEN     (2U)          /*!< Bit position for ADC_SC2_DMAEN. */
#define BM_ADC_SC2_DMAEN     (0x00000004U) /*!< Bit mask for ADC_SC2_DMAEN. */
#define BS_ADC_SC2_DMAEN     (1U)          /*!< Bit field size in bits for ADC_SC2_DMAEN. */

/*! @brief Read current value of the ADC_SC2_DMAEN field. */
#define BR_ADC_SC2_DMAEN(x)  (BITBAND_ACCESS32(HW_ADC_SC2_ADDR(x), BP_ADC_SC2_DMAEN))

/*! @brief Format value for bitfield ADC_SC2_DMAEN. */
#define BF_ADC_SC2_DMAEN(v)  ((uint32_t)((uint32_t)(v) << BP_ADC_SC2_DMAEN) & BM_ADC_SC2_DMAEN)

/*! @brief Set the DMAEN field to a new value. */
#define BW_ADC_SC2_DMAEN(x, v) (BITBAND_ACCESS32(HW_ADC_SC2_ADDR(x), BP_ADC_SC2_DMAEN) = (v))
/*@}*/

/*!
 * @name Register ADC_SC2, field ACREN[3] (RW)
 *
 * ACREN configures the compare function to check if the conversion result of
 * the input being monitored is either between or outside the range formed by the
 * compare value registers (CV1 and CV2) determined by the value of ACFGT. The
 * ACFE bit must be set for ACFGT to have any effect.
 *
 * Values:
 * - 0 - Range function disabled. Only the compare value 1 register (CV1) is
 *     compared.
 * - 1 - Range function enabled. Both compare value registers (CV1 and CV2) are
 *     compared.
 */
/*@{*/
#define BP_ADC_SC2_ACREN     (3U)          /*!< Bit position for ADC_SC2_ACREN. */
#define BM_ADC_SC2_ACREN     (0x00000008U) /*!< Bit mask for ADC_SC2_ACREN. */
#define BS_ADC_SC2_ACREN     (1U)          /*!< Bit field size in bits for ADC_SC2_ACREN. */

/*! @brief Read current value of the ADC_SC2_ACREN field. */
#define BR_ADC_SC2_ACREN(x)  (BITBAND_ACCESS32(HW_ADC_SC2_ADDR(x), BP_ADC_SC2_ACREN))

/*! @brief Format value for bitfield ADC_SC2_ACREN. */
#define BF_ADC_SC2_ACREN(v)  ((uint32_t)((uint32_t)(v) << BP_ADC_SC2_ACREN) & BM_ADC_SC2_ACREN)

/*! @brief Set the ACREN field to a new value. */
#define BW_ADC_SC2_ACREN(x, v) (BITBAND_ACCESS32(HW_ADC_SC2_ADDR(x), BP_ADC_SC2_ACREN) = (v))
/*@}*/

/*!
 * @name Register ADC_SC2, field ACFGT[4] (RW)
 *
 * ACFGT configures the compare function to check the conversion result relative
 * to the compare value register(s) (CV1 and CV2) based upon the value of ACREN.
 * The ACFE bit must be set for ACFGT to have any effect.
 *
 * Values:
 * - 0 - Configures less than threshold, outside range not inclusive and inside
 *     range not inclusive functionality based on the values placed in the CV1
 *     and CV2 registers.
 * - 1 - Configures greater than or equal to threshold, outside range inclusive
 *     and inside range inclusive functionality based on the values placed in the
 *     CV1 and CV2 registers.
 */
/*@{*/
#define BP_ADC_SC2_ACFGT     (4U)          /*!< Bit position for ADC_SC2_ACFGT. */
#define BM_ADC_SC2_ACFGT     (0x00000010U) /*!< Bit mask for ADC_SC2_ACFGT. */
#define BS_ADC_SC2_ACFGT     (1U)          /*!< Bit field size in bits for ADC_SC2_ACFGT. */

/*! @brief Read current value of the ADC_SC2_ACFGT field. */
#define BR_ADC_SC2_ACFGT(x)  (BITBAND_ACCESS32(HW_ADC_SC2_ADDR(x), BP_ADC_SC2_ACFGT))

/*! @brief Format value for bitfield ADC_SC2_ACFGT. */
#define BF_ADC_SC2_ACFGT(v)  ((uint32_t)((uint32_t)(v) << BP_ADC_SC2_ACFGT) & BM_ADC_SC2_ACFGT)

/*! @brief Set the ACFGT field to a new value. */
#define BW_ADC_SC2_ACFGT(x, v) (BITBAND_ACCESS32(HW_ADC_SC2_ADDR(x), BP_ADC_SC2_ACFGT) = (v))
/*@}*/

/*!
 * @name Register ADC_SC2, field ACFE[5] (RW)
 *
 * ACFE enables the compare function.
 *
 * Values:
 * - 0 - Compare function disabled.
 * - 1 - Compare function enabled.
 */
/*@{*/
#define BP_ADC_SC2_ACFE      (5U)          /*!< Bit position for ADC_SC2_ACFE. */
#define BM_ADC_SC2_ACFE      (0x00000020U) /*!< Bit mask for ADC_SC2_ACFE. */
#define BS_ADC_SC2_ACFE      (1U)          /*!< Bit field size in bits for ADC_SC2_ACFE. */

/*! @brief Read current value of the ADC_SC2_ACFE field. */
#define BR_ADC_SC2_ACFE(x)   (BITBAND_ACCESS32(HW_ADC_SC2_ADDR(x), BP_ADC_SC2_ACFE))

/*! @brief Format value for bitfield ADC_SC2_ACFE. */
#define BF_ADC_SC2_ACFE(v)   ((uint32_t)((uint32_t)(v) << BP_ADC_SC2_ACFE) & BM_ADC_SC2_ACFE)

/*! @brief Set the ACFE field to a new value. */
#define BW_ADC_SC2_ACFE(x, v) (BITBAND_ACCESS32(HW_ADC_SC2_ADDR(x), BP_ADC_SC2_ACFE) = (v))
/*@}*/

/*!
 * @name Register ADC_SC2, field ADTRG[6] (RW)
 *
 * ADTRG selects the type of trigger used for initiating a conversion. Two types
 * of trigger are selectable: software trigger and hardware trigger. When
 * software trigger is selected, a conversion is initiated following a write to SC1A.
 * When hardware trigger is selected, a conversion is initiated following the
 * assertion of the ADHWT input after a pulse of the ADHWTSn input.
 *
 * Values:
 * - 0 - Software trigger selected.
 * - 1 - Hardware trigger selected.
 */
/*@{*/
#define BP_ADC_SC2_ADTRG     (6U)          /*!< Bit position for ADC_SC2_ADTRG. */
#define BM_ADC_SC2_ADTRG     (0x00000040U) /*!< Bit mask for ADC_SC2_ADTRG. */
#define BS_ADC_SC2_ADTRG     (1U)          /*!< Bit field size in bits for ADC_SC2_ADTRG. */

/*! @brief Read current value of the ADC_SC2_ADTRG field. */
#define BR_ADC_SC2_ADTRG(x)  (BITBAND_ACCESS32(HW_ADC_SC2_ADDR(x), BP_ADC_SC2_ADTRG))

/*! @brief Format value for bitfield ADC_SC2_ADTRG. */
#define BF_ADC_SC2_ADTRG(v)  ((uint32_t)((uint32_t)(v) << BP_ADC_SC2_ADTRG) & BM_ADC_SC2_ADTRG)

/*! @brief Set the ADTRG field to a new value. */
#define BW_ADC_SC2_ADTRG(x, v) (BITBAND_ACCESS32(HW_ADC_SC2_ADDR(x), BP_ADC_SC2_ADTRG) = (v))
/*@}*/

/*!
 * @name Register ADC_SC2, field ADACT[7] (RO)
 *
 * ADACT indicates that a conversion or hardware averaging is in progress. ADACT
 * is set when a conversion is initiated and cleared when a conversion is
 * completed or aborted.
 *
 * Values:
 * - 0 - Conversion not in progress.
 * - 1 - Conversion in progress.
 */
/*@{*/
#define BP_ADC_SC2_ADACT     (7U)          /*!< Bit position for ADC_SC2_ADACT. */
#define BM_ADC_SC2_ADACT     (0x00000080U) /*!< Bit mask for ADC_SC2_ADACT. */
#define BS_ADC_SC2_ADACT     (1U)          /*!< Bit field size in bits for ADC_SC2_ADACT. */

/*! @brief Read current value of the ADC_SC2_ADACT field. */
#define BR_ADC_SC2_ADACT(x)  (BITBAND_ACCESS32(HW_ADC_SC2_ADDR(x), BP_ADC_SC2_ADACT))
/*@}*/

/*******************************************************************************
 * HW_ADC_SC3 - Status and control register 3
 ******************************************************************************/

/*!
 * @brief HW_ADC_SC3 - Status and control register 3 (RW)
 *
 * Reset value: 0x00000000U
 *
 * The SC3 register controls the calibration, continuous convert, and hardware
 * averaging functions of the ADC module.
 */
typedef union _hw_adc_sc3
{
    uint32_t U;
    struct _hw_adc_sc3_bitfields
    {
        uint32_t AVGS : 2;             /*!< [1:0] Hardware average select */
        uint32_t AVGE : 1;             /*!< [2] Hardware average enable */
        uint32_t ADCO : 1;             /*!< [3] Continuous conversion enable */
        uint32_t RESERVED0 : 2;        /*!< [5:4]  */
        uint32_t CALF : 1;             /*!< [6] Calibration failed flag */
        uint32_t CAL : 1;              /*!< [7] Calibration */
        uint32_t RESERVED1 : 24;       /*!< [31:8]  */
    } B;
} hw_adc_sc3_t;

/*!
 * @name Constants and macros for entire ADC_SC3 register
 */
/*@{*/
#define HW_ADC_SC3_ADDR(x)       ((x) + 0x24U)

#define HW_ADC_SC3(x)            (*(__IO hw_adc_sc3_t *) HW_ADC_SC3_ADDR(x))
#define HW_ADC_SC3_RD(x)         (HW_ADC_SC3(x).U)
#define HW_ADC_SC3_WR(x, v)      (HW_ADC_SC3(x).U = (v))
#define HW_ADC_SC3_SET(x, v)     (HW_ADC_SC3_WR(x, HW_ADC_SC3_RD(x) |  (v)))
#define HW_ADC_SC3_CLR(x, v)     (HW_ADC_SC3_WR(x, HW_ADC_SC3_RD(x) & ~(v)))
#define HW_ADC_SC3_TOG(x, v)     (HW_ADC_SC3_WR(x, HW_ADC_SC3_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual ADC_SC3 bitfields
 */

/*!
 * @name Register ADC_SC3, field AVGS[1:0] (RW)
 *
 * AVGS determines how many ADC conversions will be averaged to create the ADC
 * average result.
 *
 * Values:
 * - 00 - 4 samples averaged.
 * - 01 - 8 samples averaged.
 * - 10 - 16 samples averaged.
 * - 11 - 32 samples averaged.
 */
/*@{*/
#define BP_ADC_SC3_AVGS      (0U)          /*!< Bit position for ADC_SC3_AVGS. */
#define BM_ADC_SC3_AVGS      (0x00000003U) /*!< Bit mask for ADC_SC3_AVGS. */
#define BS_ADC_SC3_AVGS      (2U)          /*!< Bit field size in bits for ADC_SC3_AVGS. */

/*! @brief Read current value of the ADC_SC3_AVGS field. */
#define BR_ADC_SC3_AVGS(x)   (HW_ADC_SC3(x).B.AVGS)

/*! @brief Format value for bitfield ADC_SC3_AVGS. */
#define BF_ADC_SC3_AVGS(v)   ((uint32_t)((uint32_t)(v) << BP_ADC_SC3_AVGS) & BM_ADC_SC3_AVGS)

/*! @brief Set the AVGS field to a new value. */
#define BW_ADC_SC3_AVGS(x, v) (HW_ADC_SC3_WR(x, (HW_ADC_SC3_RD(x) & ~BM_ADC_SC3_AVGS) | BF_ADC_SC3_AVGS(v)))
/*@}*/

/*!
 * @name Register ADC_SC3, field AVGE[2] (RW)
 *
 * AVGE enables the hardware average function of the ADC.
 *
 * Values:
 * - 0 - Hardware average function disabled.
 * - 1 - Hardware average function enabled.
 */
/*@{*/
#define BP_ADC_SC3_AVGE      (2U)          /*!< Bit position for ADC_SC3_AVGE. */
#define BM_ADC_SC3_AVGE      (0x00000004U) /*!< Bit mask for ADC_SC3_AVGE. */
#define BS_ADC_SC3_AVGE      (1U)          /*!< Bit field size in bits for ADC_SC3_AVGE. */

/*! @brief Read current value of the ADC_SC3_AVGE field. */
#define BR_ADC_SC3_AVGE(x)   (BITBAND_ACCESS32(HW_ADC_SC3_ADDR(x), BP_ADC_SC3_AVGE))

/*! @brief Format value for bitfield ADC_SC3_AVGE. */
#define BF_ADC_SC3_AVGE(v)   ((uint32_t)((uint32_t)(v) << BP_ADC_SC3_AVGE) & BM_ADC_SC3_AVGE)

/*! @brief Set the AVGE field to a new value. */
#define BW_ADC_SC3_AVGE(x, v) (BITBAND_ACCESS32(HW_ADC_SC3_ADDR(x), BP_ADC_SC3_AVGE) = (v))
/*@}*/

/*!
 * @name Register ADC_SC3, field ADCO[3] (RW)
 *
 * ADCO enables continuous conversions.
 *
 * Values:
 * - 0 - One conversion or one set of conversions if the hardware average
 *     function is enabled (AVGE=1) after initiating a conversion.
 * - 1 - Continuous conversions or sets of conversions if the hardware average
 *     function is enabled (AVGE=1) after initiating a conversion.
 */
/*@{*/
#define BP_ADC_SC3_ADCO      (3U)          /*!< Bit position for ADC_SC3_ADCO. */
#define BM_ADC_SC3_ADCO      (0x00000008U) /*!< Bit mask for ADC_SC3_ADCO. */
#define BS_ADC_SC3_ADCO      (1U)          /*!< Bit field size in bits for ADC_SC3_ADCO. */

/*! @brief Read current value of the ADC_SC3_ADCO field. */
#define BR_ADC_SC3_ADCO(x)   (BITBAND_ACCESS32(HW_ADC_SC3_ADDR(x), BP_ADC_SC3_ADCO))

/*! @brief Format value for bitfield ADC_SC3_ADCO. */
#define BF_ADC_SC3_ADCO(v)   ((uint32_t)((uint32_t)(v) << BP_ADC_SC3_ADCO) & BM_ADC_SC3_ADCO)

/*! @brief Set the ADCO field to a new value. */
#define BW_ADC_SC3_ADCO(x, v) (BITBAND_ACCESS32(HW_ADC_SC3_ADDR(x), BP_ADC_SC3_ADCO) = (v))
/*@}*/

/*!
 * @name Register ADC_SC3, field CALF[6] (RO)
 *
 * CALF displays the result of the calibration sequence. The calibration
 * sequence will fail if ADTRG = 1, any ADC register is written, or any stop mode is
 * entered before the calibration sequence completes. The CALF bit is cleared by
 * writing a 1 to this bit.
 *
 * Values:
 * - 0 - Calibration completed normally.
 * - 1 - Calibration failed. ADC accuracy specifications are not guaranteed.
 */
/*@{*/
#define BP_ADC_SC3_CALF      (6U)          /*!< Bit position for ADC_SC3_CALF. */
#define BM_ADC_SC3_CALF      (0x00000040U) /*!< Bit mask for ADC_SC3_CALF. */
#define BS_ADC_SC3_CALF      (1U)          /*!< Bit field size in bits for ADC_SC3_CALF. */

/*! @brief Read current value of the ADC_SC3_CALF field. */
#define BR_ADC_SC3_CALF(x)   (BITBAND_ACCESS32(HW_ADC_SC3_ADDR(x), BP_ADC_SC3_CALF))
/*@}*/

/*!
 * @name Register ADC_SC3, field CAL[7] (RW)
 *
 * CAL begins the calibration sequence when set. This bit stays set while the
 * calibration is in progress and is cleared when the calibration sequence is
 * completed. The CALF bit must be checked to determine the result of the calibration
 * sequence. Once started, the calibration routine cannot be interrupted by
 * writes to the ADC registers or the results will be invalid and the CALF bit will
 * set. Setting the CAL bit will abort any current conversion.
 */
/*@{*/
#define BP_ADC_SC3_CAL       (7U)          /*!< Bit position for ADC_SC3_CAL. */
#define BM_ADC_SC3_CAL       (0x00000080U) /*!< Bit mask for ADC_SC3_CAL. */
#define BS_ADC_SC3_CAL       (1U)          /*!< Bit field size in bits for ADC_SC3_CAL. */

/*! @brief Read current value of the ADC_SC3_CAL field. */
#define BR_ADC_SC3_CAL(x)    (BITBAND_ACCESS32(HW_ADC_SC3_ADDR(x), BP_ADC_SC3_CAL))

/*! @brief Format value for bitfield ADC_SC3_CAL. */
#define BF_ADC_SC3_CAL(v)    ((uint32_t)((uint32_t)(v) << BP_ADC_SC3_CAL) & BM_ADC_SC3_CAL)

/*! @brief Set the CAL field to a new value. */
#define BW_ADC_SC3_CAL(x, v) (BITBAND_ACCESS32(HW_ADC_SC3_ADDR(x), BP_ADC_SC3_CAL) = (v))
/*@}*/

/*******************************************************************************
 * HW_ADC_OFS - ADC offset correction register
 ******************************************************************************/

/*!
 * @brief HW_ADC_OFS - ADC offset correction register (RW)
 *
 * Reset value: 0x00000004U
 *
 * The ADC offset correction register (OFS) contains the user selected or
 * calibration generated offset error correction value. This register is a 2's
 * complement, left justified, 16-bit value. The value in the offset correction registers
 * (OFS) is subtracted from the conversion and the result is transferred into
 * the result registers (Rn). If the result is above the maximum or below the
 * minimum result value, it is forced to the appropriate limit for the current mode of
 * operation.
 */
typedef union _hw_adc_ofs
{
    uint32_t U;
    struct _hw_adc_ofs_bitfields
    {
        uint32_t OFS : 16;             /*!< [15:0] Offset error correction value */
        uint32_t RESERVED0 : 16;       /*!< [31:16]  */
    } B;
} hw_adc_ofs_t;

/*!
 * @name Constants and macros for entire ADC_OFS register
 */
/*@{*/
#define HW_ADC_OFS_ADDR(x)       ((x) + 0x28U)

#define HW_ADC_OFS(x)            (*(__IO hw_adc_ofs_t *) HW_ADC_OFS_ADDR(x))
#define HW_ADC_OFS_RD(x)         (HW_ADC_OFS(x).U)
#define HW_ADC_OFS_WR(x, v)      (HW_ADC_OFS(x).U = (v))
#define HW_ADC_OFS_SET(x, v)     (HW_ADC_OFS_WR(x, HW_ADC_OFS_RD(x) |  (v)))
#define HW_ADC_OFS_CLR(x, v)     (HW_ADC_OFS_WR(x, HW_ADC_OFS_RD(x) & ~(v)))
#define HW_ADC_OFS_TOG(x, v)     (HW_ADC_OFS_WR(x, HW_ADC_OFS_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual ADC_OFS bitfields
 */

/*!
 * @name Register ADC_OFS, field OFS[15:0] (RW)
 */
/*@{*/
#define BP_ADC_OFS_OFS       (0U)          /*!< Bit position for ADC_OFS_OFS. */
#define BM_ADC_OFS_OFS       (0x0000FFFFU) /*!< Bit mask for ADC_OFS_OFS. */
#define BS_ADC_OFS_OFS       (16U)         /*!< Bit field size in bits for ADC_OFS_OFS. */

/*! @brief Read current value of the ADC_OFS_OFS field. */
#define BR_ADC_OFS_OFS(x)    (HW_ADC_OFS(x).B.OFS)

/*! @brief Format value for bitfield ADC_OFS_OFS. */
#define BF_ADC_OFS_OFS(v)    ((uint32_t)((uint32_t)(v) << BP_ADC_OFS_OFS) & BM_ADC_OFS_OFS)

/*! @brief Set the OFS field to a new value. */
#define BW_ADC_OFS_OFS(x, v) (HW_ADC_OFS_WR(x, (HW_ADC_OFS_RD(x) & ~BM_ADC_OFS_OFS) | BF_ADC_OFS_OFS(v)))
/*@}*/

/*******************************************************************************
 * HW_ADC_PG - ADC plus-side gain register
 ******************************************************************************/

/*!
 * @brief HW_ADC_PG - ADC plus-side gain register (RW)
 *
 * Reset value: 0x00008200U
 *
 * The plus-side gain register (PG) contains the gain error correction for the
 * overall conversion in single-ended mode. PG, a 16-bit real number in binary
 * format, is the gain adjustment factor, with the radix point fixed between ADPG15
 * and ADPG14. This register must be written by the user with the value described
 * in the calibration procedure or the gain error specifications may not be met.
 */
typedef union _hw_adc_pg
{
    uint32_t U;
    struct _hw_adc_pg_bitfields
    {
        uint32_t PG : 16;              /*!< [15:0] Plus-side gain */
        uint32_t RESERVED0 : 16;       /*!< [31:16]  */
    } B;
} hw_adc_pg_t;

/*!
 * @name Constants and macros for entire ADC_PG register
 */
/*@{*/
#define HW_ADC_PG_ADDR(x)        ((x) + 0x2CU)

#define HW_ADC_PG(x)             (*(__IO hw_adc_pg_t *) HW_ADC_PG_ADDR(x))
#define HW_ADC_PG_RD(x)          (HW_ADC_PG(x).U)
#define HW_ADC_PG_WR(x, v)       (HW_ADC_PG(x).U = (v))
#define HW_ADC_PG_SET(x, v)      (HW_ADC_PG_WR(x, HW_ADC_PG_RD(x) |  (v)))
#define HW_ADC_PG_CLR(x, v)      (HW_ADC_PG_WR(x, HW_ADC_PG_RD(x) & ~(v)))
#define HW_ADC_PG_TOG(x, v)      (HW_ADC_PG_WR(x, HW_ADC_PG_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual ADC_PG bitfields
 */

/*!
 * @name Register ADC_PG, field PG[15:0] (RW)
 */
/*@{*/
#define BP_ADC_PG_PG         (0U)          /*!< Bit position for ADC_PG_PG. */
#define BM_ADC_PG_PG         (0x0000FFFFU) /*!< Bit mask for ADC_PG_PG. */
#define BS_ADC_PG_PG         (16U)         /*!< Bit field size in bits for ADC_PG_PG. */

/*! @brief Read current value of the ADC_PG_PG field. */
#define BR_ADC_PG_PG(x)      (HW_ADC_PG(x).B.PG)

/*! @brief Format value for bitfield ADC_PG_PG. */
#define BF_ADC_PG_PG(v)      ((uint32_t)((uint32_t)(v) << BP_ADC_PG_PG) & BM_ADC_PG_PG)

/*! @brief Set the PG field to a new value. */
#define BW_ADC_PG_PG(x, v)   (HW_ADC_PG_WR(x, (HW_ADC_PG_RD(x) & ~BM_ADC_PG_PG) | BF_ADC_PG_PG(v)))
/*@}*/

/*******************************************************************************
 * HW_ADC_CLPD - ADC plus-side general calibration value register
 ******************************************************************************/

/*!
 * @brief HW_ADC_CLPD - ADC plus-side general calibration value register (RW)
 *
 * Reset value: 0x0000000AU
 *
 * The plus-side general calibration value registers (CLPx) contain calibration
 * information that is generated by the calibration function. These registers
 * contain seven calibration values of varying widths: CLP0[5:0], CLP1[6:0],
 * CLP2[7:0], CLP3[8:0], CLP4[9:0], CLPS[5:0], and CLPD[5:0]. CLPx are automatically set
 * once the self calibration sequence is done (CAL is cleared). If these
 * registers are written by the user after calibration, the linearity error
 * specifications may not be met.
 */
typedef union _hw_adc_clpd
{
    uint32_t U;
    struct _hw_adc_clpd_bitfields
    {
        uint32_t CLPD : 6;             /*!< [5:0]  */
        uint32_t RESERVED0 : 26;       /*!< [31:6]  */
    } B;
} hw_adc_clpd_t;

/*!
 * @name Constants and macros for entire ADC_CLPD register
 */
/*@{*/
#define HW_ADC_CLPD_ADDR(x)      ((x) + 0x34U)

#define HW_ADC_CLPD(x)           (*(__IO hw_adc_clpd_t *) HW_ADC_CLPD_ADDR(x))
#define HW_ADC_CLPD_RD(x)        (HW_ADC_CLPD(x).U)
#define HW_ADC_CLPD_WR(x, v)     (HW_ADC_CLPD(x).U = (v))
#define HW_ADC_CLPD_SET(x, v)    (HW_ADC_CLPD_WR(x, HW_ADC_CLPD_RD(x) |  (v)))
#define HW_ADC_CLPD_CLR(x, v)    (HW_ADC_CLPD_WR(x, HW_ADC_CLPD_RD(x) & ~(v)))
#define HW_ADC_CLPD_TOG(x, v)    (HW_ADC_CLPD_WR(x, HW_ADC_CLPD_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLPD bitfields
 */

/*!
 * @name Register ADC_CLPD, field CLPD[5:0] (RW)
 *
 * Calibration value
 */
/*@{*/
#define BP_ADC_CLPD_CLPD     (0U)          /*!< Bit position for ADC_CLPD_CLPD. */
#define BM_ADC_CLPD_CLPD     (0x0000003FU) /*!< Bit mask for ADC_CLPD_CLPD. */
#define BS_ADC_CLPD_CLPD     (6U)          /*!< Bit field size in bits for ADC_CLPD_CLPD. */

/*! @brief Read current value of the ADC_CLPD_CLPD field. */
#define BR_ADC_CLPD_CLPD(x)  (HW_ADC_CLPD(x).B.CLPD)

/*! @brief Format value for bitfield ADC_CLPD_CLPD. */
#define BF_ADC_CLPD_CLPD(v)  ((uint32_t)((uint32_t)(v) << BP_ADC_CLPD_CLPD) & BM_ADC_CLPD_CLPD)

/*! @brief Set the CLPD field to a new value. */
#define BW_ADC_CLPD_CLPD(x, v) (HW_ADC_CLPD_WR(x, (HW_ADC_CLPD_RD(x) & ~BM_ADC_CLPD_CLPD) | BF_ADC_CLPD_CLPD(v)))
/*@}*/

/*******************************************************************************
 * HW_ADC_CLPS - ADC plus-side general calibration value register
 ******************************************************************************/

/*!
 * @brief HW_ADC_CLPS - ADC plus-side general calibration value register (RW)
 *
 * Reset value: 0x00000020U
 *
 * For more information, refer to CLPD register description.
 */
typedef union _hw_adc_clps
{
    uint32_t U;
    struct _hw_adc_clps_bitfields
    {
        uint32_t CLPS : 6;             /*!< [5:0]  */
        uint32_t RESERVED0 : 26;       /*!< [31:6]  */
    } B;
} hw_adc_clps_t;

/*!
 * @name Constants and macros for entire ADC_CLPS register
 */
/*@{*/
#define HW_ADC_CLPS_ADDR(x)      ((x) + 0x38U)

#define HW_ADC_CLPS(x)           (*(__IO hw_adc_clps_t *) HW_ADC_CLPS_ADDR(x))
#define HW_ADC_CLPS_RD(x)        (HW_ADC_CLPS(x).U)
#define HW_ADC_CLPS_WR(x, v)     (HW_ADC_CLPS(x).U = (v))
#define HW_ADC_CLPS_SET(x, v)    (HW_ADC_CLPS_WR(x, HW_ADC_CLPS_RD(x) |  (v)))
#define HW_ADC_CLPS_CLR(x, v)    (HW_ADC_CLPS_WR(x, HW_ADC_CLPS_RD(x) & ~(v)))
#define HW_ADC_CLPS_TOG(x, v)    (HW_ADC_CLPS_WR(x, HW_ADC_CLPS_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLPS bitfields
 */

/*!
 * @name Register ADC_CLPS, field CLPS[5:0] (RW)
 *
 * Calibration value
 */
/*@{*/
#define BP_ADC_CLPS_CLPS     (0U)          /*!< Bit position for ADC_CLPS_CLPS. */
#define BM_ADC_CLPS_CLPS     (0x0000003FU) /*!< Bit mask for ADC_CLPS_CLPS. */
#define BS_ADC_CLPS_CLPS     (6U)          /*!< Bit field size in bits for ADC_CLPS_CLPS. */

/*! @brief Read current value of the ADC_CLPS_CLPS field. */
#define BR_ADC_CLPS_CLPS(x)  (HW_ADC_CLPS(x).B.CLPS)

/*! @brief Format value for bitfield ADC_CLPS_CLPS. */
#define BF_ADC_CLPS_CLPS(v)  ((uint32_t)((uint32_t)(v) << BP_ADC_CLPS_CLPS) & BM_ADC_CLPS_CLPS)

/*! @brief Set the CLPS field to a new value. */
#define BW_ADC_CLPS_CLPS(x, v) (HW_ADC_CLPS_WR(x, (HW_ADC_CLPS_RD(x) & ~BM_ADC_CLPS_CLPS) | BF_ADC_CLPS_CLPS(v)))
/*@}*/

/*******************************************************************************
 * HW_ADC_CLP4 - ADC plus-side general calibration value register
 ******************************************************************************/

/*!
 * @brief HW_ADC_CLP4 - ADC plus-side general calibration value register (RW)
 *
 * Reset value: 0x00000200U
 *
 * For more information, refer to CLPD register description.
 */
typedef union _hw_adc_clp4
{
    uint32_t U;
    struct _hw_adc_clp4_bitfields
    {
        uint32_t CLP4 : 10;            /*!< [9:0]  */
        uint32_t RESERVED0 : 22;       /*!< [31:10]  */
    } B;
} hw_adc_clp4_t;

/*!
 * @name Constants and macros for entire ADC_CLP4 register
 */
/*@{*/
#define HW_ADC_CLP4_ADDR(x)      ((x) + 0x3CU)

#define HW_ADC_CLP4(x)           (*(__IO hw_adc_clp4_t *) HW_ADC_CLP4_ADDR(x))
#define HW_ADC_CLP4_RD(x)        (HW_ADC_CLP4(x).U)
#define HW_ADC_CLP4_WR(x, v)     (HW_ADC_CLP4(x).U = (v))
#define HW_ADC_CLP4_SET(x, v)    (HW_ADC_CLP4_WR(x, HW_ADC_CLP4_RD(x) |  (v)))
#define HW_ADC_CLP4_CLR(x, v)    (HW_ADC_CLP4_WR(x, HW_ADC_CLP4_RD(x) & ~(v)))
#define HW_ADC_CLP4_TOG(x, v)    (HW_ADC_CLP4_WR(x, HW_ADC_CLP4_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLP4 bitfields
 */

/*!
 * @name Register ADC_CLP4, field CLP4[9:0] (RW)
 *
 * Calibration value
 */
/*@{*/
#define BP_ADC_CLP4_CLP4     (0U)          /*!< Bit position for ADC_CLP4_CLP4. */
#define BM_ADC_CLP4_CLP4     (0x000003FFU) /*!< Bit mask for ADC_CLP4_CLP4. */
#define BS_ADC_CLP4_CLP4     (10U)         /*!< Bit field size in bits for ADC_CLP4_CLP4. */

/*! @brief Read current value of the ADC_CLP4_CLP4 field. */
#define BR_ADC_CLP4_CLP4(x)  (HW_ADC_CLP4(x).B.CLP4)

/*! @brief Format value for bitfield ADC_CLP4_CLP4. */
#define BF_ADC_CLP4_CLP4(v)  ((uint32_t)((uint32_t)(v) << BP_ADC_CLP4_CLP4) & BM_ADC_CLP4_CLP4)

/*! @brief Set the CLP4 field to a new value. */
#define BW_ADC_CLP4_CLP4(x, v) (HW_ADC_CLP4_WR(x, (HW_ADC_CLP4_RD(x) & ~BM_ADC_CLP4_CLP4) | BF_ADC_CLP4_CLP4(v)))
/*@}*/

/*******************************************************************************
 * HW_ADC_CLP3 - ADC plus-side general calibration value register
 ******************************************************************************/

/*!
 * @brief HW_ADC_CLP3 - ADC plus-side general calibration value register (RW)
 *
 * Reset value: 0x00000100U
 *
 * For more information, refer to CLPD register description.
 */
typedef union _hw_adc_clp3
{
    uint32_t U;
    struct _hw_adc_clp3_bitfields
    {
        uint32_t CLP3 : 9;             /*!< [8:0]  */
        uint32_t RESERVED0 : 23;       /*!< [31:9]  */
    } B;
} hw_adc_clp3_t;

/*!
 * @name Constants and macros for entire ADC_CLP3 register
 */
/*@{*/
#define HW_ADC_CLP3_ADDR(x)      ((x) + 0x40U)

#define HW_ADC_CLP3(x)           (*(__IO hw_adc_clp3_t *) HW_ADC_CLP3_ADDR(x))
#define HW_ADC_CLP3_RD(x)        (HW_ADC_CLP3(x).U)
#define HW_ADC_CLP3_WR(x, v)     (HW_ADC_CLP3(x).U = (v))
#define HW_ADC_CLP3_SET(x, v)    (HW_ADC_CLP3_WR(x, HW_ADC_CLP3_RD(x) |  (v)))
#define HW_ADC_CLP3_CLR(x, v)    (HW_ADC_CLP3_WR(x, HW_ADC_CLP3_RD(x) & ~(v)))
#define HW_ADC_CLP3_TOG(x, v)    (HW_ADC_CLP3_WR(x, HW_ADC_CLP3_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLP3 bitfields
 */

/*!
 * @name Register ADC_CLP3, field CLP3[8:0] (RW)
 *
 * Calibration value
 */
/*@{*/
#define BP_ADC_CLP3_CLP3     (0U)          /*!< Bit position for ADC_CLP3_CLP3. */
#define BM_ADC_CLP3_CLP3     (0x000001FFU) /*!< Bit mask for ADC_CLP3_CLP3. */
#define BS_ADC_CLP3_CLP3     (9U)          /*!< Bit field size in bits for ADC_CLP3_CLP3. */

/*! @brief Read current value of the ADC_CLP3_CLP3 field. */
#define BR_ADC_CLP3_CLP3(x)  (HW_ADC_CLP3(x).B.CLP3)

/*! @brief Format value for bitfield ADC_CLP3_CLP3. */
#define BF_ADC_CLP3_CLP3(v)  ((uint32_t)((uint32_t)(v) << BP_ADC_CLP3_CLP3) & BM_ADC_CLP3_CLP3)

/*! @brief Set the CLP3 field to a new value. */
#define BW_ADC_CLP3_CLP3(x, v) (HW_ADC_CLP3_WR(x, (HW_ADC_CLP3_RD(x) & ~BM_ADC_CLP3_CLP3) | BF_ADC_CLP3_CLP3(v)))
/*@}*/

/*******************************************************************************
 * HW_ADC_CLP2 - ADC plus-side general calibration value register
 ******************************************************************************/

/*!
 * @brief HW_ADC_CLP2 - ADC plus-side general calibration value register (RW)
 *
 * Reset value: 0x00000080U
 *
 * For more information, refer to CLPD register description.
 */
typedef union _hw_adc_clp2
{
    uint32_t U;
    struct _hw_adc_clp2_bitfields
    {
        uint32_t CLP2 : 8;             /*!< [7:0]  */
        uint32_t RESERVED0 : 24;       /*!< [31:8]  */
    } B;
} hw_adc_clp2_t;

/*!
 * @name Constants and macros for entire ADC_CLP2 register
 */
/*@{*/
#define HW_ADC_CLP2_ADDR(x)      ((x) + 0x44U)

#define HW_ADC_CLP2(x)           (*(__IO hw_adc_clp2_t *) HW_ADC_CLP2_ADDR(x))
#define HW_ADC_CLP2_RD(x)        (HW_ADC_CLP2(x).U)
#define HW_ADC_CLP2_WR(x, v)     (HW_ADC_CLP2(x).U = (v))
#define HW_ADC_CLP2_SET(x, v)    (HW_ADC_CLP2_WR(x, HW_ADC_CLP2_RD(x) |  (v)))
#define HW_ADC_CLP2_CLR(x, v)    (HW_ADC_CLP2_WR(x, HW_ADC_CLP2_RD(x) & ~(v)))
#define HW_ADC_CLP2_TOG(x, v)    (HW_ADC_CLP2_WR(x, HW_ADC_CLP2_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLP2 bitfields
 */

/*!
 * @name Register ADC_CLP2, field CLP2[7:0] (RW)
 *
 * Calibration value
 */
/*@{*/
#define BP_ADC_CLP2_CLP2     (0U)          /*!< Bit position for ADC_CLP2_CLP2. */
#define BM_ADC_CLP2_CLP2     (0x000000FFU) /*!< Bit mask for ADC_CLP2_CLP2. */
#define BS_ADC_CLP2_CLP2     (8U)          /*!< Bit field size in bits for ADC_CLP2_CLP2. */

/*! @brief Read current value of the ADC_CLP2_CLP2 field. */
#define BR_ADC_CLP2_CLP2(x)  (HW_ADC_CLP2(x).B.CLP2)

/*! @brief Format value for bitfield ADC_CLP2_CLP2. */
#define BF_ADC_CLP2_CLP2(v)  ((uint32_t)((uint32_t)(v) << BP_ADC_CLP2_CLP2) & BM_ADC_CLP2_CLP2)

/*! @brief Set the CLP2 field to a new value. */
#define BW_ADC_CLP2_CLP2(x, v) (HW_ADC_CLP2_WR(x, (HW_ADC_CLP2_RD(x) & ~BM_ADC_CLP2_CLP2) | BF_ADC_CLP2_CLP2(v)))
/*@}*/

/*******************************************************************************
 * HW_ADC_CLP1 - ADC plus-side general calibration value register
 ******************************************************************************/

/*!
 * @brief HW_ADC_CLP1 - ADC plus-side general calibration value register (RW)
 *
 * Reset value: 0x00000040U
 *
 * For more information, refer to CLPD register description.
 */
typedef union _hw_adc_clp1
{
    uint32_t U;
    struct _hw_adc_clp1_bitfields
    {
        uint32_t CLP1 : 7;             /*!< [6:0]  */
        uint32_t RESERVED0 : 25;       /*!< [31:7]  */
    } B;
} hw_adc_clp1_t;

/*!
 * @name Constants and macros for entire ADC_CLP1 register
 */
/*@{*/
#define HW_ADC_CLP1_ADDR(x)      ((x) + 0x48U)

#define HW_ADC_CLP1(x)           (*(__IO hw_adc_clp1_t *) HW_ADC_CLP1_ADDR(x))
#define HW_ADC_CLP1_RD(x)        (HW_ADC_CLP1(x).U)
#define HW_ADC_CLP1_WR(x, v)     (HW_ADC_CLP1(x).U = (v))
#define HW_ADC_CLP1_SET(x, v)    (HW_ADC_CLP1_WR(x, HW_ADC_CLP1_RD(x) |  (v)))
#define HW_ADC_CLP1_CLR(x, v)    (HW_ADC_CLP1_WR(x, HW_ADC_CLP1_RD(x) & ~(v)))
#define HW_ADC_CLP1_TOG(x, v)    (HW_ADC_CLP1_WR(x, HW_ADC_CLP1_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLP1 bitfields
 */

/*!
 * @name Register ADC_CLP1, field CLP1[6:0] (RW)
 *
 * Calibration value
 */
/*@{*/
#define BP_ADC_CLP1_CLP1     (0U)          /*!< Bit position for ADC_CLP1_CLP1. */
#define BM_ADC_CLP1_CLP1     (0x0000007FU) /*!< Bit mask for ADC_CLP1_CLP1. */
#define BS_ADC_CLP1_CLP1     (7U)          /*!< Bit field size in bits for ADC_CLP1_CLP1. */

/*! @brief Read current value of the ADC_CLP1_CLP1 field. */
#define BR_ADC_CLP1_CLP1(x)  (HW_ADC_CLP1(x).B.CLP1)

/*! @brief Format value for bitfield ADC_CLP1_CLP1. */
#define BF_ADC_CLP1_CLP1(v)  ((uint32_t)((uint32_t)(v) << BP_ADC_CLP1_CLP1) & BM_ADC_CLP1_CLP1)

/*! @brief Set the CLP1 field to a new value. */
#define BW_ADC_CLP1_CLP1(x, v) (HW_ADC_CLP1_WR(x, (HW_ADC_CLP1_RD(x) & ~BM_ADC_CLP1_CLP1) | BF_ADC_CLP1_CLP1(v)))
/*@}*/

/*******************************************************************************
 * HW_ADC_CLP0 - ADC plus-side general calibration value register
 ******************************************************************************/

/*!
 * @brief HW_ADC_CLP0 - ADC plus-side general calibration value register (RW)
 *
 * Reset value: 0x00000020U
 *
 * For more information, refer to CLPD register description.
 */
typedef union _hw_adc_clp0
{
    uint32_t U;
    struct _hw_adc_clp0_bitfields
    {
        uint32_t CLP0 : 6;             /*!< [5:0]  */
        uint32_t RESERVED0 : 26;       /*!< [31:6]  */
    } B;
} hw_adc_clp0_t;

/*!
 * @name Constants and macros for entire ADC_CLP0 register
 */
/*@{*/
#define HW_ADC_CLP0_ADDR(x)      ((x) + 0x4CU)

#define HW_ADC_CLP0(x)           (*(__IO hw_adc_clp0_t *) HW_ADC_CLP0_ADDR(x))
#define HW_ADC_CLP0_RD(x)        (HW_ADC_CLP0(x).U)
#define HW_ADC_CLP0_WR(x, v)     (HW_ADC_CLP0(x).U = (v))
#define HW_ADC_CLP0_SET(x, v)    (HW_ADC_CLP0_WR(x, HW_ADC_CLP0_RD(x) |  (v)))
#define HW_ADC_CLP0_CLR(x, v)    (HW_ADC_CLP0_WR(x, HW_ADC_CLP0_RD(x) & ~(v)))
#define HW_ADC_CLP0_TOG(x, v)    (HW_ADC_CLP0_WR(x, HW_ADC_CLP0_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLP0 bitfields
 */

/*!
 * @name Register ADC_CLP0, field CLP0[5:0] (RW)
 *
 * Calibration value
 */
/*@{*/
#define BP_ADC_CLP0_CLP0     (0U)          /*!< Bit position for ADC_CLP0_CLP0. */
#define BM_ADC_CLP0_CLP0     (0x0000003FU) /*!< Bit mask for ADC_CLP0_CLP0. */
#define BS_ADC_CLP0_CLP0     (6U)          /*!< Bit field size in bits for ADC_CLP0_CLP0. */

/*! @brief Read current value of the ADC_CLP0_CLP0 field. */
#define BR_ADC_CLP0_CLP0(x)  (HW_ADC_CLP0(x).B.CLP0)

/*! @brief Format value for bitfield ADC_CLP0_CLP0. */
#define BF_ADC_CLP0_CLP0(v)  ((uint32_t)((uint32_t)(v) << BP_ADC_CLP0_CLP0) & BM_ADC_CLP0_CLP0)

/*! @brief Set the CLP0 field to a new value. */
#define BW_ADC_CLP0_CLP0(x, v) (HW_ADC_CLP0_WR(x, (HW_ADC_CLP0_RD(x) & ~BM_ADC_CLP0_CLP0) | BF_ADC_CLP0_CLP0(v)))
/*@}*/

/*******************************************************************************
 * hw_adc_t - module struct
 ******************************************************************************/
/*!
 * @brief All ADC module registers.
 */
#pragma pack(1)
typedef struct _hw_adc
{
    __IO hw_adc_sc1n_t SC1n[2];            /*!< [0x0] ADC status and control registers 1 */
    __IO hw_adc_cfg1_t CFG1;               /*!< [0x8] ADC configuration register 1 */
    __IO hw_adc_cfg2_t CFG2;               /*!< [0xC] Configuration register 2 */
    __I hw_adc_rn_t Rn[2];                 /*!< [0x10] ADC data result register */
    __IO hw_adc_cv1_t CV1;                 /*!< [0x18] Compare value registers */
    __IO hw_adc_cv2_t CV2;                 /*!< [0x1C] Compare value registers */
    __IO hw_adc_sc2_t SC2;                 /*!< [0x20] Status and control register 2 */
    __IO hw_adc_sc3_t SC3;                 /*!< [0x24] Status and control register 3 */
    __IO hw_adc_ofs_t OFS;                 /*!< [0x28] ADC offset correction register */
    __IO hw_adc_pg_t PG;                   /*!< [0x2C] ADC plus-side gain register */
    uint8_t _reserved0[4];
    __IO hw_adc_clpd_t CLPD;               /*!< [0x34] ADC plus-side general calibration value register */
    __IO hw_adc_clps_t CLPS;               /*!< [0x38] ADC plus-side general calibration value register */
    __IO hw_adc_clp4_t CLP4;               /*!< [0x3C] ADC plus-side general calibration value register */
    __IO hw_adc_clp3_t CLP3;               /*!< [0x40] ADC plus-side general calibration value register */
    __IO hw_adc_clp2_t CLP2;               /*!< [0x44] ADC plus-side general calibration value register */
    __IO hw_adc_clp1_t CLP1;               /*!< [0x48] ADC plus-side general calibration value register */
    __IO hw_adc_clp0_t CLP0;               /*!< [0x4C] ADC plus-side general calibration value register */
} hw_adc_t;
#pragma pack()

/*! @brief Macro to access all ADC registers. */
/*! @param x ADC module instance base address. */
/*! @return Reference (not a pointer) to the registers struct. To get a pointer to the struct,
 *     use the '&' operator, like <code>&HW_ADC(ADC0_BASE)</code>. */
#define HW_ADC(x)      (*(hw_adc_t *)(x))

#endif /* __HW_ADC_REGISTERS_H__ */
/* v33/140401/2.1.0 */
/* EOF */

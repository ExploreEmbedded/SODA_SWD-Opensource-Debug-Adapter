/*
 * Copyright (c) 2014, Freescale Semiconductor, Inc.
 * All rights reserved.
 *
 * THIS SOFTWARE IS PROVIDED BY FREESCALE "AS IS" AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
 * SHALL FREESCALE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
 * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
 * OF SUCH DAMAGE.
 */
/*
 * WARNING! DO NOT EDIT THIS FILE DIRECTLY!
 *
 * This file was generated automatically and any changes may be lost.
 */
#ifndef __HW_UART_REGISTERS_H__
#define __HW_UART_REGISTERS_H__

#include "MK20D5.h"
#include "fsl_bitband.h"

/*
 * MK20D5 UART
 *
 * Serial Communication Interface
 *
 * Registers defined in this header file:
 * - HW_UART_BDH - UART Baud Rate Registers:High
 * - HW_UART_BDL - UART Baud Rate Registers: Low
 * - HW_UART_C1 - UART Control Register 1
 * - HW_UART_C2 - UART Control Register 2
 * - HW_UART_S1 - UART Status Register 1
 * - HW_UART_S2 - UART Status Register 2
 * - HW_UART_C3 - UART Control Register 3
 * - HW_UART_D - UART Data Register
 * - HW_UART_MA1 - UART Match Address Registers 1
 * - HW_UART_MA2 - UART Match Address Registers 2
 * - HW_UART_C4 - UART Control Register 4
 * - HW_UART_C5 - UART Control Register 5
 * - HW_UART_ED - UART Extended Data Register
 * - HW_UART_MODEM - UART Modem Register
 * - HW_UART_IR - UART Infrared Register
 * - HW_UART_PFIFO - UART FIFO Parameters
 * - HW_UART_CFIFO - UART FIFO Control Register
 * - HW_UART_SFIFO - UART FIFO Status Register
 * - HW_UART_TWFIFO - UART FIFO Transmit Watermark
 * - HW_UART_TCFIFO - UART FIFO Transmit Count
 * - HW_UART_RWFIFO - UART FIFO Receive Watermark
 * - HW_UART_RCFIFO - UART FIFO Receive Count
 * - HW_UART_C7816 - UART 7816 Control Register
 * - HW_UART_IE7816 - UART 7816 Interrupt Enable Register
 * - HW_UART_IS7816 - UART 7816 Interrupt Status Register
 * - HW_UART_WP7816T0 - UART 7816 Wait Parameter Register
 * - HW_UART_WP7816T1 - UART 7816 Wait Parameter Register
 * - HW_UART_WN7816 - UART 7816 Wait N Register
 * - HW_UART_WF7816 - UART 7816 Wait FD Register
 * - HW_UART_ET7816 - UART 7816 Error Threshold Register
 * - HW_UART_TL7816 - UART 7816 Transmit Length Register
 * - HW_UART_C6 - UART CEA709.1-B Control Register 6
 * - HW_UART_PCTH - UART CEA709.1-B Packet Cycle Time Counter High
 * - HW_UART_PCTL - UART CEA709.1-B Packet Cycle Time Counter Low
 * - HW_UART_B1T - UART CEA709.1-B Beta1 Timer
 * - HW_UART_SDTH - UART CEA709.1-B Secondary Delay Timer High
 * - HW_UART_SDTL - UART CEA709.1-B Secondary Delay Timer Low
 * - HW_UART_PRE - UART CEA709.1-B Preamble
 * - HW_UART_TPL - UART CEA709.1-B Transmit Packet Length
 * - HW_UART_IE - UART CEA709.1-B Interrupt Enable Register
 * - HW_UART_WB - UART CEA709.1-B WBASE
 * - HW_UART_S3 - UART CEA709.1-B Status Register
 * - HW_UART_S4 - UART CEA709.1-B Status Register
 * - HW_UART_RPL - UART CEA709.1-B Received Packet Length
 * - HW_UART_RPREL - UART CEA709.1-B Received Preamble Length
 * - HW_UART_CPW - UART CEA709.1-B Collision Pulse Width
 * - HW_UART_RIDT - UART CEA709.1-B Receive Indeterminate Time
 * - HW_UART_TIDT - UART CEA709.1-B Transmit Indeterminate Time
 *
 * - hw_uart_t - Struct containing all module registers.
 */

#define HW_UART_INSTANCE_COUNT (3U) /*!< Number of instances of the UART module. */
#define HW_UART0 (0U) /*!< Instance number for UART0. */
#define HW_UART1 (1U) /*!< Instance number for UART1. */
#define HW_UART2 (2U) /*!< Instance number for UART2. */

/*******************************************************************************
 * HW_UART_BDH - UART Baud Rate Registers:High
 ******************************************************************************/

/*!
 * @brief HW_UART_BDH - UART Baud Rate Registers:High (RW)
 *
 * Reset value: 0x00U
 *
 * This register, along with the BDL register, controls the prescale divisor for
 * UART baud rate generation. To update the 13-bit baud rate setting
 * (SBR[12:0]), first write to BDH to buffer the high half of the new value and then write
 * to BDL. The working value in BDH does not change until BDL is written. BDL is
 * reset to a non-zero value, but after reset the baud rate generator remains
 * disabled until the first time the receiver or transmitter is enabled (C2[RE] or
 * C2[TE] bits are set).
 */
typedef union _hw_uart_bdh
{
    uint8_t U;
    struct _hw_uart_bdh_bitfields
    {
        uint8_t SBR : 5;               /*!< [4:0] UART Baud Rate Bits */
        uint8_t RESERVED0 : 1;         /*!< [5]  */
        uint8_t RXEDGIE : 1;           /*!< [6] RxD Input Active Edge Interrupt Enable
                                        * */
        uint8_t LBKDIE : 1;            /*!< [7] LIN Break Detect Interrupt Enable */
    } B;
} hw_uart_bdh_t;

/*!
 * @name Constants and macros for entire UART_BDH register
 */
/*@{*/
#define HW_UART_BDH_ADDR(x)      ((x) + 0x0U)

#define HW_UART_BDH(x)           (*(__IO hw_uart_bdh_t *) HW_UART_BDH_ADDR(x))
#define HW_UART_BDH_RD(x)        (HW_UART_BDH(x).U)
#define HW_UART_BDH_WR(x, v)     (HW_UART_BDH(x).U = (v))
#define HW_UART_BDH_SET(x, v)    (HW_UART_BDH_WR(x, HW_UART_BDH_RD(x) |  (v)))
#define HW_UART_BDH_CLR(x, v)    (HW_UART_BDH_WR(x, HW_UART_BDH_RD(x) & ~(v)))
#define HW_UART_BDH_TOG(x, v)    (HW_UART_BDH_WR(x, HW_UART_BDH_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual UART_BDH bitfields
 */

/*!
 * @name Register UART_BDH, field SBR[4:0] (RW)
 *
 * The baud rate for the UART is determined by these 13 bits. See Baud rate
 * generation for details. The baud rate generator is disabled until the C2[TE] bit
 * or the C2[RE] bit is set for the first time after reset.The baud rate generator
 * is disabled when SBR = 0. Writing to BDH has no effect without writing to
 * BDL, since writing to BDH puts the data in a temporary location until BDL is
 * written.
 */
/*@{*/
#define BP_UART_BDH_SBR      (0U)          /*!< Bit position for UART_BDH_SBR. */
#define BM_UART_BDH_SBR      (0x1FU)       /*!< Bit mask for UART_BDH_SBR. */
#define BS_UART_BDH_SBR      (5U)          /*!< Bit field size in bits for UART_BDH_SBR. */

/*! @brief Read current value of the UART_BDH_SBR field. */
#define BR_UART_BDH_SBR(x)   (HW_UART_BDH(x).B.SBR)

/*! @brief Format value for bitfield UART_BDH_SBR. */
#define BF_UART_BDH_SBR(v)   ((uint8_t)((uint8_t)(v) << BP_UART_BDH_SBR) & BM_UART_BDH_SBR)

/*! @brief Set the SBR field to a new value. */
#define BW_UART_BDH_SBR(x, v) (HW_UART_BDH_WR(x, (HW_UART_BDH_RD(x) & ~BM_UART_BDH_SBR) | BF_UART_BDH_SBR(v)))
/*@}*/

/*!
 * @name Register UART_BDH, field RXEDGIE[6] (RW)
 *
 * RXEDGIE enables the Receive input active edge, RXEDGIF, to generate interrupt
 * requests.
 *
 * Values:
 * - 0 - Hardware interrupts from RXEDGIF disabled (use polling).
 * - 1 - RXEDGIF interrupt request enabled.
 */
/*@{*/
#define BP_UART_BDH_RXEDGIE  (6U)          /*!< Bit position for UART_BDH_RXEDGIE. */
#define BM_UART_BDH_RXEDGIE  (0x40U)       /*!< Bit mask for UART_BDH_RXEDGIE. */
#define BS_UART_BDH_RXEDGIE  (1U)          /*!< Bit field size in bits for UART_BDH_RXEDGIE. */

/*! @brief Read current value of the UART_BDH_RXEDGIE field. */
#define BR_UART_BDH_RXEDGIE(x) (BITBAND_ACCESS8(HW_UART_BDH_ADDR(x), BP_UART_BDH_RXEDGIE))

/*! @brief Format value for bitfield UART_BDH_RXEDGIE. */
#define BF_UART_BDH_RXEDGIE(v) ((uint8_t)((uint8_t)(v) << BP_UART_BDH_RXEDGIE) & BM_UART_BDH_RXEDGIE)

/*! @brief Set the RXEDGIE field to a new value. */
#define BW_UART_BDH_RXEDGIE(x, v) (BITBAND_ACCESS8(HW_UART_BDH_ADDR(x), BP_UART_BDH_RXEDGIE) = (v))
/*@}*/

/*!
 * @name Register UART_BDH, field LBKDIE[7] (RW)
 *
 * LBKDIE enables the LIN break detect flag, LBKDIF, to generate interrupt
 * requests based on the state of LBKDDMAS.
 *
 * Values:
 * - 0 - LBKDIF interrupt requests disabled.
 * - 1 - LBKDIF interrupt requests enabled.
 */
/*@{*/
#define BP_UART_BDH_LBKDIE   (7U)          /*!< Bit position for UART_BDH_LBKDIE. */
#define BM_UART_BDH_LBKDIE   (0x80U)       /*!< Bit mask for UART_BDH_LBKDIE. */
#define BS_UART_BDH_LBKDIE   (1U)          /*!< Bit field size in bits for UART_BDH_LBKDIE. */

/*! @brief Read current value of the UART_BDH_LBKDIE field. */
#define BR_UART_BDH_LBKDIE(x) (BITBAND_ACCESS8(HW_UART_BDH_ADDR(x), BP_UART_BDH_LBKDIE))

/*! @brief Format value for bitfield UART_BDH_LBKDIE. */
#define BF_UART_BDH_LBKDIE(v) ((uint8_t)((uint8_t)(v) << BP_UART_BDH_LBKDIE) & BM_UART_BDH_LBKDIE)

/*! @brief Set the LBKDIE field to a new value. */
#define BW_UART_BDH_LBKDIE(x, v) (BITBAND_ACCESS8(HW_UART_BDH_ADDR(x), BP_UART_BDH_LBKDIE) = (v))
/*@}*/

/*******************************************************************************
 * HW_UART_BDL - UART Baud Rate Registers: Low
 ******************************************************************************/

/*!
 * @brief HW_UART_BDL - UART Baud Rate Registers: Low (RW)
 *
 * Reset value: 0x04U
 *
 * This register, along with the BDH register, controls the prescale divisor for
 * UART baud rate generation. To update the 13-bit baud rate setting
 * (SBR[12:0]), first write to BDH to buffer the high half of the new value and then write
 * to BDL. The working value in BDH does not change until BDL is written. BDL is
 * reset to a non-zero value, but after reset the baud rate generator remains
 * disabled until the first time the receiver or transmitter is enabled (C2[RE] or
 * C2[TE] bits are set)
 */
typedef union _hw_uart_bdl
{
    uint8_t U;
    struct _hw_uart_bdl_bitfields
    {
        uint8_t SBR : 8;               /*!< [7:0] UART Baud Rate Bits */
    } B;
} hw_uart_bdl_t;

/*!
 * @name Constants and macros for entire UART_BDL register
 */
/*@{*/
#define HW_UART_BDL_ADDR(x)      ((x) + 0x1U)

#define HW_UART_BDL(x)           (*(__IO hw_uart_bdl_t *) HW_UART_BDL_ADDR(x))
#define HW_UART_BDL_RD(x)        (HW_UART_BDL(x).U)
#define HW_UART_BDL_WR(x, v)     (HW_UART_BDL(x).U = (v))
#define HW_UART_BDL_SET(x, v)    (HW_UART_BDL_WR(x, HW_UART_BDL_RD(x) |  (v)))
#define HW_UART_BDL_CLR(x, v)    (HW_UART_BDL_WR(x, HW_UART_BDL_RD(x) & ~(v)))
#define HW_UART_BDL_TOG(x, v)    (HW_UART_BDL_WR(x, HW_UART_BDL_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual UART_BDL bitfields
 */

/*!
 * @name Register UART_BDL, field SBR[7:0] (RW)
 *
 * The baud rate for the UART is determined by these 13 bits. See Baud rate
 * generation for details The baud rate generator is disabled until the C2[TE] bit or
 * the C2[RE] bit is set for the first time after reset.The baud rate generator
 * is disabled when SBR = 0. Writing to BDH has no effect without writing to BDL,
 * since writing to BDH puts the data in a temporary location until BDL is
 * written. When the 1/32 narrow pulse width is selected for infrared (IrDA), the baud
 * rate bits must be even, the least significant bit is 0. Refer to MODEM
 * register.
 */
/*@{*/
#define BP_UART_BDL_SBR      (0U)          /*!< Bit position for UART_BDL_SBR. */
#define BM_UART_BDL_SBR      (0xFFU)       /*!< Bit mask for UART_BDL_SBR. */
#define BS_UART_BDL_SBR      (8U)          /*!< Bit field size in bits for UART_BDL_SBR. */

/*! @brief Read current value of the UART_BDL_SBR field. */
#define BR_UART_BDL_SBR(x)   (HW_UART_BDL(x).U)

/*! @brief Format value for bitfield UART_BDL_SBR. */
#define BF_UART_BDL_SBR(v)   ((uint8_t)((uint8_t)(v) << BP_UART_BDL_SBR) & BM_UART_BDL_SBR)

/*! @brief Set the SBR field to a new value. */
#define BW_UART_BDL_SBR(x, v) (HW_UART_BDL_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_UART_C1 - UART Control Register 1
 ******************************************************************************/

/*!
 * @brief HW_UART_C1 - UART Control Register 1 (RW)
 *
 * Reset value: 0x00U
 *
 * This read/write register controls various optional features of the UART
 * system.
 */
typedef union _hw_uart_c1
{
    uint8_t U;
    struct _hw_uart_c1_bitfields
    {
        uint8_t PT : 1;                /*!< [0] Parity Type */
        uint8_t PE : 1;                /*!< [1] Parity Enable */
        uint8_t ILT : 1;               /*!< [2] Idle Line Type Select */
        uint8_t WAKE : 1;              /*!< [3] Receiver Wakeup Method Select */
        uint8_t M : 1;                 /*!< [4] 9-bit or 8-bit Mode Select */
        uint8_t RSRC : 1;              /*!< [5] Receiver Source Select */
        uint8_t UARTSWAI : 1;          /*!< [6] UART Stops in Wait Mode */
        uint8_t LOOPS : 1;             /*!< [7] Loop Mode Select */
    } B;
} hw_uart_c1_t;

/*!
 * @name Constants and macros for entire UART_C1 register
 */
/*@{*/
#define HW_UART_C1_ADDR(x)       ((x) + 0x2U)

#define HW_UART_C1(x)            (*(__IO hw_uart_c1_t *) HW_UART_C1_ADDR(x))
#define HW_UART_C1_RD(x)         (HW_UART_C1(x).U)
#define HW_UART_C1_WR(x, v)      (HW_UART_C1(x).U = (v))
#define HW_UART_C1_SET(x, v)     (HW_UART_C1_WR(x, HW_UART_C1_RD(x) |  (v)))
#define HW_UART_C1_CLR(x, v)     (HW_UART_C1_WR(x, HW_UART_C1_RD(x) & ~(v)))
#define HW_UART_C1_TOG(x, v)     (HW_UART_C1_WR(x, HW_UART_C1_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual UART_C1 bitfields
 */

/*!
 * @name Register UART_C1, field PT[0] (RW)
 *
 * PT determines whether the UART generates and checks for even parity or odd
 * parity. With even parity, an even number of 1s clears the parity bit and an odd
 * number of 1s sets the parity bit. With odd parity, an odd number of 1s clears
 * the parity bit and an even number of 1s sets the parity bit.This bit must be
 * cleared when 7816E is set/enabled.
 *
 * Values:
 * - 0 - Even parity.
 * - 1 - Odd parity.
 */
/*@{*/
#define BP_UART_C1_PT        (0U)          /*!< Bit position for UART_C1_PT. */
#define BM_UART_C1_PT        (0x01U)       /*!< Bit mask for UART_C1_PT. */
#define BS_UART_C1_PT        (1U)          /*!< Bit field size in bits for UART_C1_PT. */

/*! @brief Read current value of the UART_C1_PT field. */
#define BR_UART_C1_PT(x)     (BITBAND_ACCESS8(HW_UART_C1_ADDR(x), BP_UART_C1_PT))

/*! @brief Format value for bitfield UART_C1_PT. */
#define BF_UART_C1_PT(v)     ((uint8_t)((uint8_t)(v) << BP_UART_C1_PT) & BM_UART_C1_PT)

/*! @brief Set the PT field to a new value. */
#define BW_UART_C1_PT(x, v)  (BITBAND_ACCESS8(HW_UART_C1_ADDR(x), BP_UART_C1_PT) = (v))
/*@}*/

/*!
 * @name Register UART_C1, field PE[1] (RW)
 *
 * Enables the parity function. When parity is enabled, parity function inserts
 * a parity bit in the bit position immediately preceding the stop bit. This bit
 * must be set when 7816E is set/enabled.
 *
 * Values:
 * - 0 - Parity function disabled.
 * - 1 - Parity function enabled.
 */
/*@{*/
#define BP_UART_C1_PE        (1U)          /*!< Bit position for UART_C1_PE. */
#define BM_UART_C1_PE        (0x02U)       /*!< Bit mask for UART_C1_PE. */
#define BS_UART_C1_PE        (1U)          /*!< Bit field size in bits for UART_C1_PE. */

/*! @brief Read current value of the UART_C1_PE field. */
#define BR_UART_C1_PE(x)     (BITBAND_ACCESS8(HW_UART_C1_ADDR(x), BP_UART_C1_PE))

/*! @brief Format value for bitfield UART_C1_PE. */
#define BF_UART_C1_PE(v)     ((uint8_t)((uint8_t)(v) << BP_UART_C1_PE) & BM_UART_C1_PE)

/*! @brief Set the PE field to a new value. */
#define BW_UART_C1_PE(x, v)  (BITBAND_ACCESS8(HW_UART_C1_ADDR(x), BP_UART_C1_PE) = (v))
/*@}*/

/*!
 * @name Register UART_C1, field ILT[2] (RW)
 *
 * ILT determines when the receiver starts counting logic 1s as idle character
 * bits. The counting begins either after a valid start bit or after the stop bit.
 * If the count begins after the start bit, then a string of logic 1s preceding
 * the stop bit can cause false recognition of an idle character. Beginning the
 * count after the stop bit avoids false idle character recognition, but requires
 * properly synchronized transmissions. In the case where UART is programmed with
 * ILT = 1, a logic of 1'b0 is automatically shifted after a received stop bit
 * thus resetting the idle count. In the case where UART is programmed for IDLE
 * line wakeup (RWU = 1 and WAKE = 0), ILT has no effect on when the receiver
 * starts counting logic 1s as idle character bits. In idle line wakeup an idle
 * character is recognized at anytime the receiver sees 10, 11, or 12 1s depending on
 * the M, PE, and C4[M10] bits.
 *
 * Values:
 * - 0 - Idle character bit count starts after start bit.
 * - 1 - Idle character bit count starts after stop bit.
 */
/*@{*/
#define BP_UART_C1_ILT       (2U)          /*!< Bit position for UART_C1_ILT. */
#define BM_UART_C1_ILT       (0x04U)       /*!< Bit mask for UART_C1_ILT. */
#define BS_UART_C1_ILT       (1U)          /*!< Bit field size in bits for UART_C1_ILT. */

/*! @brief Read current value of the UART_C1_ILT field. */
#define BR_UART_C1_ILT(x)    (BITBAND_ACCESS8(HW_UART_C1_ADDR(x), BP_UART_C1_ILT))

/*! @brief Format value for bitfield UART_C1_ILT. */
#define BF_UART_C1_ILT(v)    ((uint8_t)((uint8_t)(v) << BP_UART_C1_ILT) & BM_UART_C1_ILT)

/*! @brief Set the ILT field to a new value. */
#define BW_UART_C1_ILT(x, v) (BITBAND_ACCESS8(HW_UART_C1_ADDR(x), BP_UART_C1_ILT) = (v))
/*@}*/

/*!
 * @name Register UART_C1, field WAKE[3] (RW)
 *
 * WAKE determines which condition wakes the UART: address mark in the most
 * significant bit position of a received data character or an idle condition on the
 * receive pin input signal.
 *
 * Values:
 * - 0 - Idle-line wakeup.
 * - 1 - Address-mark wakeup.
 */
/*@{*/
#define BP_UART_C1_WAKE      (3U)          /*!< Bit position for UART_C1_WAKE. */
#define BM_UART_C1_WAKE      (0x08U)       /*!< Bit mask for UART_C1_WAKE. */
#define BS_UART_C1_WAKE      (1U)          /*!< Bit field size in bits for UART_C1_WAKE. */

/*! @brief Read current value of the UART_C1_WAKE field. */
#define BR_UART_C1_WAKE(x)   (BITBAND_ACCESS8(HW_UART_C1_ADDR(x), BP_UART_C1_WAKE))

/*! @brief Format value for bitfield UART_C1_WAKE. */
#define BF_UART_C1_WAKE(v)   ((uint8_t)((uint8_t)(v) << BP_UART_C1_WAKE) & BM_UART_C1_WAKE)

/*! @brief Set the WAKE field to a new value. */
#define BW_UART_C1_WAKE(x, v) (BITBAND_ACCESS8(HW_UART_C1_ADDR(x), BP_UART_C1_WAKE) = (v))
/*@}*/

/*!
 * @name Register UART_C1, field M[4] (RW)
 *
 * This bit must be set when 7816E is set/enabled.
 *
 * Values:
 * - 0 - Normal - start + 8 data bits (MSB/LSB first as determined by MSBF) +
 *     stop.
 * - 1 - Use - start + 9 data bits (MSB/LSB first as determined by MSBF) + stop.
 */
/*@{*/
#define BP_UART_C1_M         (4U)          /*!< Bit position for UART_C1_M. */
#define BM_UART_C1_M         (0x10U)       /*!< Bit mask for UART_C1_M. */
#define BS_UART_C1_M         (1U)          /*!< Bit field size in bits for UART_C1_M. */

/*! @brief Read current value of the UART_C1_M field. */
#define BR_UART_C1_M(x)      (BITBAND_ACCESS8(HW_UART_C1_ADDR(x), BP_UART_C1_M))

/*! @brief Format value for bitfield UART_C1_M. */
#define BF_UART_C1_M(v)      ((uint8_t)((uint8_t)(v) << BP_UART_C1_M) & BM_UART_C1_M)

/*! @brief Set the M field to a new value. */
#define BW_UART_C1_M(x, v)   (BITBAND_ACCESS8(HW_UART_C1_ADDR(x), BP_UART_C1_M) = (v))
/*@}*/

/*!
 * @name Register UART_C1, field RSRC[5] (RW)
 *
 * This bit has no meaning or effect unless the LOOPS bit is set. When LOOPS is
 * set, the RSRC bit determines the source for the receiver shift register input.
 *
 * Values:
 * - 0 - Selects internal loop back mode and receiver input is internally
 *     connected to transmitter output.
 * - 1 - Single-wire UART mode where the receiver input is connected to the
 *     transmit pin input signal.
 */
/*@{*/
#define BP_UART_C1_RSRC      (5U)          /*!< Bit position for UART_C1_RSRC. */
#define BM_UART_C1_RSRC      (0x20U)       /*!< Bit mask for UART_C1_RSRC. */
#define BS_UART_C1_RSRC      (1U)          /*!< Bit field size in bits for UART_C1_RSRC. */

/*! @brief Read current value of the UART_C1_RSRC field. */
#define BR_UART_C1_RSRC(x)   (BITBAND_ACCESS8(HW_UART_C1_ADDR(x), BP_UART_C1_RSRC))

/*! @brief Format value for bitfield UART_C1_RSRC. */
#define BF_UART_C1_RSRC(v)   ((uint8_t)((uint8_t)(v) << BP_UART_C1_RSRC) & BM_UART_C1_RSRC)

/*! @brief Set the RSRC field to a new value. */
#define BW_UART_C1_RSRC(x, v) (BITBAND_ACCESS8(HW_UART_C1_ADDR(x), BP_UART_C1_RSRC) = (v))
/*@}*/

/*!
 * @name Register UART_C1, field UARTSWAI[6] (RW)
 *
 * Values:
 * - 0 - UART clock continues to run in wait mode.
 * - 1 - UART clock freezes while CPU is in wait mode.
 */
/*@{*/
#define BP_UART_C1_UARTSWAI  (6U)          /*!< Bit position for UART_C1_UARTSWAI. */
#define BM_UART_C1_UARTSWAI  (0x40U)       /*!< Bit mask for UART_C1_UARTSWAI. */
#define BS_UART_C1_UARTSWAI  (1U)          /*!< Bit field size in bits for UART_C1_UARTSWAI. */

/*! @brief Read current value of the UART_C1_UARTSWAI field. */
#define BR_UART_C1_UARTSWAI(x) (BITBAND_ACCESS8(HW_UART_C1_ADDR(x), BP_UART_C1_UARTSWAI))

/*! @brief Format value for bitfield UART_C1_UARTSWAI. */
#define BF_UART_C1_UARTSWAI(v) ((uint8_t)((uint8_t)(v) << BP_UART_C1_UARTSWAI) & BM_UART_C1_UARTSWAI)

/*! @brief Set the UARTSWAI field to a new value. */
#define BW_UART_C1_UARTSWAI(x, v) (BITBAND_ACCESS8(HW_UART_C1_ADDR(x), BP_UART_C1_UARTSWAI) = (v))
/*@}*/

/*!
 * @name Register UART_C1, field LOOPS[7] (RW)
 *
 * When LOOPS is set, the RxD pin is disconnected from the UART and the
 * transmitter output is internally connected to the receiver input.The transmitter and
 * the receiver must be enabled to use the loop function.
 *
 * Values:
 * - 0 - Normal operation.
 * - 1 - Loop mode where transmitter output is internally connected to receiver
 *     input. The receiver input is determined by the RSRC bit.
 */
/*@{*/
#define BP_UART_C1_LOOPS     (7U)          /*!< Bit position for UART_C1_LOOPS. */
#define BM_UART_C1_LOOPS     (0x80U)       /*!< Bit mask for UART_C1_LOOPS. */
#define BS_UART_C1_LOOPS     (1U)          /*!< Bit field size in bits for UART_C1_LOOPS. */

/*! @brief Read current value of the UART_C1_LOOPS field. */
#define BR_UART_C1_LOOPS(x)  (BITBAND_ACCESS8(HW_UART_C1_ADDR(x), BP_UART_C1_LOOPS))

/*! @brief Format value for bitfield UART_C1_LOOPS. */
#define BF_UART_C1_LOOPS(v)  ((uint8_t)((uint8_t)(v) << BP_UART_C1_LOOPS) & BM_UART_C1_LOOPS)

/*! @brief Set the LOOPS field to a new value. */
#define BW_UART_C1_LOOPS(x, v) (BITBAND_ACCESS8(HW_UART_C1_ADDR(x), BP_UART_C1_LOOPS) = (v))
/*@}*/

/*******************************************************************************
 * HW_UART_C2 - UART Control Register 2
 ******************************************************************************/

/*!
 * @brief HW_UART_C2 - UART Control Register 2 (RW)
 *
 * Reset value: 0x00U
 *
 * This register can be read or written at any time.
 */
typedef union _hw_uart_c2
{
    uint8_t U;
    struct _hw_uart_c2_bitfields
    {
        uint8_t SBK : 1;               /*!< [0] Send Break */
        uint8_t RWU : 1;               /*!< [1] Receiver Wakeup Control */
        uint8_t RE : 1;                /*!< [2] Receiver Enable */
        uint8_t TE : 1;                /*!< [3] Transmitter Enable */
        uint8_t ILIE : 1;              /*!< [4] Idle Line Interrupt Enable */
        uint8_t RIE : 1;               /*!< [5] Receiver Full Interrupt or DMA Transfer
                                        * Enable */
        uint8_t TCIE : 1;              /*!< [6] Transmission Complete Interrupt Enable */
        uint8_t TIE : 1;               /*!< [7] Transmitter Interrupt or DMA Transfer
                                        * Enable. */
    } B;
} hw_uart_c2_t;

/*!
 * @name Constants and macros for entire UART_C2 register
 */
/*@{*/
#define HW_UART_C2_ADDR(x)       ((x) + 0x3U)

#define HW_UART_C2(x)            (*(__IO hw_uart_c2_t *) HW_UART_C2_ADDR(x))
#define HW_UART_C2_RD(x)         (HW_UART_C2(x).U)
#define HW_UART_C2_WR(x, v)      (HW_UART_C2(x).U = (v))
#define HW_UART_C2_SET(x, v)     (HW_UART_C2_WR(x, HW_UART_C2_RD(x) |  (v)))
#define HW_UART_C2_CLR(x, v)     (HW_UART_C2_WR(x, HW_UART_C2_RD(x) & ~(v)))
#define HW_UART_C2_TOG(x, v)     (HW_UART_C2_WR(x, HW_UART_C2_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual UART_C2 bitfields
 */

/*!
 * @name Register UART_C2, field SBK[0] (RW)
 *
 * Toggling SBK sends one break character (10, 11, or 12 logic 0s, if S2[BRK13]
 * is cleared; 13 or 14 logic 0s, if S2[BRK13] is set). See Transmitting break
 * characters for the number of logic 0s for the different configurations. Toggling
 * implies clearing the SBK bit before the break character has finished
 * transmitting. As long as SBK is set, the transmitter continues to send complete break
 * characters (10, 11, or 12 bits, or 13 or 14 bits).This bit must be cleared
 * when 7816E is set.
 *
 * Values:
 * - 0 - Normal transmitter operation.
 * - 1 - Queue break character(s) to be sent.
 */
/*@{*/
#define BP_UART_C2_SBK       (0U)          /*!< Bit position for UART_C2_SBK. */
#define BM_UART_C2_SBK       (0x01U)       /*!< Bit mask for UART_C2_SBK. */
#define BS_UART_C2_SBK       (1U)          /*!< Bit field size in bits for UART_C2_SBK. */

/*! @brief Read current value of the UART_C2_SBK field. */
#define BR_UART_C2_SBK(x)    (BITBAND_ACCESS8(HW_UART_C2_ADDR(x), BP_UART_C2_SBK))

/*! @brief Format value for bitfield UART_C2_SBK. */
#define BF_UART_C2_SBK(v)    ((uint8_t)((uint8_t)(v) << BP_UART_C2_SBK) & BM_UART_C2_SBK)

/*! @brief Set the SBK field to a new value. */
#define BW_UART_C2_SBK(x, v) (BITBAND_ACCESS8(HW_UART_C2_ADDR(x), BP_UART_C2_SBK) = (v))
/*@}*/

/*!
 * @name Register UART_C2, field RWU[1] (RW)
 *
 * This bit can be set to place the UART receiver in a standby state. RWU
 * automatically clears when an RWU event occurs (an IDLE event when C1[WAKE] is clear
 * or an address match when C1[WAKE] is set). This bit must be cleared when 7816E
 * is set. RWU should only be set with C1[WAKE] = 0 (wakeup on idle) if the
 * channel is currently not idle. This can be determined by the S2[RAF] flag. If set
 * to wake up an IDLE event and the channel is already idle, it is possible that
 * the UART will discard data since data must be received (or a LIN break detect)
 * after an IDLE is detected before IDLE is allowed to reasserted.
 *
 * Values:
 * - 0 - Normal operation.
 * - 1 - RWU enables the wakeup function and inhibits further receiver interrupt
 *     requests. Normally, hardware wakes the receiver by automatically clearing
 *     RWU.
 */
/*@{*/
#define BP_UART_C2_RWU       (1U)          /*!< Bit position for UART_C2_RWU. */
#define BM_UART_C2_RWU       (0x02U)       /*!< Bit mask for UART_C2_RWU. */
#define BS_UART_C2_RWU       (1U)          /*!< Bit field size in bits for UART_C2_RWU. */

/*! @brief Read current value of the UART_C2_RWU field. */
#define BR_UART_C2_RWU(x)    (BITBAND_ACCESS8(HW_UART_C2_ADDR(x), BP_UART_C2_RWU))

/*! @brief Format value for bitfield UART_C2_RWU. */
#define BF_UART_C2_RWU(v)    ((uint8_t)((uint8_t)(v) << BP_UART_C2_RWU) & BM_UART_C2_RWU)

/*! @brief Set the RWU field to a new value. */
#define BW_UART_C2_RWU(x, v) (BITBAND_ACCESS8(HW_UART_C2_ADDR(x), BP_UART_C2_RWU) = (v))
/*@}*/

/*!
 * @name Register UART_C2, field RE[2] (RW)
 *
 * RE enables the UART receiver.
 *
 * Values:
 * - 0 - Receiver off.
 * - 1 - Receiver on.
 */
/*@{*/
#define BP_UART_C2_RE        (2U)          /*!< Bit position for UART_C2_RE. */
#define BM_UART_C2_RE        (0x04U)       /*!< Bit mask for UART_C2_RE. */
#define BS_UART_C2_RE        (1U)          /*!< Bit field size in bits for UART_C2_RE. */

/*! @brief Read current value of the UART_C2_RE field. */
#define BR_UART_C2_RE(x)     (BITBAND_ACCESS8(HW_UART_C2_ADDR(x), BP_UART_C2_RE))

/*! @brief Format value for bitfield UART_C2_RE. */
#define BF_UART_C2_RE(v)     ((uint8_t)((uint8_t)(v) << BP_UART_C2_RE) & BM_UART_C2_RE)

/*! @brief Set the RE field to a new value. */
#define BW_UART_C2_RE(x, v)  (BITBAND_ACCESS8(HW_UART_C2_ADDR(x), BP_UART_C2_RE) = (v))
/*@}*/

/*!
 * @name Register UART_C2, field TE[3] (RW)
 *
 * TE enables the UART transmitter.The TE bit can be used to queue an idle
 * preamble by clearing and then setting the TE bit. When 7816E is set/enabled and
 * C7816[TTYPE] = 1, this bit is automatically cleared after the requested block has
 * been transmitted. This condition is detected when TL7816[TLEN] = 0 and four
 * additional characters have been transmitted.
 *
 * Values:
 * - 0 - Transmitter off.
 * - 1 - Transmitter on.
 */
/*@{*/
#define BP_UART_C2_TE        (3U)          /*!< Bit position for UART_C2_TE. */
#define BM_UART_C2_TE        (0x08U)       /*!< Bit mask for UART_C2_TE. */
#define BS_UART_C2_TE        (1U)          /*!< Bit field size in bits for UART_C2_TE. */

/*! @brief Read current value of the UART_C2_TE field. */
#define BR_UART_C2_TE(x)     (BITBAND_ACCESS8(HW_UART_C2_ADDR(x), BP_UART_C2_TE))

/*! @brief Format value for bitfield UART_C2_TE. */
#define BF_UART_C2_TE(v)     ((uint8_t)((uint8_t)(v) << BP_UART_C2_TE) & BM_UART_C2_TE)

/*! @brief Set the TE field to a new value. */
#define BW_UART_C2_TE(x, v)  (BITBAND_ACCESS8(HW_UART_C2_ADDR(x), BP_UART_C2_TE) = (v))
/*@}*/

/*!
 * @name Register UART_C2, field ILIE[4] (RW)
 *
 * ILIE enables the idle line flag, S1[IDLE], to generate interrupt requests,
 * based on the state of C5[ILDMAS].
 *
 * Values:
 * - 0 - IDLE interrupt requests disabled.
 * - 1 - IDLE interrupt requests enabled.
 */
/*@{*/
#define BP_UART_C2_ILIE      (4U)          /*!< Bit position for UART_C2_ILIE. */
#define BM_UART_C2_ILIE      (0x10U)       /*!< Bit mask for UART_C2_ILIE. */
#define BS_UART_C2_ILIE      (1U)          /*!< Bit field size in bits for UART_C2_ILIE. */

/*! @brief Read current value of the UART_C2_ILIE field. */
#define BR_UART_C2_ILIE(x)   (BITBAND_ACCESS8(HW_UART_C2_ADDR(x), BP_UART_C2_ILIE))

/*! @brief Format value for bitfield UART_C2_ILIE. */
#define BF_UART_C2_ILIE(v)   ((uint8_t)((uint8_t)(v) << BP_UART_C2_ILIE) & BM_UART_C2_ILIE)

/*! @brief Set the ILIE field to a new value. */
#define BW_UART_C2_ILIE(x, v) (BITBAND_ACCESS8(HW_UART_C2_ADDR(x), BP_UART_C2_ILIE) = (v))
/*@}*/

/*!
 * @name Register UART_C2, field RIE[5] (RW)
 *
 * RIE enables the S1[RDRF] flag, to generate interrupt requests or DMA transfer
 * requests, based on the state of C5[RDMAS].
 *
 * Values:
 * - 0 - RDRF interrupt and DMA transfer requests disabled.
 * - 1 - RDRF interrupt or DMA transfer requests enabled
 */
/*@{*/
#define BP_UART_C2_RIE       (5U)          /*!< Bit position for UART_C2_RIE. */
#define BM_UART_C2_RIE       (0x20U)       /*!< Bit mask for UART_C2_RIE. */
#define BS_UART_C2_RIE       (1U)          /*!< Bit field size in bits for UART_C2_RIE. */

/*! @brief Read current value of the UART_C2_RIE field. */
#define BR_UART_C2_RIE(x)    (BITBAND_ACCESS8(HW_UART_C2_ADDR(x), BP_UART_C2_RIE))

/*! @brief Format value for bitfield UART_C2_RIE. */
#define BF_UART_C2_RIE(v)    ((uint8_t)((uint8_t)(v) << BP_UART_C2_RIE) & BM_UART_C2_RIE)

/*! @brief Set the RIE field to a new value. */
#define BW_UART_C2_RIE(x, v) (BITBAND_ACCESS8(HW_UART_C2_ADDR(x), BP_UART_C2_RIE) = (v))
/*@}*/

/*!
 * @name Register UART_C2, field TCIE[6] (RW)
 *
 * TCIE enables the transmission complete flag, S1[TC], to generate interrupt
 * requests.
 *
 * Values:
 * - 0 - TC interrupt requests disabled.
 * - 1 - TC interrupt requests enabled.
 */
/*@{*/
#define BP_UART_C2_TCIE      (6U)          /*!< Bit position for UART_C2_TCIE. */
#define BM_UART_C2_TCIE      (0x40U)       /*!< Bit mask for UART_C2_TCIE. */
#define BS_UART_C2_TCIE      (1U)          /*!< Bit field size in bits for UART_C2_TCIE. */

/*! @brief Read current value of the UART_C2_TCIE field. */
#define BR_UART_C2_TCIE(x)   (BITBAND_ACCESS8(HW_UART_C2_ADDR(x), BP_UART_C2_TCIE))

/*! @brief Format value for bitfield UART_C2_TCIE. */
#define BF_UART_C2_TCIE(v)   ((uint8_t)((uint8_t)(v) << BP_UART_C2_TCIE) & BM_UART_C2_TCIE)

/*! @brief Set the TCIE field to a new value. */
#define BW_UART_C2_TCIE(x, v) (BITBAND_ACCESS8(HW_UART_C2_ADDR(x), BP_UART_C2_TCIE) = (v))
/*@}*/

/*!
 * @name Register UART_C2, field TIE[7] (RW)
 *
 * TIE enables the S1[TDRE] flag, to generate interrupt requests or DMA transfer
 * requests, based on the state of C5[TDMAS]. If C2[TIE] and C5[TDMAS] are both
 * set, then TCIE must be cleared, and D[D] must not be written outside of
 * servicing of a DMA request.
 *
 * Values:
 * - 0 - TDRE interrupt and DMA transfer requests disabled.
 * - 1 - TDRE interrupt or DMA transfer requests enabled.
 */
/*@{*/
#define BP_UART_C2_TIE       (7U)          /*!< Bit position for UART_C2_TIE. */
#define BM_UART_C2_TIE       (0x80U)       /*!< Bit mask for UART_C2_TIE. */
#define BS_UART_C2_TIE       (1U)          /*!< Bit field size in bits for UART_C2_TIE. */

/*! @brief Read current value of the UART_C2_TIE field. */
#define BR_UART_C2_TIE(x)    (BITBAND_ACCESS8(HW_UART_C2_ADDR(x), BP_UART_C2_TIE))

/*! @brief Format value for bitfield UART_C2_TIE. */
#define BF_UART_C2_TIE(v)    ((uint8_t)((uint8_t)(v) << BP_UART_C2_TIE) & BM_UART_C2_TIE)

/*! @brief Set the TIE field to a new value. */
#define BW_UART_C2_TIE(x, v) (BITBAND_ACCESS8(HW_UART_C2_ADDR(x), BP_UART_C2_TIE) = (v))
/*@}*/

/*******************************************************************************
 * HW_UART_S1 - UART Status Register 1
 ******************************************************************************/

/*!
 * @brief HW_UART_S1 - UART Status Register 1 (RO)
 *
 * Reset value: 0xC0U
 *
 * The S1 register provides inputs to the MCU for generation of UART interrupts
 * or DMA requests. This register can also be polled by the MCU to check the
 * status of these bits. To clear a flag, the status register should be read followed
 * by a read or write (depending on interrupt flag type) to the UART Data
 * Register. Other instructions can be executed between the two steps as long as it
 * does not compromise the handling of I/O, but the order of operations is important
 * for flag clearing. When a flag is configured to trigger a DMA request,
 * assertion of the associated DMA done signal from the DMA controller, clears the
 * flag. If the condition that results in the assertion of the flag, interrupt or DMA
 * request is not resolved prior to clearing the flag, the flag (and
 * interrupt/DMA request) will reassert. For example, if the DMA or interrupt service
 * routine failed to write sufficient data to the transmit buffer to raise it above the
 * watermark level, the flag will reassert and generate another interrupt or DMA
 * request. Reading an empty data register to clear one of these flags causes
 * the FIFO pointers to get out of alignment. A receive FIFO flush reinitializes
 * the pointers.
 */
typedef union _hw_uart_s1
{
    uint8_t U;
    struct _hw_uart_s1_bitfields
    {
        uint8_t PF : 1;                /*!< [0] Parity Error Flag */
        uint8_t FE : 1;                /*!< [1] Framing Error Flag */
        uint8_t NF : 1;                /*!< [2] Noise Flag */
        uint8_t OR : 1;                /*!< [3] Receiver Overrun Flag */
        uint8_t IDLE : 1;              /*!< [4] Idle Line Flag */
        uint8_t RDRF : 1;              /*!< [5] Receive Data Register Full Flag */
        uint8_t TC : 1;                /*!< [6] Transmit Complete Flag */
        uint8_t TDRE : 1;              /*!< [7] Transmit Data Register Empty Flag */
    } B;
} hw_uart_s1_t;

/*!
 * @name Constants and macros for entire UART_S1 register
 */
/*@{*/
#define HW_UART_S1_ADDR(x)       ((x) + 0x4U)

#define HW_UART_S1(x)            (*(__I hw_uart_s1_t *) HW_UART_S1_ADDR(x))
#define HW_UART_S1_RD(x)         (HW_UART_S1(x).U)
/*@}*/

/*
 * Constants & macros for individual UART_S1 bitfields
 */

/*!
 * @name Register UART_S1, field PF[0] (RO)
 *
 * PF is set when PE is set, S2[LBKDE] is disabled, and the parity of the
 * received data does not match its parity bit. The PF is not set in the case of an
 * overrun condition. When the PF bit is set it only indicates that a dataword was
 * received with parity error since the last time it was cleared. There is no
 * guarantee that the first dataword read from the receive buffer has a parity error
 * or that there is only one dataword in the buffer that was received with a
 * parity error unless the receive buffer was a depth of one. To clear PF, read S1
 * and then read the UART data register (D). Within the receive buffer structure
 * the received dataword is tagged if it was received with a parity error. That
 * information is available by reading the ED register prior to reading the D
 * register. When EN709 is set/enabled parity error flag is not set.
 *
 * Values:
 * - 0 - No parity error has been detected since the last time this flag was
 *     cleared. If the receive buffer has a depth greater than 1 then there may be
 *     data in the receive buffer what was received with a parity error.
 * - 1 - At least one dataword was received with a parity error since the last
 *     time this flag was cleared.
 */
/*@{*/
#define BP_UART_S1_PF        (0U)          /*!< Bit position for UART_S1_PF. */
#define BM_UART_S1_PF        (0x01U)       /*!< Bit mask for UART_S1_PF. */
#define BS_UART_S1_PF        (1U)          /*!< Bit field size in bits for UART_S1_PF. */

/*! @brief Read current value of the UART_S1_PF field. */
#define BR_UART_S1_PF(x)     (BITBAND_ACCESS8(HW_UART_S1_ADDR(x), BP_UART_S1_PF))
/*@}*/

/*!
 * @name Register UART_S1, field FE[1] (RO)
 *
 * FE is set when a logic 0 is accepted as the stop bit. FE bit does not set in
 * the case of an overrun or while the LIN break detect feature is enabled
 * (S2[LBKDE] = 1). FE inhibits further data reception until it is cleared. To clear
 * FE, read S1 with FE set and then read the UART data register (D). The last data
 * in the receive buffer represents the data that was received with the frame
 * error enabled. However, framing errors are not supported when 7816E is
 * set/enabled. However, if this flag is set, data will still not be received in 7816 mode.
 * Framing errors are not supported in 709 mode.
 *
 * Values:
 * - 0 - No framing error detected.
 * - 1 - Framing error.
 */
/*@{*/
#define BP_UART_S1_FE        (1U)          /*!< Bit position for UART_S1_FE. */
#define BM_UART_S1_FE        (0x02U)       /*!< Bit mask for UART_S1_FE. */
#define BS_UART_S1_FE        (1U)          /*!< Bit field size in bits for UART_S1_FE. */

/*! @brief Read current value of the UART_S1_FE field. */
#define BR_UART_S1_FE(x)     (BITBAND_ACCESS8(HW_UART_S1_ADDR(x), BP_UART_S1_FE))
/*@}*/

/*!
 * @name Register UART_S1, field NF[2] (RO)
 *
 * NF is set when the UART detects noise on the receiver input. NF bit does not
 * get set in the case of an overrun or while the LIN break detect feature is
 * enabled (S2[LBKDE] = 1). When NF is set, it only indicates that a dataword has
 * been received with noise since the last time it was cleared. There is no
 * guarantee that the first dataword read from the receive buffer has noise or that
 * there is only one dataword in the buffer that was received with noise unless the
 * receive buffer has a depth of one. To clear NF, read S1 and then read the UART
 * data register (D). When EN709 is set/enabled, noise flag is not set.
 *
 * Values:
 * - 0 - No noise detected since the last time this flag was cleared. If the
 *     receive buffer has a depth greater than 1 then there may be data in the
 *     receiver buffer that was received with noise.
 * - 1 - At least one dataword was received with noise detected since the last
 *     time the flag was cleared.
 */
/*@{*/
#define BP_UART_S1_NF        (2U)          /*!< Bit position for UART_S1_NF. */
#define BM_UART_S1_NF        (0x04U)       /*!< Bit mask for UART_S1_NF. */
#define BS_UART_S1_NF        (1U)          /*!< Bit field size in bits for UART_S1_NF. */

/*! @brief Read current value of the UART_S1_NF field. */
#define BR_UART_S1_NF(x)     (BITBAND_ACCESS8(HW_UART_S1_ADDR(x), BP_UART_S1_NF))
/*@}*/

/*!
 * @name Register UART_S1, field OR[3] (RO)
 *
 * OR is set when software fails to prevent the receive data register from
 * overflowing with data. The OR bit is set immediately after the stop bit has been
 * completely received for the dataword that overflows the buffer and all the other
 * error flags (FE,NF and PF) are prevented from setting. The data in the shift
 * register is lost, but the data already in the UART data registers is not
 * affected. If the OR flag is set, no data will be stored in the data buffer even if
 * sufficient room exists. Additionally, while the OR flag is set the RDRF flag,
 * and IDLE flags will be blocked from asserting, i.e. transition from an
 * inactive to an active state. To clear OR, read S1 when OR is set and then read UART
 * data register (D). If LBKDE is enabled and a LIN Break is detected, the OR bit
 * will assert if the S2[LBKDIF] flag is not cleared before the next data
 * character is received.See Overrun (OR) flag implications for more details regarding
 * the operation of the OR bit. In 7816 mode, it is possible to configure a NACK
 * to be returned by programing the C7816[ONACK] bit.
 *
 * Values:
 * - 0 - No overrun has occurred since the last time the flag was cleared.
 * - 1 - Overrun has occurred or the overrun flag has not been cleared since the
 *     last overrun occured.
 */
/*@{*/
#define BP_UART_S1_OR        (3U)          /*!< Bit position for UART_S1_OR. */
#define BM_UART_S1_OR        (0x08U)       /*!< Bit mask for UART_S1_OR. */
#define BS_UART_S1_OR        (1U)          /*!< Bit field size in bits for UART_S1_OR. */

/*! @brief Read current value of the UART_S1_OR field. */
#define BR_UART_S1_OR(x)     (BITBAND_ACCESS8(HW_UART_S1_ADDR(x), BP_UART_S1_OR))
/*@}*/

/*!
 * @name Register UART_S1, field IDLE[4] (RO)
 *
 * IDLE is set when 10 consecutive logic 1s (if C1[M] = 0), 11 consecutive logic
 * 1s (if C1[M] = 1 and C4[M10] = 0), or 12 consecutive logic 1s (if C1[M] = 1,
 * C4[M10] = 1, and C1[PE] = 1) appear on the receiver input. After the IDLE flag
 * is cleared, a frame must be received (although not necessarily stored in the
 * data buffer, for example if C2[RWU] is set) or a LIN break character must set
 * the S2[LBKDIF] flag before an idle condition can set the IDLE flag. To clear
 * IDLE, read UART status S1 with IDLE set and then read D. Idle detection is not
 * supported when 7816E or EN709 is set/enabled and hence this flag is ignored.
 * When the receiver wakeup bit (RWU) is set and WAKE is cleared, an idle line
 * condition sets the IDLE flag if RWUID is set, else the IDLE flag does not get set.
 *
 * Values:
 * - 0 - Receiver input is either active now or has never become active since
 *     the IDLE flag was last cleared.
 * - 1 - Receiver input has become idle or the flag has not been cleared since
 *     it last asserted.
 */
/*@{*/
#define BP_UART_S1_IDLE      (4U)          /*!< Bit position for UART_S1_IDLE. */
#define BM_UART_S1_IDLE      (0x10U)       /*!< Bit mask for UART_S1_IDLE. */
#define BS_UART_S1_IDLE      (1U)          /*!< Bit field size in bits for UART_S1_IDLE. */

/*! @brief Read current value of the UART_S1_IDLE field. */
#define BR_UART_S1_IDLE(x)   (BITBAND_ACCESS8(HW_UART_S1_ADDR(x), BP_UART_S1_IDLE))
/*@}*/

/*!
 * @name Register UART_S1, field RDRF[5] (RO)
 *
 * RDRF is set when the number of datawords in the receive buffer is equal to or
 * more than the number indicated by RWFIFO[RXWATER]. A dataword that is in the
 * process of being received is not included in the count. RDRF is prevented from
 * setting while S2[LBKDE] is set. Additionally, when S2[LBKDE] is set,
 * datawords that are received will be stored in the receive buffer but will over-write
 * each other. To clear RDRF, read S1 when RDRF is set and then read the UART data
 * register (D). For more efficient interrupt and DMA operation all data except
 * the final value is to be read from the buffer using D/C3[T8]/ED. The S1 should
 * then be read and the final data value read, resulting in the clearing of the
 * RDRF flag. Even if the RDRF flag is set, data will continue to be received
 * until an overrun condition occurs.
 *
 * Values:
 * - 0 - The number of datawords in the receive buffer is less than the number
 *     indicated by RXWATER.
 * - 1 - The number of datawords in the receive buffer is equal to or greater
 *     than the number indicated by RXWATER at some point in time since this flag
 *     was last cleared.
 */
/*@{*/
#define BP_UART_S1_RDRF      (5U)          /*!< Bit position for UART_S1_RDRF. */
#define BM_UART_S1_RDRF      (0x20U)       /*!< Bit mask for UART_S1_RDRF. */
#define BS_UART_S1_RDRF      (1U)          /*!< Bit field size in bits for UART_S1_RDRF. */

/*! @brief Read current value of the UART_S1_RDRF field. */
#define BR_UART_S1_RDRF(x)   (BITBAND_ACCESS8(HW_UART_S1_ADDR(x), BP_UART_S1_RDRF))
/*@}*/

/*!
 * @name Register UART_S1, field TC[6] (RO)
 *
 * TC is cleared when there is a transmission in progress or when a preamble or
 * break character is loaded. TC is set when the transmit buffer is empty and no
 * data, preamble, or break character is being transmitted. When TC is set, the
 * transmit data output signal becomes idle (logic 1). When 7816E is set/enabled
 * this bit is set after any NACK signal has been received but prior to any
 * corresponding guard times expiring. When EN709 is set/enabled this flag is not set
 * on transmit packet completion. TC is cleared by reading S1 with TC set and then
 * doing one of the following: Writing to the UART data register (D) to transmit
 * new data Queuing a preamble by clearing and then setting the C2[TE] bit.
 * Queuing a break character by writing 1 to SBK in C2
 *
 * Values:
 * - 0 - Transmitter active (sending data, a preamble, or a break).
 * - 1 - Transmitter idle (transmission activity complete).
 */
/*@{*/
#define BP_UART_S1_TC        (6U)          /*!< Bit position for UART_S1_TC. */
#define BM_UART_S1_TC        (0x40U)       /*!< Bit mask for UART_S1_TC. */
#define BS_UART_S1_TC        (1U)          /*!< Bit field size in bits for UART_S1_TC. */

/*! @brief Read current value of the UART_S1_TC field. */
#define BR_UART_S1_TC(x)     (BITBAND_ACCESS8(HW_UART_S1_ADDR(x), BP_UART_S1_TC))
/*@}*/

/*!
 * @name Register UART_S1, field TDRE[7] (RO)
 *
 * TDRE will set when the number of datawords in the transmit buffer (D and
 * C3[T8])is equal to or less than the number indicated by TWFIFO[TXWATER]. A
 * character that is in the process of being transmitted is not included in the count.
 * To clear TDRE, read S1 when TDRE is set and then write to the UART data
 * register (D). For more efficient interrupt servicing all data except the final value
 * to be written to the buffer should written to D/C3[T8]. Then S1 can be read
 * before writing the final data value, resulting in the clearing of the TRDE flag.
 * This is more efficient since the TDRE will reassert until the watermark has
 * been exceeded so attempting to clear the TDRE every write will be ineffective
 * until sufficient data has been written.
 *
 * Values:
 * - 0 - The amount of data in the transmit buffer is greater than the value
 *     indicated by TWFIFO[TXWATER].
 * - 1 - The amount of data in the transmit buffer is less than or equal to the
 *     value indicated by TWFIFO[TXWATER] at some point in time since the flag
 *     has been cleared.
 */
/*@{*/
#define BP_UART_S1_TDRE      (7U)          /*!< Bit position for UART_S1_TDRE. */
#define BM_UART_S1_TDRE      (0x80U)       /*!< Bit mask for UART_S1_TDRE. */
#define BS_UART_S1_TDRE      (1U)          /*!< Bit field size in bits for UART_S1_TDRE. */

/*! @brief Read current value of the UART_S1_TDRE field. */
#define BR_UART_S1_TDRE(x)   (BITBAND_ACCESS8(HW_UART_S1_ADDR(x), BP_UART_S1_TDRE))
/*@}*/

/*******************************************************************************
 * HW_UART_S2 - UART Status Register 2
 ******************************************************************************/

/*!
 * @brief HW_UART_S2 - UART Status Register 2 (RW)
 *
 * Reset value: 0x00U
 *
 * The S2 register provides inputs to the MCU for generation of UART interrupts
 * or DMA requests. Also, this register can be polled by the MCU to check the
 * status of these bits. This register can be read or written at any time, with the
 * exception of the MSBF and RXINV bits which should only be changed by the user
 * between transmit and receive packets.
 */
typedef union _hw_uart_s2
{
    uint8_t U;
    struct _hw_uart_s2_bitfields
    {
        uint8_t RAF : 1;               /*!< [0] Receiver Active Flag */
        uint8_t LBKDE : 1;             /*!< [1] LIN Break Detection Enable */
        uint8_t BRK13 : 1;             /*!< [2] Break Transmit Character Length */
        uint8_t RWUID : 1;             /*!< [3] Receive Wakeup Idle Detect */
        uint8_t RXINV : 1;             /*!< [4] Receive Data Inversion */
        uint8_t MSBF : 1;              /*!< [5] Most Significant Bit First */
        uint8_t RXEDGIF : 1;           /*!< [6] RxD Pin Active Edge Interrupt Flag */
        uint8_t LBKDIF : 1;            /*!< [7] LIN Break Detect Interrupt Flag */
    } B;
} hw_uart_s2_t;

/*!
 * @name Constants and macros for entire UART_S2 register
 */
/*@{*/
#define HW_UART_S2_ADDR(x)       ((x) + 0x5U)

#define HW_UART_S2(x)            (*(__IO hw_uart_s2_t *) HW_UART_S2_ADDR(x))
#define HW_UART_S2_RD(x)         (HW_UART_S2(x).U)
#define HW_UART_S2_WR(x, v)      (HW_UART_S2(x).U = (v))
#define HW_UART_S2_SET(x, v)     (HW_UART_S2_WR(x, HW_UART_S2_RD(x) |  (v)))
#define HW_UART_S2_CLR(x, v)     (HW_UART_S2_WR(x, HW_UART_S2_RD(x) & ~(v)))
#define HW_UART_S2_TOG(x, v)     (HW_UART_S2_WR(x, HW_UART_S2_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual UART_S2 bitfields
 */

/*!
 * @name Register UART_S2, field RAF[0] (RO)
 *
 * RAF is set when the UART receiver detects a logic 0 during the RT1 time
 * period of the start bit search. RAF is cleared when the receiver detects an idle
 * character when C7816[ISO7816E] is cleared/disabled. When C7816[ISO7816E] is
 * enabled the RAF is cleared if the C7816[TTYPE] = 0 expires or the C7816[TTYPE] = 1
 * expires. In the case when C7816[ISO7816E] is set and C7816[TTYPE] = 0, it is
 * possible to configure the guard time to be 12. However, in the event that a
 * NACK is required to be transmitted the data transfer actually takes 13 ETU with
 * the 13th ETU slot being a inactive buffer. Hence in this situation the RAF may
 * deassert one ETU prior to actually being inactive.
 *
 * Values:
 * - 0 - UART receiver idle/inactive waiting for a start bit.
 * - 1 - UART receiver active (RxD input not idle).
 */
/*@{*/
#define BP_UART_S2_RAF       (0U)          /*!< Bit position for UART_S2_RAF. */
#define BM_UART_S2_RAF       (0x01U)       /*!< Bit mask for UART_S2_RAF. */
#define BS_UART_S2_RAF       (1U)          /*!< Bit field size in bits for UART_S2_RAF. */

/*! @brief Read current value of the UART_S2_RAF field. */
#define BR_UART_S2_RAF(x)    (BITBAND_ACCESS8(HW_UART_S2_ADDR(x), BP_UART_S2_RAF))
/*@}*/

/*!
 * @name Register UART_S2, field LBKDE[1] (RW)
 *
 * LBKDE selects a longer break character detection length. While LBKDE is set,
 * the S1[RDRF], S1[NF], S1[FE], and S1[PF] flags are prevented from setting.
 * When LBKDE is set, see Overrun operation. The LBKDE bit must be cleared when
 * C7816[ISO7816E] is set.
 *
 * Values:
 * - 0 - Break character is detected at length of 10 bit times (C1[M] = 0), 11
 *     (C1[M] = 1 and C4[M10] = 0), or 12 (C1[M] = 1, C4[M10] = 1, and S1[PE] = 1).
 * - 1 - Break character is detected at length of 11 bits times (if C1[M] = 0 or
 *     12 bits time (if C1[M] = 1).
 */
/*@{*/
#define BP_UART_S2_LBKDE     (1U)          /*!< Bit position for UART_S2_LBKDE. */
#define BM_UART_S2_LBKDE     (0x02U)       /*!< Bit mask for UART_S2_LBKDE. */
#define BS_UART_S2_LBKDE     (1U)          /*!< Bit field size in bits for UART_S2_LBKDE. */

/*! @brief Read current value of the UART_S2_LBKDE field. */
#define BR_UART_S2_LBKDE(x)  (BITBAND_ACCESS8(HW_UART_S2_ADDR(x), BP_UART_S2_LBKDE))

/*! @brief Format value for bitfield UART_S2_LBKDE. */
#define BF_UART_S2_LBKDE(v)  ((uint8_t)((uint8_t)(v) << BP_UART_S2_LBKDE) & BM_UART_S2_LBKDE)

/*! @brief Set the LBKDE field to a new value. */
#define BW_UART_S2_LBKDE(x, v) (BITBAND_ACCESS8(HW_UART_S2_ADDR(x), BP_UART_S2_LBKDE) = (v))
/*@}*/

/*!
 * @name Register UART_S2, field BRK13[2] (RW)
 *
 * This bit determines whether the transmit break character is 10, 11, or 12
 * bits long, or 13 or 14 bits long. Refer to Transmitting break characters for the
 * length of the break character for the different configurations. The detection
 * of a framing error is not affected by this bit.
 *
 * Values:
 * - 0 - Break character is 10, 11, or 12 bits long.
 * - 1 - Break character is 13 or 14 bits long.
 */
/*@{*/
#define BP_UART_S2_BRK13     (2U)          /*!< Bit position for UART_S2_BRK13. */
#define BM_UART_S2_BRK13     (0x04U)       /*!< Bit mask for UART_S2_BRK13. */
#define BS_UART_S2_BRK13     (1U)          /*!< Bit field size in bits for UART_S2_BRK13. */

/*! @brief Read current value of the UART_S2_BRK13 field. */
#define BR_UART_S2_BRK13(x)  (BITBAND_ACCESS8(HW_UART_S2_ADDR(x), BP_UART_S2_BRK13))

/*! @brief Format value for bitfield UART_S2_BRK13. */
#define BF_UART_S2_BRK13(v)  ((uint8_t)((uint8_t)(v) << BP_UART_S2_BRK13) & BM_UART_S2_BRK13)

/*! @brief Set the BRK13 field to a new value. */
#define BW_UART_S2_BRK13(x, v) (BITBAND_ACCESS8(HW_UART_S2_ADDR(x), BP_UART_S2_BRK13) = (v))
/*@}*/

/*!
 * @name Register UART_S2, field RWUID[3] (RW)
 *
 * When RWU is set and WAKE is cleared, this bit controls whether the idle
 * character that wakes the receiver sets the S1[IDLE] bit.This bit must be cleared
 * when C7816[ISO7816E] is set/enabled.
 *
 * Values:
 * - 0 - The S1[IDLE] bit is not set upon detection of an idle character.
 * - 1 - The S1[IDLE] bit is set upon detection of an idle character.
 */
/*@{*/
#define BP_UART_S2_RWUID     (3U)          /*!< Bit position for UART_S2_RWUID. */
#define BM_UART_S2_RWUID     (0x08U)       /*!< Bit mask for UART_S2_RWUID. */
#define BS_UART_S2_RWUID     (1U)          /*!< Bit field size in bits for UART_S2_RWUID. */

/*! @brief Read current value of the UART_S2_RWUID field. */
#define BR_UART_S2_RWUID(x)  (BITBAND_ACCESS8(HW_UART_S2_ADDR(x), BP_UART_S2_RWUID))

/*! @brief Format value for bitfield UART_S2_RWUID. */
#define BF_UART_S2_RWUID(v)  ((uint8_t)((uint8_t)(v) << BP_UART_S2_RWUID) & BM_UART_S2_RWUID)

/*! @brief Set the RWUID field to a new value. */
#define BW_UART_S2_RWUID(x, v) (BITBAND_ACCESS8(HW_UART_S2_ADDR(x), BP_UART_S2_RWUID) = (v))
/*@}*/

/*!
 * @name Register UART_S2, field RXINV[4] (RW)
 *
 * Setting this bit, reverses the polarity of the received data input. In NRZ
 * format, a one is represented by a mark and a zero is represented by a space for
 * normal polarity, and the opposite for inverted polarity. In IrDA format, a
 * zero is represented by short high pulse in the middle of a bit time remaining
 * idle low for a one for normal polarity, and a zero is represented by short low
 * pulse in the middle of a bit time remaining idle high for a one for inverted
 * polarity. This bit is automatically set or cleared when C7816[INIT] and
 * C7816[ISO7816E] are enabled and an initial character is detected. In EN709 mode, this
 * bit affects the polarity of bits the same as it does in normal mode. Setting
 * RXINV inverts the RxD input for: data bits, start and stop bits, break, and
 * idle. When C7816[ISO7816E] is set/enabled then only the data bits and the parity
 * bit are inverted.
 *
 * Values:
 * - 0 - Receive data is not inverted.
 * - 1 - Receive data is inverted.
 */
/*@{*/
#define BP_UART_S2_RXINV     (4U)          /*!< Bit position for UART_S2_RXINV. */
#define BM_UART_S2_RXINV     (0x10U)       /*!< Bit mask for UART_S2_RXINV. */
#define BS_UART_S2_RXINV     (1U)          /*!< Bit field size in bits for UART_S2_RXINV. */

/*! @brief Read current value of the UART_S2_RXINV field. */
#define BR_UART_S2_RXINV(x)  (BITBAND_ACCESS8(HW_UART_S2_ADDR(x), BP_UART_S2_RXINV))

/*! @brief Format value for bitfield UART_S2_RXINV. */
#define BF_UART_S2_RXINV(v)  ((uint8_t)((uint8_t)(v) << BP_UART_S2_RXINV) & BM_UART_S2_RXINV)

/*! @brief Set the RXINV field to a new value. */
#define BW_UART_S2_RXINV(x, v) (BITBAND_ACCESS8(HW_UART_S2_ADDR(x), BP_UART_S2_RXINV) = (v))
/*@}*/

/*!
 * @name Register UART_S2, field MSBF[5] (RW)
 *
 * Setting this bit reverses the order of the bits that are transmitted and
 * received on the wire. This bit does not affect the polarity of the bits, the
 * location of the parity bit or the location of the start or stop bits.This bit is
 * automatically set or cleared when C7816[INIT] and C7816[ISO7816E] are enabled
 * and an initial character is detected. In EN709 mode, this bit affects the order
 * of bits the same way as it does in normal mode.
 *
 * Values:
 * - 0 - LSB (bit0) is the first bit that is transmitted following the start
 *     bit. Further, the first bit received after the start bit is identified as
 *     bit0.
 * - 1 - MSB (bit8, bit7 or bit6) is the first bit that is transmitted following
 *     the start bit depending on the setting of C1[M] and C1[PE]. Further, the
 *     first bit received after the start bit is identified as bit8, bit7 or bit6
 *     depending on the setting of C1[M] and C1[PE].
 */
/*@{*/
#define BP_UART_S2_MSBF      (5U)          /*!< Bit position for UART_S2_MSBF. */
#define BM_UART_S2_MSBF      (0x20U)       /*!< Bit mask for UART_S2_MSBF. */
#define BS_UART_S2_MSBF      (1U)          /*!< Bit field size in bits for UART_S2_MSBF. */

/*! @brief Read current value of the UART_S2_MSBF field. */
#define BR_UART_S2_MSBF(x)   (BITBAND_ACCESS8(HW_UART_S2_ADDR(x), BP_UART_S2_MSBF))

/*! @brief Format value for bitfield UART_S2_MSBF. */
#define BF_UART_S2_MSBF(v)   ((uint8_t)((uint8_t)(v) << BP_UART_S2_MSBF) & BM_UART_S2_MSBF)

/*! @brief Set the MSBF field to a new value. */
#define BW_UART_S2_MSBF(x, v) (BITBAND_ACCESS8(HW_UART_S2_ADDR(x), BP_UART_S2_MSBF) = (v))
/*@}*/

/*!
 * @name Register UART_S2, field RXEDGIF[6] (RW)
 *
 * RXEDGIF is set when an active edge (falling if RXINV = 0, rising if RXINV=1)
 * on the RxD pin occurs. RXEDGIF is cleared by writing a 1 to it. See RXEDGIF
 * description for additional details. The active edge is only detected when in two
 * wire mode and on receive data coming from the RxD pin.
 *
 * Values:
 * - 0 - No active edge on the receive pin has occurred.
 * - 1 - An active edge on the receive pin has occurred.
 */
/*@{*/
#define BP_UART_S2_RXEDGIF   (6U)          /*!< Bit position for UART_S2_RXEDGIF. */
#define BM_UART_S2_RXEDGIF   (0x40U)       /*!< Bit mask for UART_S2_RXEDGIF. */
#define BS_UART_S2_RXEDGIF   (1U)          /*!< Bit field size in bits for UART_S2_RXEDGIF. */

/*! @brief Read current value of the UART_S2_RXEDGIF field. */
#define BR_UART_S2_RXEDGIF(x) (BITBAND_ACCESS8(HW_UART_S2_ADDR(x), BP_UART_S2_RXEDGIF))

/*! @brief Format value for bitfield UART_S2_RXEDGIF. */
#define BF_UART_S2_RXEDGIF(v) ((uint8_t)((uint8_t)(v) << BP_UART_S2_RXEDGIF) & BM_UART_S2_RXEDGIF)

/*! @brief Set the RXEDGIF field to a new value. */
#define BW_UART_S2_RXEDGIF(x, v) (BITBAND_ACCESS8(HW_UART_S2_ADDR(x), BP_UART_S2_RXEDGIF) = (v))
/*@}*/

/*!
 * @name Register UART_S2, field LBKDIF[7] (RW)
 *
 * LBKDIF is set when LBKDE is set and a LIN break character is detected, when
 * 11 consecutive logic 0s (if C1[M] = 0) or 12 consecutive logic 0s (if C1[M] =
 * 1) appear on the receiver input. LBKDIF is set right after receiving the last
 * LIN break character bit. LBKDIF is cleared by writing a 1 to it.
 *
 * Values:
 * - 0 - No LIN break character has been detected.
 * - 1 - LIN break character has been detected.
 */
/*@{*/
#define BP_UART_S2_LBKDIF    (7U)          /*!< Bit position for UART_S2_LBKDIF. */
#define BM_UART_S2_LBKDIF    (0x80U)       /*!< Bit mask for UART_S2_LBKDIF. */
#define BS_UART_S2_LBKDIF    (1U)          /*!< Bit field size in bits for UART_S2_LBKDIF. */

/*! @brief Read current value of the UART_S2_LBKDIF field. */
#define BR_UART_S2_LBKDIF(x) (BITBAND_ACCESS8(HW_UART_S2_ADDR(x), BP_UART_S2_LBKDIF))

/*! @brief Format value for bitfield UART_S2_LBKDIF. */
#define BF_UART_S2_LBKDIF(v) ((uint8_t)((uint8_t)(v) << BP_UART_S2_LBKDIF) & BM_UART_S2_LBKDIF)

/*! @brief Set the LBKDIF field to a new value. */
#define BW_UART_S2_LBKDIF(x, v) (BITBAND_ACCESS8(HW_UART_S2_ADDR(x), BP_UART_S2_LBKDIF) = (v))
/*@}*/

/*******************************************************************************
 * HW_UART_C3 - UART Control Register 3
 ******************************************************************************/

/*!
 * @brief HW_UART_C3 - UART Control Register 3 (RW)
 *
 * Reset value: 0x00U
 *
 * Writing to R8 bit does not have any effect. The TXDIR and TXINV bits can only
 * be changed between transmit and receive packets.
 */
typedef union _hw_uart_c3
{
    uint8_t U;
    struct _hw_uart_c3_bitfields
    {
        uint8_t PEIE : 1;              /*!< [0] Parity Error Interrupt Enable */
        uint8_t FEIE : 1;              /*!< [1] Framing Error Interrupt Enable */
        uint8_t NEIE : 1;              /*!< [2] Noise Error Interrupt Enable */
        uint8_t ORIE : 1;              /*!< [3] Overrun Error Interrupt Enable */
        uint8_t TXINV : 1;             /*!< [4] Transmit Data Inversion. */
        uint8_t TXDIR : 1;             /*!< [5] Transmitter Pin Data Direction in
                                        * Single-Wire mode */
        uint8_t T8 : 1;                /*!< [6] Transmit Bit 8 */
        uint8_t R8 : 1;                /*!< [7] Received Bit 8 */
    } B;
} hw_uart_c3_t;

/*!
 * @name Constants and macros for entire UART_C3 register
 */
/*@{*/
#define HW_UART_C3_ADDR(x)       ((x) + 0x6U)

#define HW_UART_C3(x)            (*(__IO hw_uart_c3_t *) HW_UART_C3_ADDR(x))
#define HW_UART_C3_RD(x)         (HW_UART_C3(x).U)
#define HW_UART_C3_WR(x, v)      (HW_UART_C3(x).U = (v))
#define HW_UART_C3_SET(x, v)     (HW_UART_C3_WR(x, HW_UART_C3_RD(x) |  (v)))
#define HW_UART_C3_CLR(x, v)     (HW_UART_C3_WR(x, HW_UART_C3_RD(x) & ~(v)))
#define HW_UART_C3_TOG(x, v)     (HW_UART_C3_WR(x, HW_UART_C3_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual UART_C3 bitfields
 */

/*!
 * @name Register UART_C3, field PEIE[0] (RW)
 *
 * This bit enables the parity error flag (S1[PF]) to generate interrupt
 * requests.
 *
 * Values:
 * - 0 - PF interrupt requests are disabled.
 * - 1 - PF interrupt requests are enabled.
 */
/*@{*/
#define BP_UART_C3_PEIE      (0U)          /*!< Bit position for UART_C3_PEIE. */
#define BM_UART_C3_PEIE      (0x01U)       /*!< Bit mask for UART_C3_PEIE. */
#define BS_UART_C3_PEIE      (1U)          /*!< Bit field size in bits for UART_C3_PEIE. */

/*! @brief Read current value of the UART_C3_PEIE field. */
#define BR_UART_C3_PEIE(x)   (BITBAND_ACCESS8(HW_UART_C3_ADDR(x), BP_UART_C3_PEIE))

/*! @brief Format value for bitfield UART_C3_PEIE. */
#define BF_UART_C3_PEIE(v)   ((uint8_t)((uint8_t)(v) << BP_UART_C3_PEIE) & BM_UART_C3_PEIE)

/*! @brief Set the PEIE field to a new value. */
#define BW_UART_C3_PEIE(x, v) (BITBAND_ACCESS8(HW_UART_C3_ADDR(x), BP_UART_C3_PEIE) = (v))
/*@}*/

/*!
 * @name Register UART_C3, field FEIE[1] (RW)
 *
 * This bit enables the framing error flag (S1[FE]) to generate interrupt
 * requests.
 *
 * Values:
 * - 0 - FE interrupt requests are disabled.
 * - 1 - FE interrupt requests are enabled.
 */
/*@{*/
#define BP_UART_C3_FEIE      (1U)          /*!< Bit position for UART_C3_FEIE. */
#define BM_UART_C3_FEIE      (0x02U)       /*!< Bit mask for UART_C3_FEIE. */
#define BS_UART_C3_FEIE      (1U)          /*!< Bit field size in bits for UART_C3_FEIE. */

/*! @brief Read current value of the UART_C3_FEIE field. */
#define BR_UART_C3_FEIE(x)   (BITBAND_ACCESS8(HW_UART_C3_ADDR(x), BP_UART_C3_FEIE))

/*! @brief Format value for bitfield UART_C3_FEIE. */
#define BF_UART_C3_FEIE(v)   ((uint8_t)((uint8_t)(v) << BP_UART_C3_FEIE) & BM_UART_C3_FEIE)

/*! @brief Set the FEIE field to a new value. */
#define BW_UART_C3_FEIE(x, v) (BITBAND_ACCESS8(HW_UART_C3_ADDR(x), BP_UART_C3_FEIE) = (v))
/*@}*/

/*!
 * @name Register UART_C3, field NEIE[2] (RW)
 *
 * This bit enables the noise flag (S1[NF]) to generate interrupt requests.
 *
 * Values:
 * - 0 - NF interrupt requests are disabled.
 * - 1 - NF interrupt requests are enabled.
 */
/*@{*/
#define BP_UART_C3_NEIE      (2U)          /*!< Bit position for UART_C3_NEIE. */
#define BM_UART_C3_NEIE      (0x04U)       /*!< Bit mask for UART_C3_NEIE. */
#define BS_UART_C3_NEIE      (1U)          /*!< Bit field size in bits for UART_C3_NEIE. */

/*! @brief Read current value of the UART_C3_NEIE field. */
#define BR_UART_C3_NEIE(x)   (BITBAND_ACCESS8(HW_UART_C3_ADDR(x), BP_UART_C3_NEIE))

/*! @brief Format value for bitfield UART_C3_NEIE. */
#define BF_UART_C3_NEIE(v)   ((uint8_t)((uint8_t)(v) << BP_UART_C3_NEIE) & BM_UART_C3_NEIE)

/*! @brief Set the NEIE field to a new value. */
#define BW_UART_C3_NEIE(x, v) (BITBAND_ACCESS8(HW_UART_C3_ADDR(x), BP_UART_C3_NEIE) = (v))
/*@}*/

/*!
 * @name Register UART_C3, field ORIE[3] (RW)
 *
 * This bit enables the overrun error flag (S1[OR]) to generate interrupt
 * requests.
 *
 * Values:
 * - 0 - OR interrupts are disabled.
 * - 1 - OR interrupt requests are enabled.
 */
/*@{*/
#define BP_UART_C3_ORIE      (3U)          /*!< Bit position for UART_C3_ORIE. */
#define BM_UART_C3_ORIE      (0x08U)       /*!< Bit mask for UART_C3_ORIE. */
#define BS_UART_C3_ORIE      (1U)          /*!< Bit field size in bits for UART_C3_ORIE. */

/*! @brief Read current value of the UART_C3_ORIE field. */
#define BR_UART_C3_ORIE(x)   (BITBAND_ACCESS8(HW_UART_C3_ADDR(x), BP_UART_C3_ORIE))

/*! @brief Format value for bitfield UART_C3_ORIE. */
#define BF_UART_C3_ORIE(v)   ((uint8_t)((uint8_t)(v) << BP_UART_C3_ORIE) & BM_UART_C3_ORIE)

/*! @brief Set the ORIE field to a new value. */
#define BW_UART_C3_ORIE(x, v) (BITBAND_ACCESS8(HW_UART_C3_ADDR(x), BP_UART_C3_ORIE) = (v))
/*@}*/

/*!
 * @name Register UART_C3, field TXINV[4] (RW)
 *
 * Setting this bit reverses the polarity of the transmitted data output. In NRZ
 * format, a one is represented by a mark and a zero is represented by a space
 * for normal polarity, and the opposite for inverted polarity. In IrDA format, a
 * zero is represented by short high pulse in the middle of a bit time remaining
 * idle low for a one for normal polarity, and a zero is represented by short low
 * pulse in the middle of a bit time remaining idle high for a one for inverted
 * polarity. This bit is automatically set or cleared when C7816[INIT] and
 * C7816[ISO7816E] are enabled and an initial character is detected. Setting TXINV
 * inverts all transmitted values, including idle, break, start, and stop bits. In
 * loop mode, if TXINV is set, the receiver gets the transmit inversion bit when
 * RXINV is disabled.When C7816[ISO7816E] is set/enabled then only the transmitted
 * data bits and parity bit are inverted.
 *
 * Values:
 * - 0 - Transmit data is not inverted.
 * - 1 - Transmit data is inverted.
 */
/*@{*/
#define BP_UART_C3_TXINV     (4U)          /*!< Bit position for UART_C3_TXINV. */
#define BM_UART_C3_TXINV     (0x10U)       /*!< Bit mask for UART_C3_TXINV. */
#define BS_UART_C3_TXINV     (1U)          /*!< Bit field size in bits for UART_C3_TXINV. */

/*! @brief Read current value of the UART_C3_TXINV field. */
#define BR_UART_C3_TXINV(x)  (BITBAND_ACCESS8(HW_UART_C3_ADDR(x), BP_UART_C3_TXINV))

/*! @brief Format value for bitfield UART_C3_TXINV. */
#define BF_UART_C3_TXINV(v)  ((uint8_t)((uint8_t)(v) << BP_UART_C3_TXINV) & BM_UART_C3_TXINV)

/*! @brief Set the TXINV field to a new value. */
#define BW_UART_C3_TXINV(x, v) (BITBAND_ACCESS8(HW_UART_C3_ADDR(x), BP_UART_C3_TXINV) = (v))
/*@}*/

/*!
 * @name Register UART_C3, field TXDIR[5] (RW)
 *
 * This bit determines whether the TXD pin is used as an input or output in the
 * single-wire mode of operation. This bit is relevant only to the single-wire
 * mode. When C7816[ISO7816E] is set/enabled and C7816[TTYPE] = 1, this bit is
 * automatically cleared after the requested block has been transmitted. This
 * condition is detected when TL7816[TLEN] = 0 and 4 additional characters have been
 * transmitted. Additionally, if C7816[ISO7816E] is set/enabled and C7816[TTYPE] = 0
 * and a NACK is being transmitted, the hardware will automatically override
 * this bit as needed. In this situation TXDIR will not reflect the temporary state
 * associated with the NACK.
 *
 * Values:
 * - 0 - TXD pin is an input in single-wire mode.
 * - 1 - TXD pin is an output in single-wire mode.
 */
/*@{*/
#define BP_UART_C3_TXDIR     (5U)          /*!< Bit position for UART_C3_TXDIR. */
#define BM_UART_C3_TXDIR     (0x20U)       /*!< Bit mask for UART_C3_TXDIR. */
#define BS_UART_C3_TXDIR     (1U)          /*!< Bit field size in bits for UART_C3_TXDIR. */

/*! @brief Read current value of the UART_C3_TXDIR field. */
#define BR_UART_C3_TXDIR(x)  (BITBAND_ACCESS8(HW_UART_C3_ADDR(x), BP_UART_C3_TXDIR))

/*! @brief Format value for bitfield UART_C3_TXDIR. */
#define BF_UART_C3_TXDIR(v)  ((uint8_t)((uint8_t)(v) << BP_UART_C3_TXDIR) & BM_UART_C3_TXDIR)

/*! @brief Set the TXDIR field to a new value. */
#define BW_UART_C3_TXDIR(x, v) (BITBAND_ACCESS8(HW_UART_C3_ADDR(x), BP_UART_C3_TXDIR) = (v))
/*@}*/

/*!
 * @name Register UART_C3, field T8[6] (RW)
 *
 * T8 is the ninth data bit transmitted when the UART is configured for 9-bit
 * data format (C1[M] = 1) or (C4[M10] = 1). If the value of T8 is the same as in
 * the previous transmission, T8 does not have to be rewritten. The same value is
 * transmitted until T8 is rewritten.
 */
/*@{*/
#define BP_UART_C3_T8        (6U)          /*!< Bit position for UART_C3_T8. */
#define BM_UART_C3_T8        (0x40U)       /*!< Bit mask for UART_C3_T8. */
#define BS_UART_C3_T8        (1U)          /*!< Bit field size in bits for UART_C3_T8. */

/*! @brief Read current value of the UART_C3_T8 field. */
#define BR_UART_C3_T8(x)     (BITBAND_ACCESS8(HW_UART_C3_ADDR(x), BP_UART_C3_T8))

/*! @brief Format value for bitfield UART_C3_T8. */
#define BF_UART_C3_T8(v)     ((uint8_t)((uint8_t)(v) << BP_UART_C3_T8) & BM_UART_C3_T8)

/*! @brief Set the T8 field to a new value. */
#define BW_UART_C3_T8(x, v)  (BITBAND_ACCESS8(HW_UART_C3_ADDR(x), BP_UART_C3_T8) = (v))
/*@}*/

/*!
 * @name Register UART_C3, field R8[7] (RO)
 *
 * R8 is the ninth data bit received when the UART is configured for 9-bit data
 * format (C1[M] = 1) or (C4[M10] = 1).
 */
/*@{*/
#define BP_UART_C3_R8        (7U)          /*!< Bit position for UART_C3_R8. */
#define BM_UART_C3_R8        (0x80U)       /*!< Bit mask for UART_C3_R8. */
#define BS_UART_C3_R8        (1U)          /*!< Bit field size in bits for UART_C3_R8. */

/*! @brief Read current value of the UART_C3_R8 field. */
#define BR_UART_C3_R8(x)     (BITBAND_ACCESS8(HW_UART_C3_ADDR(x), BP_UART_C3_R8))
/*@}*/

/*******************************************************************************
 * HW_UART_D - UART Data Register
 ******************************************************************************/

/*!
 * @brief HW_UART_D - UART Data Register (RW)
 *
 * Reset value: 0x00U
 *
 * This register is actually two separate registers. Reads return the contents
 * of the read-only receive data register and writes go to the write-only transmit
 * data register. In 8-bit or 9-bit data format, only UART data register (D)
 * needs to be accessed in order to clear the S1[RDRF] bit (assuming receiver buffer
 * level is less than RWFIFO[RXWATER]). The C3 register only needs to be read
 * (prior to the D register) if the ninth bit of data needs to be captured.
 * Likewise the ED register only needs to be read (prior to the D register) if the
 * additional flag data for the dataword needs to be captured. In the normal 8-bit
 * mode (M bit cleared) if the parity is enabled, you get seven data bits and one
 * parity bit. That one parity bit will be loaded into the D register. So if you
 * care about only the data bits, you have to mask off the parity bit from the
 * value you read out of this register. When transmitting in 9-bit data format and
 * using 8-bit write instructions, write first to transmit bit 8 in UART control
 * register 3 (C3[T8]), then D. A write to C3[T8] stores the data in a temporary
 * register. If D register is written first then the new data on data bus is stored
 * in D register, while the temporary value (written by last write to C3[T8])
 * gets stored in C3[T8] register.
 */
typedef union _hw_uart_d
{
    uint8_t U;
    struct _hw_uart_d_bitfields
    {
        uint8_t RT : 8;                /*!< [7:0]  */
    } B;
} hw_uart_d_t;

/*!
 * @name Constants and macros for entire UART_D register
 */
/*@{*/
#define HW_UART_D_ADDR(x)        ((x) + 0x7U)

#define HW_UART_D(x)             (*(__IO hw_uart_d_t *) HW_UART_D_ADDR(x))
#define HW_UART_D_RD(x)          (HW_UART_D(x).U)
#define HW_UART_D_WR(x, v)       (HW_UART_D(x).U = (v))
#define HW_UART_D_SET(x, v)      (HW_UART_D_WR(x, HW_UART_D_RD(x) |  (v)))
#define HW_UART_D_CLR(x, v)      (HW_UART_D_WR(x, HW_UART_D_RD(x) & ~(v)))
#define HW_UART_D_TOG(x, v)      (HW_UART_D_WR(x, HW_UART_D_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual UART_D bitfields
 */

/*!
 * @name Register UART_D, field RT[7:0] (RW)
 *
 * Reads return the contents of the read-only receive data register and writes
 * go to the write-only transmit data register.
 */
/*@{*/
#define BP_UART_D_RT         (0U)          /*!< Bit position for UART_D_RT. */
#define BM_UART_D_RT         (0xFFU)       /*!< Bit mask for UART_D_RT. */
#define BS_UART_D_RT         (8U)          /*!< Bit field size in bits for UART_D_RT. */

/*! @brief Read current value of the UART_D_RT field. */
#define BR_UART_D_RT(x)      (HW_UART_D(x).U)

/*! @brief Format value for bitfield UART_D_RT. */
#define BF_UART_D_RT(v)      ((uint8_t)((uint8_t)(v) << BP_UART_D_RT) & BM_UART_D_RT)

/*! @brief Set the RT field to a new value. */
#define BW_UART_D_RT(x, v)   (HW_UART_D_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_UART_MA1 - UART Match Address Registers 1
 ******************************************************************************/

/*!
 * @brief HW_UART_MA1 - UART Match Address Registers 1 (RW)
 *
 * Reset value: 0x00U
 *
 * The MA1 and MA2 registers are compared to input data addresses when the most
 * significant bit is set and the associated C4[MAEN] bit is set. If a match
 * occurs, the following data is transferred to the data register. If a match fails,
 * the following data is discarded. These registers can be read and written at
 * anytime.
 */
typedef union _hw_uart_ma1
{
    uint8_t U;
    struct _hw_uart_ma1_bitfields
    {
        uint8_t MA : 8;                /*!< [7:0] Match Address */
    } B;
} hw_uart_ma1_t;

/*!
 * @name Constants and macros for entire UART_MA1 register
 */
/*@{*/
#define HW_UART_MA1_ADDR(x)      ((x) + 0x8U)

#define HW_UART_MA1(x)           (*(__IO hw_uart_ma1_t *) HW_UART_MA1_ADDR(x))
#define HW_UART_MA1_RD(x)        (HW_UART_MA1(x).U)
#define HW_UART_MA1_WR(x, v)     (HW_UART_MA1(x).U = (v))
#define HW_UART_MA1_SET(x, v)    (HW_UART_MA1_WR(x, HW_UART_MA1_RD(x) |  (v)))
#define HW_UART_MA1_CLR(x, v)    (HW_UART_MA1_WR(x, HW_UART_MA1_RD(x) & ~(v)))
#define HW_UART_MA1_TOG(x, v)    (HW_UART_MA1_WR(x, HW_UART_MA1_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual UART_MA1 bitfields
 */

/*!
 * @name Register UART_MA1, field MA[7:0] (RW)
 */
/*@{*/
#define BP_UART_MA1_MA       (0U)          /*!< Bit position for UART_MA1_MA. */
#define BM_UART_MA1_MA       (0xFFU)       /*!< Bit mask for UART_MA1_MA. */
#define BS_UART_MA1_MA       (8U)          /*!< Bit field size in bits for UART_MA1_MA. */

/*! @brief Read current value of the UART_MA1_MA field. */
#define BR_UART_MA1_MA(x)    (HW_UART_MA1(x).U)

/*! @brief Format value for bitfield UART_MA1_MA. */
#define BF_UART_MA1_MA(v)    ((uint8_t)((uint8_t)(v) << BP_UART_MA1_MA) & BM_UART_MA1_MA)

/*! @brief Set the MA field to a new value. */
#define BW_UART_MA1_MA(x, v) (HW_UART_MA1_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_UART_MA2 - UART Match Address Registers 2
 ******************************************************************************/

/*!
 * @brief HW_UART_MA2 - UART Match Address Registers 2 (RW)
 *
 * Reset value: 0x00U
 *
 * These registers can be read and written at anytime. The MA1 and MA2 registers
 * are compared to input data addresses when the most significant bit is set and
 * the associated C4[MAEN] bit is set. If a match occurs, the following data is
 * transferred to the data register. If a match fails, the following data is
 * discarded.
 */
typedef union _hw_uart_ma2
{
    uint8_t U;
    struct _hw_uart_ma2_bitfields
    {
        uint8_t MA : 8;                /*!< [7:0] Match Address */
    } B;
} hw_uart_ma2_t;

/*!
 * @name Constants and macros for entire UART_MA2 register
 */
/*@{*/
#define HW_UART_MA2_ADDR(x)      ((x) + 0x9U)

#define HW_UART_MA2(x)           (*(__IO hw_uart_ma2_t *) HW_UART_MA2_ADDR(x))
#define HW_UART_MA2_RD(x)        (HW_UART_MA2(x).U)
#define HW_UART_MA2_WR(x, v)     (HW_UART_MA2(x).U = (v))
#define HW_UART_MA2_SET(x, v)    (HW_UART_MA2_WR(x, HW_UART_MA2_RD(x) |  (v)))
#define HW_UART_MA2_CLR(x, v)    (HW_UART_MA2_WR(x, HW_UART_MA2_RD(x) & ~(v)))
#define HW_UART_MA2_TOG(x, v)    (HW_UART_MA2_WR(x, HW_UART_MA2_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual UART_MA2 bitfields
 */

/*!
 * @name Register UART_MA2, field MA[7:0] (RW)
 */
/*@{*/
#define BP_UART_MA2_MA       (0U)          /*!< Bit position for UART_MA2_MA. */
#define BM_UART_MA2_MA       (0xFFU)       /*!< Bit mask for UART_MA2_MA. */
#define BS_UART_MA2_MA       (8U)          /*!< Bit field size in bits for UART_MA2_MA. */

/*! @brief Read current value of the UART_MA2_MA field. */
#define BR_UART_MA2_MA(x)    (HW_UART_MA2(x).U)

/*! @brief Format value for bitfield UART_MA2_MA. */
#define BF_UART_MA2_MA(v)    ((uint8_t)((uint8_t)(v) << BP_UART_MA2_MA) & BM_UART_MA2_MA)

/*! @brief Set the MA field to a new value. */
#define BW_UART_MA2_MA(x, v) (HW_UART_MA2_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_UART_C4 - UART Control Register 4
 ******************************************************************************/

/*!
 * @brief HW_UART_C4 - UART Control Register 4 (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_uart_c4
{
    uint8_t U;
    struct _hw_uart_c4_bitfields
    {
        uint8_t BRFA : 5;              /*!< [4:0] Baud Rate Fine Adjust */
        uint8_t M10 : 1;               /*!< [5] 10-bit Mode select */
        uint8_t MAEN2 : 1;             /*!< [6] Match Address Mode Enable 2 */
        uint8_t MAEN1 : 1;             /*!< [7] Match Address Mode Enable 1 */
    } B;
} hw_uart_c4_t;

/*!
 * @name Constants and macros for entire UART_C4 register
 */
/*@{*/
#define HW_UART_C4_ADDR(x)       ((x) + 0xAU)

#define HW_UART_C4(x)            (*(__IO hw_uart_c4_t *) HW_UART_C4_ADDR(x))
#define HW_UART_C4_RD(x)         (HW_UART_C4(x).U)
#define HW_UART_C4_WR(x, v)      (HW_UART_C4(x).U = (v))
#define HW_UART_C4_SET(x, v)     (HW_UART_C4_WR(x, HW_UART_C4_RD(x) |  (v)))
#define HW_UART_C4_CLR(x, v)     (HW_UART_C4_WR(x, HW_UART_C4_RD(x) & ~(v)))
#define HW_UART_C4_TOG(x, v)     (HW_UART_C4_WR(x, HW_UART_C4_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual UART_C4 bitfields
 */

/*!
 * @name Register UART_C4, field BRFA[4:0] (RW)
 *
 * This bit field is used to add more timing resolution to the average baud
 * frequency, in increments of 1/32. Refer to Baud rate generation for more
 * information.
 */
/*@{*/
#define BP_UART_C4_BRFA      (0U)          /*!< Bit position for UART_C4_BRFA. */
#define BM_UART_C4_BRFA      (0x1FU)       /*!< Bit mask for UART_C4_BRFA. */
#define BS_UART_C4_BRFA      (5U)          /*!< Bit field size in bits for UART_C4_BRFA. */

/*! @brief Read current value of the UART_C4_BRFA field. */
#define BR_UART_C4_BRFA(x)   (HW_UART_C4(x).B.BRFA)

/*! @brief Format value for bitfield UART_C4_BRFA. */
#define BF_UART_C4_BRFA(v)   ((uint8_t)((uint8_t)(v) << BP_UART_C4_BRFA) & BM_UART_C4_BRFA)

/*! @brief Set the BRFA field to a new value. */
#define BW_UART_C4_BRFA(x, v) (HW_UART_C4_WR(x, (HW_UART_C4_RD(x) & ~BM_UART_C4_BRFA) | BF_UART_C4_BRFA(v)))
/*@}*/

/*!
 * @name Register UART_C4, field M10[5] (RW)
 *
 * The M10 bit causes a tenth, non-memory mapped bit to be part of the serial
 * transmission. This tenth bit is generated and interpreted as a parity bit. The
 * M10 bit does not affect the LIN send or detect break behavior. If M10 is set
 * then both C1[M] and C1[PE] bits must also be set. This bit must be cleared when
 * C7816[ISO7816E] is set/enabled. Refer to Data format (non ISO-7816) for more
 * information.
 *
 * Values:
 * - 0 - The parity bit is the ninth bit in the serial transmission.
 * - 1 - The parity bit is the tenth bit in the serial transmission.
 */
/*@{*/
#define BP_UART_C4_M10       (5U)          /*!< Bit position for UART_C4_M10. */
#define BM_UART_C4_M10       (0x20U)       /*!< Bit mask for UART_C4_M10. */
#define BS_UART_C4_M10       (1U)          /*!< Bit field size in bits for UART_C4_M10. */

/*! @brief Read current value of the UART_C4_M10 field. */
#define BR_UART_C4_M10(x)    (BITBAND_ACCESS8(HW_UART_C4_ADDR(x), BP_UART_C4_M10))

/*! @brief Format value for bitfield UART_C4_M10. */
#define BF_UART_C4_M10(v)    ((uint8_t)((uint8_t)(v) << BP_UART_C4_M10) & BM_UART_C4_M10)

/*! @brief Set the M10 field to a new value. */
#define BW_UART_C4_M10(x, v) (BITBAND_ACCESS8(HW_UART_C4_ADDR(x), BP_UART_C4_M10) = (v))
/*@}*/

/*!
 * @name Register UART_C4, field MAEN2[6] (RW)
 *
 * Refer to Match address operation for more information.
 *
 * Values:
 * - 0 - All data received is transferred to the data buffer if MAEN1 is cleared.
 * - 1 - All data received with the most significant bit cleared, is discarded.
 *     All data received with the most significant bit set, is compared with
 *     contents of MA2 register. If no match occurs, the data is discarded. If match
 *     occurs, data is transferred to the data buffer.This bit must be cleared
 *     when C7816[ISO7816E] is set/enabled.
 */
/*@{*/
#define BP_UART_C4_MAEN2     (6U)          /*!< Bit position for UART_C4_MAEN2. */
#define BM_UART_C4_MAEN2     (0x40U)       /*!< Bit mask for UART_C4_MAEN2. */
#define BS_UART_C4_MAEN2     (1U)          /*!< Bit field size in bits for UART_C4_MAEN2. */

/*! @brief Read current value of the UART_C4_MAEN2 field. */
#define BR_UART_C4_MAEN2(x)  (BITBAND_ACCESS8(HW_UART_C4_ADDR(x), BP_UART_C4_MAEN2))

/*! @brief Format value for bitfield UART_C4_MAEN2. */
#define BF_UART_C4_MAEN2(v)  ((uint8_t)((uint8_t)(v) << BP_UART_C4_MAEN2) & BM_UART_C4_MAEN2)

/*! @brief Set the MAEN2 field to a new value. */
#define BW_UART_C4_MAEN2(x, v) (BITBAND_ACCESS8(HW_UART_C4_ADDR(x), BP_UART_C4_MAEN2) = (v))
/*@}*/

/*!
 * @name Register UART_C4, field MAEN1[7] (RW)
 *
 * Refer to Match address operation for more information.
 *
 * Values:
 * - 0 - All data received is transferred to the data buffer if MAEN2 is cleared.
 * - 1 - All data received with the most significant bit cleared, is discarded.
 *     All data received with the most significant bit set, is compared with
 *     contents of MA1 register. If no match occurs, the data is discarded. If match
 *     occurs, data is transferred to the data buffer.This bit must be cleared
 *     when C7816[ISO7816E] is set/enabled.
 */
/*@{*/
#define BP_UART_C4_MAEN1     (7U)          /*!< Bit position for UART_C4_MAEN1. */
#define BM_UART_C4_MAEN1     (0x80U)       /*!< Bit mask for UART_C4_MAEN1. */
#define BS_UART_C4_MAEN1     (1U)          /*!< Bit field size in bits for UART_C4_MAEN1. */

/*! @brief Read current value of the UART_C4_MAEN1 field. */
#define BR_UART_C4_MAEN1(x)  (BITBAND_ACCESS8(HW_UART_C4_ADDR(x), BP_UART_C4_MAEN1))

/*! @brief Format value for bitfield UART_C4_MAEN1. */
#define BF_UART_C4_MAEN1(v)  ((uint8_t)((uint8_t)(v) << BP_UART_C4_MAEN1) & BM_UART_C4_MAEN1)

/*! @brief Set the MAEN1 field to a new value. */
#define BW_UART_C4_MAEN1(x, v) (BITBAND_ACCESS8(HW_UART_C4_ADDR(x), BP_UART_C4_MAEN1) = (v))
/*@}*/

/*******************************************************************************
 * HW_UART_C5 - UART Control Register 5
 ******************************************************************************/

/*!
 * @brief HW_UART_C5 - UART Control Register 5 (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_uart_c5
{
    uint8_t U;
    struct _hw_uart_c5_bitfields
    {
        uint8_t RESERVED0 : 5;         /*!< [4:0]  */
        uint8_t RDMAS : 1;             /*!< [5] Receiver Full DMA Select */
        uint8_t RESERVED1 : 1;         /*!< [6]  */
        uint8_t TDMAS : 1;             /*!< [7] Transmitter DMA Select */
    } B;
} hw_uart_c5_t;

/*!
 * @name Constants and macros for entire UART_C5 register
 */
/*@{*/
#define HW_UART_C5_ADDR(x)       ((x) + 0xBU)

#define HW_UART_C5(x)            (*(__IO hw_uart_c5_t *) HW_UART_C5_ADDR(x))
#define HW_UART_C5_RD(x)         (HW_UART_C5(x).U)
#define HW_UART_C5_WR(x, v)      (HW_UART_C5(x).U = (v))
#define HW_UART_C5_SET(x, v)     (HW_UART_C5_WR(x, HW_UART_C5_RD(x) |  (v)))
#define HW_UART_C5_CLR(x, v)     (HW_UART_C5_WR(x, HW_UART_C5_RD(x) & ~(v)))
#define HW_UART_C5_TOG(x, v)     (HW_UART_C5_WR(x, HW_UART_C5_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual UART_C5 bitfields
 */

/*!
 * @name Register UART_C5, field RDMAS[5] (RW)
 *
 * RDMAS configures the receiver data register full flag, S1[RDRF], to generate
 * interrupt or DMA requests if C2[RIE] is set. If C2[RIE] is cleared, the RDRF
 * DMA and RDFR interrupt request signals are not asserted when the S1[RDRF] flag
 * is set, regardless of the state of RDMAS.
 *
 * Values:
 * - 0 - If C2[RIE] is set and the S1[RDRF] flag is set, the RDFR interrupt
 *     request signal is asserted to request interrupt service.
 * - 1 - If C2[RIE] is set and the S1[RDRF] flag is set, the RDRF DMA request
 *     signal is asserted to request a DMA transfer.
 */
/*@{*/
#define BP_UART_C5_RDMAS     (5U)          /*!< Bit position for UART_C5_RDMAS. */
#define BM_UART_C5_RDMAS     (0x20U)       /*!< Bit mask for UART_C5_RDMAS. */
#define BS_UART_C5_RDMAS     (1U)          /*!< Bit field size in bits for UART_C5_RDMAS. */

/*! @brief Read current value of the UART_C5_RDMAS field. */
#define BR_UART_C5_RDMAS(x)  (BITBAND_ACCESS8(HW_UART_C5_ADDR(x), BP_UART_C5_RDMAS))

/*! @brief Format value for bitfield UART_C5_RDMAS. */
#define BF_UART_C5_RDMAS(v)  ((uint8_t)((uint8_t)(v) << BP_UART_C5_RDMAS) & BM_UART_C5_RDMAS)

/*! @brief Set the RDMAS field to a new value. */
#define BW_UART_C5_RDMAS(x, v) (BITBAND_ACCESS8(HW_UART_C5_ADDR(x), BP_UART_C5_RDMAS) = (v))
/*@}*/

/*!
 * @name Register UART_C5, field TDMAS[7] (RW)
 *
 * TDMAS configures the transmit data register empty flag, S1[TDRE], to generate
 * interrupt or DMA requests if C2[TIE] is set. If C2[TIE] is cleared, TDRE DMA
 * and TDRE interrupt request signals are not asserted when the TDRE flag is set,
 * regardless of the state of TDMAS. If C2[TIE] and TDMAS are both set, then
 * C2[TCIE] must be cleared, and D register must not be written outside of servicing
 * of a DMA request.
 *
 * Values:
 * - 0 - If C2[TIE] is set and the S1[TDRE] flag is set, the TDRE interrupt
 *     request signal is asserted to request interrupt service.
 * - 1 - If C2[TIE] is set and the S1[TDRE] flag is set, the TDRE DMA request
 *     signal is asserted to request a DMA transfer.
 */
/*@{*/
#define BP_UART_C5_TDMAS     (7U)          /*!< Bit position for UART_C5_TDMAS. */
#define BM_UART_C5_TDMAS     (0x80U)       /*!< Bit mask for UART_C5_TDMAS. */
#define BS_UART_C5_TDMAS     (1U)          /*!< Bit field size in bits for UART_C5_TDMAS. */

/*! @brief Read current value of the UART_C5_TDMAS field. */
#define BR_UART_C5_TDMAS(x)  (BITBAND_ACCESS8(HW_UART_C5_ADDR(x), BP_UART_C5_TDMAS))

/*! @brief Format value for bitfield UART_C5_TDMAS. */
#define BF_UART_C5_TDMAS(v)  ((uint8_t)((uint8_t)(v) << BP_UART_C5_TDMAS) & BM_UART_C5_TDMAS)

/*! @brief Set the TDMAS field to a new value. */
#define BW_UART_C5_TDMAS(x, v) (BITBAND_ACCESS8(HW_UART_C5_ADDR(x), BP_UART_C5_TDMAS) = (v))
/*@}*/

/*******************************************************************************
 * HW_UART_ED - UART Extended Data Register
 ******************************************************************************/

/*!
 * @brief HW_UART_ED - UART Extended Data Register (RO)
 *
 * Reset value: 0x00U
 *
 * This register contains additional information flags that are stored with a
 * received dataword. This register may be read at any time but only contains valid
 * data if there is a dataword in the receive FIFO. The data contained in this
 * register represents additional information regarding the conditions on which a
 * dataword was received. The importance of this data varies with application,
 * and in some cases maybe completely optional. These fields automatically update
 * to reflect the conditions of the next dataword whenever D is read. If the
 * S1[NF] and S1[PF] flags have not been set since the last time the receive buffer
 * was empty, the NOISY and PARITYE bits will be zero.
 */
typedef union _hw_uart_ed
{
    uint8_t U;
    struct _hw_uart_ed_bitfields
    {
        uint8_t RESERVED0 : 6;         /*!< [5:0]  */
        uint8_t PARITYE : 1;           /*!< [6]  */
        uint8_t NOISY : 1;             /*!< [7]  */
    } B;
} hw_uart_ed_t;

/*!
 * @name Constants and macros for entire UART_ED register
 */
/*@{*/
#define HW_UART_ED_ADDR(x)       ((x) + 0xCU)

#define HW_UART_ED(x)            (*(__I hw_uart_ed_t *) HW_UART_ED_ADDR(x))
#define HW_UART_ED_RD(x)         (HW_UART_ED(x).U)
/*@}*/

/*
 * Constants & macros for individual UART_ED bitfields
 */

/*!
 * @name Register UART_ED, field PARITYE[6] (RO)
 *
 * The current received dataword contained in D and C3[R8] was received with a
 * parity error.
 *
 * Values:
 * - 0 - The dataword was received without a parity error.
 * - 1 - The dataword was received with a parity error.
 */
/*@{*/
#define BP_UART_ED_PARITYE   (6U)          /*!< Bit position for UART_ED_PARITYE. */
#define BM_UART_ED_PARITYE   (0x40U)       /*!< Bit mask for UART_ED_PARITYE. */
#define BS_UART_ED_PARITYE   (1U)          /*!< Bit field size in bits for UART_ED_PARITYE. */

/*! @brief Read current value of the UART_ED_PARITYE field. */
#define BR_UART_ED_PARITYE(x) (BITBAND_ACCESS8(HW_UART_ED_ADDR(x), BP_UART_ED_PARITYE))
/*@}*/

/*!
 * @name Register UART_ED, field NOISY[7] (RO)
 *
 * The current received dataword contained in D and C3[R8] was received with
 * noise.
 *
 * Values:
 * - 0 - The dataword was received without noise.
 * - 1 - The data was received with noise.
 */
/*@{*/
#define BP_UART_ED_NOISY     (7U)          /*!< Bit position for UART_ED_NOISY. */
#define BM_UART_ED_NOISY     (0x80U)       /*!< Bit mask for UART_ED_NOISY. */
#define BS_UART_ED_NOISY     (1U)          /*!< Bit field size in bits for UART_ED_NOISY. */

/*! @brief Read current value of the UART_ED_NOISY field. */
#define BR_UART_ED_NOISY(x)  (BITBAND_ACCESS8(HW_UART_ED_ADDR(x), BP_UART_ED_NOISY))
/*@}*/

/*******************************************************************************
 * HW_UART_MODEM - UART Modem Register
 ******************************************************************************/

/*!
 * @brief HW_UART_MODEM - UART Modem Register (RW)
 *
 * Reset value: 0x00U
 *
 * The MODEM register controls options for setting the modem configuration.
 * RXRTSE, TXRTSPOL, TXRTSE and TXCTSE must all be cleared when C7816[ISO7816EN] is
 * enabled. This will cause the RTS to deassert during ISO-7816 wait times. The
 * ISO-7816 protocol does not make use of the RTS and CTS signals.
 */
typedef union _hw_uart_modem
{
    uint8_t U;
    struct _hw_uart_modem_bitfields
    {
        uint8_t TXCTSE : 1;            /*!< [0] Transmitter clear-to-send enable */
        uint8_t TXRTSE : 1;            /*!< [1] Transmitter request-to-send enable */
        uint8_t TXRTSPOL : 1;          /*!< [2] Transmitter request-to-send polarity */
        uint8_t RXRTSE : 1;            /*!< [3] Receiver request-to-send enable */
        uint8_t RESERVED0 : 4;         /*!< [7:4]  */
    } B;
} hw_uart_modem_t;

/*!
 * @name Constants and macros for entire UART_MODEM register
 */
/*@{*/
#define HW_UART_MODEM_ADDR(x)    ((x) + 0xDU)

#define HW_UART_MODEM(x)         (*(__IO hw_uart_modem_t *) HW_UART_MODEM_ADDR(x))
#define HW_UART_MODEM_RD(x)      (HW_UART_MODEM(x).U)
#define HW_UART_MODEM_WR(x, v)   (HW_UART_MODEM(x).U = (v))
#define HW_UART_MODEM_SET(x, v)  (HW_UART_MODEM_WR(x, HW_UART_MODEM_RD(x) |  (v)))
#define HW_UART_MODEM_CLR(x, v)  (HW_UART_MODEM_WR(x, HW_UART_MODEM_RD(x) & ~(v)))
#define HW_UART_MODEM_TOG(x, v)  (HW_UART_MODEM_WR(x, HW_UART_MODEM_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual UART_MODEM bitfields
 */

/*!
 * @name Register UART_MODEM, field TXCTSE[0] (RW)
 *
 * TXCTSE controls the operation of the transmitter. TXCTSE can be set
 * independently from the state of TXRTSE and RXRTSE.
 *
 * Values:
 * - 0 - CTS has no effect on the transmitter.
 * - 1 - Enables clear-to-send operation. The transmitter checks the state of
 *     CTS each time it is ready to send a character. If CTS is asserted, the
 *     character is sent. If CTS is deasserted, the signal TXD remains in the mark
 *     state and transmission is delayed until CTS is asserted. Changes in CTS as a
 *     character is being sent do not affect its transmission.
 */
/*@{*/
#define BP_UART_MODEM_TXCTSE (0U)          /*!< Bit position for UART_MODEM_TXCTSE. */
#define BM_UART_MODEM_TXCTSE (0x01U)       /*!< Bit mask for UART_MODEM_TXCTSE. */
#define BS_UART_MODEM_TXCTSE (1U)          /*!< Bit field size in bits for UART_MODEM_TXCTSE. */

/*! @brief Read current value of the UART_MODEM_TXCTSE field. */
#define BR_UART_MODEM_TXCTSE(x) (BITBAND_ACCESS8(HW_UART_MODEM_ADDR(x), BP_UART_MODEM_TXCTSE))

/*! @brief Format value for bitfield UART_MODEM_TXCTSE. */
#define BF_UART_MODEM_TXCTSE(v) ((uint8_t)((uint8_t)(v) << BP_UART_MODEM_TXCTSE) & BM_UART_MODEM_TXCTSE)

/*! @brief Set the TXCTSE field to a new value. */
#define BW_UART_MODEM_TXCTSE(x, v) (BITBAND_ACCESS8(HW_UART_MODEM_ADDR(x), BP_UART_MODEM_TXCTSE) = (v))
/*@}*/

/*!
 * @name Register UART_MODEM, field TXRTSE[1] (RW)
 *
 * Controls RTS before and after a transmission.
 *
 * Values:
 * - 0 - The transmitter has no effect on RTS.
 * - 1 - When a character is placed into an empty transmitter data buffer(FIFO),
 *     RTS asserts one bit time before the start bit is transmitted. RTS
 *     deasserts one bit time after all characters in the transmitter data buffer(FIFO)
 *     and shift register are completely sent, including the last stop bit.
 */
/*@{*/
#define BP_UART_MODEM_TXRTSE (1U)          /*!< Bit position for UART_MODEM_TXRTSE. */
#define BM_UART_MODEM_TXRTSE (0x02U)       /*!< Bit mask for UART_MODEM_TXRTSE. */
#define BS_UART_MODEM_TXRTSE (1U)          /*!< Bit field size in bits for UART_MODEM_TXRTSE. */

/*! @brief Read current value of the UART_MODEM_TXRTSE field. */
#define BR_UART_MODEM_TXRTSE(x) (BITBAND_ACCESS8(HW_UART_MODEM_ADDR(x), BP_UART_MODEM_TXRTSE))

/*! @brief Format value for bitfield UART_MODEM_TXRTSE. */
#define BF_UART_MODEM_TXRTSE(v) ((uint8_t)((uint8_t)(v) << BP_UART_MODEM_TXRTSE) & BM_UART_MODEM_TXRTSE)

/*! @brief Set the TXRTSE field to a new value. */
#define BW_UART_MODEM_TXRTSE(x, v) (BITBAND_ACCESS8(HW_UART_MODEM_ADDR(x), BP_UART_MODEM_TXRTSE) = (v))
/*@}*/

/*!
 * @name Register UART_MODEM, field TXRTSPOL[2] (RW)
 *
 * Controls the polarity of the transmitter RTS. TXRTSPOL does not affect the
 * polarity of the receiver RTS. RTS will remain negated in the active low state
 * unless TXRTSE is set.
 *
 * Values:
 * - 0 - Transmitter RTS is active low.
 * - 1 - Transmitter RTS is active high.
 */
/*@{*/
#define BP_UART_MODEM_TXRTSPOL (2U)        /*!< Bit position for UART_MODEM_TXRTSPOL. */
#define BM_UART_MODEM_TXRTSPOL (0x04U)     /*!< Bit mask for UART_MODEM_TXRTSPOL. */
#define BS_UART_MODEM_TXRTSPOL (1U)        /*!< Bit field size in bits for UART_MODEM_TXRTSPOL. */

/*! @brief Read current value of the UART_MODEM_TXRTSPOL field. */
#define BR_UART_MODEM_TXRTSPOL(x) (BITBAND_ACCESS8(HW_UART_MODEM_ADDR(x), BP_UART_MODEM_TXRTSPOL))

/*! @brief Format value for bitfield UART_MODEM_TXRTSPOL. */
#define BF_UART_MODEM_TXRTSPOL(v) ((uint8_t)((uint8_t)(v) << BP_UART_MODEM_TXRTSPOL) & BM_UART_MODEM_TXRTSPOL)

/*! @brief Set the TXRTSPOL field to a new value. */
#define BW_UART_MODEM_TXRTSPOL(x, v) (BITBAND_ACCESS8(HW_UART_MODEM_ADDR(x), BP_UART_MODEM_TXRTSPOL) = (v))
/*@}*/

/*!
 * @name Register UART_MODEM, field RXRTSE[3] (RW)
 *
 * Allows the RTS output to control the CTS input of the transmitting device to
 * prevent receiver overrun. Do not set both RXRTSE and TXRTSE.
 *
 * Values:
 * - 0 - The receiver has no effect on RTS.
 * - 1 - RTS is deasserted if the number of characters in the receiver data
 *     register (FIFO) is equal to or greater than RWFIFO[RXWATER]. RTS is asserted
 *     when the number of characters in the receiver data register (FIFO) is less
 *     than RWFIFO[RXWATER].
 */
/*@{*/
#define BP_UART_MODEM_RXRTSE (3U)          /*!< Bit position for UART_MODEM_RXRTSE. */
#define BM_UART_MODEM_RXRTSE (0x08U)       /*!< Bit mask for UART_MODEM_RXRTSE. */
#define BS_UART_MODEM_RXRTSE (1U)          /*!< Bit field size in bits for UART_MODEM_RXRTSE. */

/*! @brief Read current value of the UART_MODEM_RXRTSE field. */
#define BR_UART_MODEM_RXRTSE(x) (BITBAND_ACCESS8(HW_UART_MODEM_ADDR(x), BP_UART_MODEM_RXRTSE))

/*! @brief Format value for bitfield UART_MODEM_RXRTSE. */
#define BF_UART_MODEM_RXRTSE(v) ((uint8_t)((uint8_t)(v) << BP_UART_MODEM_RXRTSE) & BM_UART_MODEM_RXRTSE)

/*! @brief Set the RXRTSE field to a new value. */
#define BW_UART_MODEM_RXRTSE(x, v) (BITBAND_ACCESS8(HW_UART_MODEM_ADDR(x), BP_UART_MODEM_RXRTSE) = (v))
/*@}*/

/*******************************************************************************
 * HW_UART_IR - UART Infrared Register
 ******************************************************************************/

/*!
 * @brief HW_UART_IR - UART Infrared Register (RW)
 *
 * Reset value: 0x00U
 *
 * The IR register controls options for setting the infrared configuration.
 */
typedef union _hw_uart_ir
{
    uint8_t U;
    struct _hw_uart_ir_bitfields
    {
        uint8_t TNP : 2;               /*!< [1:0] Transmitter narrow pulse */
        uint8_t IREN : 1;              /*!< [2] Infrared enable */
        uint8_t RESERVED0 : 5;         /*!< [7:3]  */
    } B;
} hw_uart_ir_t;

/*!
 * @name Constants and macros for entire UART_IR register
 */
/*@{*/
#define HW_UART_IR_ADDR(x)       ((x) + 0xEU)

#define HW_UART_IR(x)            (*(__IO hw_uart_ir_t *) HW_UART_IR_ADDR(x))
#define HW_UART_IR_RD(x)         (HW_UART_IR(x).U)
#define HW_UART_IR_WR(x, v)      (HW_UART_IR(x).U = (v))
#define HW_UART_IR_SET(x, v)     (HW_UART_IR_WR(x, HW_UART_IR_RD(x) |  (v)))
#define HW_UART_IR_CLR(x, v)     (HW_UART_IR_WR(x, HW_UART_IR_RD(x) & ~(v)))
#define HW_UART_IR_TOG(x, v)     (HW_UART_IR_WR(x, HW_UART_IR_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual UART_IR bitfields
 */

/*!
 * @name Register UART_IR, field TNP[1:0] (RW)
 *
 * These bits enable whether the UART transmits a 1/16, 3/16, 1/32 or 1/4 narrow
 * pulse.
 *
 * Values:
 * - 00 - 3/16.
 * - 01 - 1/16.
 * - 10 - 1/32.
 * - 11 - 1/4.
 */
/*@{*/
#define BP_UART_IR_TNP       (0U)          /*!< Bit position for UART_IR_TNP. */
#define BM_UART_IR_TNP       (0x03U)       /*!< Bit mask for UART_IR_TNP. */
#define BS_UART_IR_TNP       (2U)          /*!< Bit field size in bits for UART_IR_TNP. */

/*! @brief Read current value of the UART_IR_TNP field. */
#define BR_UART_IR_TNP(x)    (HW_UART_IR(x).B.TNP)

/*! @brief Format value for bitfield UART_IR_TNP. */
#define BF_UART_IR_TNP(v)    ((uint8_t)((uint8_t)(v) << BP_UART_IR_TNP) & BM_UART_IR_TNP)

/*! @brief Set the TNP field to a new value. */
#define BW_UART_IR_TNP(x, v) (HW_UART_IR_WR(x, (HW_UART_IR_RD(x) & ~BM_UART_IR_TNP) | BF_UART_IR_TNP(v)))
/*@}*/

/*!
 * @name Register UART_IR, field IREN[2] (RW)
 *
 * This bit enables/disables the infrared modulation/demodulation.
 *
 * Values:
 * - 0 - IR disabled.
 * - 1 - IR enabled.
 */
/*@{*/
#define BP_UART_IR_IREN      (2U)          /*!< Bit position for UART_IR_IREN. */
#define BM_UART_IR_IREN      (0x04U)       /*!< Bit mask for UART_IR_IREN. */
#define BS_UART_IR_IREN      (1U)          /*!< Bit field size in bits for UART_IR_IREN. */

/*! @brief Read current value of the UART_IR_IREN field. */
#define BR_UART_IR_IREN(x)   (BITBAND_ACCESS8(HW_UART_IR_ADDR(x), BP_UART_IR_IREN))

/*! @brief Format value for bitfield UART_IR_IREN. */
#define BF_UART_IR_IREN(v)   ((uint8_t)((uint8_t)(v) << BP_UART_IR_IREN) & BM_UART_IR_IREN)

/*! @brief Set the IREN field to a new value. */
#define BW_UART_IR_IREN(x, v) (BITBAND_ACCESS8(HW_UART_IR_ADDR(x), BP_UART_IR_IREN) = (v))
/*@}*/

/*******************************************************************************
 * HW_UART_PFIFO - UART FIFO Parameters
 ******************************************************************************/

/*!
 * @brief HW_UART_PFIFO - UART FIFO Parameters (RW)
 *
 * Reset value: 0x00U
 *
 * This register provides the ability for the programmer to turn on and off FIFO
 * functionality. It also provides the size of the FIFO that has been
 * implemented. This register may be read at any time. This register should only be written
 * when the C2[RE] and C2[TE] bits are cleared / not set and when the data
 * buffer/FIFO is empty.
 */
typedef union _hw_uart_pfifo
{
    uint8_t U;
    struct _hw_uart_pfifo_bitfields
    {
        uint8_t RXFIFOSIZE : 3;        /*!< [2:0] Receive FIFO. Buffer Depth */
        uint8_t RXFE : 1;              /*!< [3] Receive FIFO Enable */
        uint8_t TXFIFOSIZE : 3;        /*!< [6:4] Transmit FIFO. Buffer Depth */
        uint8_t TXFE : 1;              /*!< [7] Transmit FIFO Enable */
    } B;
} hw_uart_pfifo_t;

/*!
 * @name Constants and macros for entire UART_PFIFO register
 */
/*@{*/
#define HW_UART_PFIFO_ADDR(x)    ((x) + 0x10U)

#define HW_UART_PFIFO(x)         (*(__IO hw_uart_pfifo_t *) HW_UART_PFIFO_ADDR(x))
#define HW_UART_PFIFO_RD(x)      (HW_UART_PFIFO(x).U)
#define HW_UART_PFIFO_WR(x, v)   (HW_UART_PFIFO(x).U = (v))
#define HW_UART_PFIFO_SET(x, v)  (HW_UART_PFIFO_WR(x, HW_UART_PFIFO_RD(x) |  (v)))
#define HW_UART_PFIFO_CLR(x, v)  (HW_UART_PFIFO_WR(x, HW_UART_PFIFO_RD(x) & ~(v)))
#define HW_UART_PFIFO_TOG(x, v)  (HW_UART_PFIFO_WR(x, HW_UART_PFIFO_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual UART_PFIFO bitfields
 */

/*!
 * @name Register UART_PFIFO, field RXFIFOSIZE[2:0] (RO)
 *
 * The maximum number of receive datawords that can be stored in the receive
 * buffer before an overrun occurs. This field is read only.
 *
 * Values:
 * - 000 - Receive FIFO/Buffer Depth = 1 Dataword.
 * - 001 - Receive FIFO/Buffer Depth = 4 Datawords.
 * - 010 - Receive FIFO/Buffer Depth = 8 Datawords.
 * - 011 - Receive FIFO/Buffer Depth = 16 Datawords.
 * - 100 - Receive FIFO/Buffer Depth = 32 Datawords.
 * - 101 - Receive FIFO/Buffer Depth = 64 Datawords.
 * - 110 - Receive FIFO/Buffer Depth = 128 Datawords.
 * - 111 - Reserved.
 */
/*@{*/
#define BP_UART_PFIFO_RXFIFOSIZE (0U)      /*!< Bit position for UART_PFIFO_RXFIFOSIZE. */
#define BM_UART_PFIFO_RXFIFOSIZE (0x07U)   /*!< Bit mask for UART_PFIFO_RXFIFOSIZE. */
#define BS_UART_PFIFO_RXFIFOSIZE (3U)      /*!< Bit field size in bits for UART_PFIFO_RXFIFOSIZE. */

/*! @brief Read current value of the UART_PFIFO_RXFIFOSIZE field. */
#define BR_UART_PFIFO_RXFIFOSIZE(x) (HW_UART_PFIFO(x).B.RXFIFOSIZE)
/*@}*/

/*!
 * @name Register UART_PFIFO, field RXFE[3] (RW)
 *
 * When this bit is set the built in FIFO structure for the receive buffer is
 * enabled. The size of the FIFO structure is indicated by the RXFIFOSIZE field. If
 * this bit is not set then the receive buffer operates as a FIFO of depth one
 * dataword regardless of the value in RXFIFOSIZE. Both C2[TE] and C2[RE] must be
 * cleared prior to changing this bit. Additionally TXFLUSH and RXFLUSH commands
 * should be issued immediately after changing this bit.
 *
 * Values:
 * - 0 - Receive FIFO is not enabled. Buffer is depth 1. (Legacy support)
 * - 1 - Receive FIFO is enabled. Buffer is depth indicted by RXFIFOSIZE.
 */
/*@{*/
#define BP_UART_PFIFO_RXFE   (3U)          /*!< Bit position for UART_PFIFO_RXFE. */
#define BM_UART_PFIFO_RXFE   (0x08U)       /*!< Bit mask for UART_PFIFO_RXFE. */
#define BS_UART_PFIFO_RXFE   (1U)          /*!< Bit field size in bits for UART_PFIFO_RXFE. */

/*! @brief Read current value of the UART_PFIFO_RXFE field. */
#define BR_UART_PFIFO_RXFE(x) (BITBAND_ACCESS8(HW_UART_PFIFO_ADDR(x), BP_UART_PFIFO_RXFE))

/*! @brief Format value for bitfield UART_PFIFO_RXFE. */
#define BF_UART_PFIFO_RXFE(v) ((uint8_t)((uint8_t)(v) << BP_UART_PFIFO_RXFE) & BM_UART_PFIFO_RXFE)

/*! @brief Set the RXFE field to a new value. */
#define BW_UART_PFIFO_RXFE(x, v) (BITBAND_ACCESS8(HW_UART_PFIFO_ADDR(x), BP_UART_PFIFO_RXFE) = (v))
/*@}*/

/*!
 * @name Register UART_PFIFO, field TXFIFOSIZE[6:4] (RO)
 *
 * The maximum number of transmit datawords that can be stored in the transmit
 * buffer. This field is read only.
 *
 * Values:
 * - 000 - Transmit FIFO/Buffer Depth = 1 Dataword.
 * - 001 - Transmit FIFO/Buffer Depth = 4 Datawords.
 * - 010 - Transmit FIFO/Buffer Depth = 8 Datawords.
 * - 011 - Transmit FIFO/Buffer Depth = 16 Datawords.
 * - 100 - Transmit FIFO/Buffer Depth = 32 Datawords.
 * - 101 - Transmit FIFO/Buffer Depth = 64 Datawords.
 * - 110 - Transmit FIFO/Buffer Depth = 128 Datawords.
 * - 111 - Reserved.
 */
/*@{*/
#define BP_UART_PFIFO_TXFIFOSIZE (4U)      /*!< Bit position for UART_PFIFO_TXFIFOSIZE. */
#define BM_UART_PFIFO_TXFIFOSIZE (0x70U)   /*!< Bit mask for UART_PFIFO_TXFIFOSIZE. */
#define BS_UART_PFIFO_TXFIFOSIZE (3U)      /*!< Bit field size in bits for UART_PFIFO_TXFIFOSIZE. */

/*! @brief Read current value of the UART_PFIFO_TXFIFOSIZE field. */
#define BR_UART_PFIFO_TXFIFOSIZE(x) (HW_UART_PFIFO(x).B.TXFIFOSIZE)
/*@}*/

/*!
 * @name Register UART_PFIFO, field TXFE[7] (RW)
 *
 * When this bit is set the built in FIFO structure for the transmit buffer is
 * enabled. The size of the FIFO structure is indicated by the TXFIFOSIZE field.
 * If this bit is not set then the transmit buffer operates as a FIFO of depth one
 * dataword regardless of the value in TXFIFOSIZE. Both C2[TE] and C2[RE] must
 * be cleared prior to changing this bit. Additionally TXFLUSH and RXFLUSH
 * commands should be issued immediately after changing this bit.
 *
 * Values:
 * - 0 - Transmit FIFO is not enabled. Buffer is depth 1. (Legacy support).
 * - 1 - Transmit FIFO is enabled. Buffer is depth indicted by TXFIFOSIZE.
 */
/*@{*/
#define BP_UART_PFIFO_TXFE   (7U)          /*!< Bit position for UART_PFIFO_TXFE. */
#define BM_UART_PFIFO_TXFE   (0x80U)       /*!< Bit mask for UART_PFIFO_TXFE. */
#define BS_UART_PFIFO_TXFE   (1U)          /*!< Bit field size in bits for UART_PFIFO_TXFE. */

/*! @brief Read current value of the UART_PFIFO_TXFE field. */
#define BR_UART_PFIFO_TXFE(x) (BITBAND_ACCESS8(HW_UART_PFIFO_ADDR(x), BP_UART_PFIFO_TXFE))

/*! @brief Format value for bitfield UART_PFIFO_TXFE. */
#define BF_UART_PFIFO_TXFE(v) ((uint8_t)((uint8_t)(v) << BP_UART_PFIFO_TXFE) & BM_UART_PFIFO_TXFE)

/*! @brief Set the TXFE field to a new value. */
#define BW_UART_PFIFO_TXFE(x, v) (BITBAND_ACCESS8(HW_UART_PFIFO_ADDR(x), BP_UART_PFIFO_TXFE) = (v))
/*@}*/

/*******************************************************************************
 * HW_UART_CFIFO - UART FIFO Control Register
 ******************************************************************************/

/*!
 * @brief HW_UART_CFIFO - UART FIFO Control Register (RW)
 *
 * Reset value: 0x00U
 *
 * This register provides the ability to program various control bits for FIFO
 * operation. This register may be read or written at any time. Note that writing
 * the TXFLUSH and RXFLUSH bits may result in data loss and requires careful
 * action to prevent unintended / unpredictable behavior, hence it is recommended
 * that TE and RE be cleared prior to flushing the corresponding FIFO.
 */
typedef union _hw_uart_cfifo
{
    uint8_t U;
    struct _hw_uart_cfifo_bitfields
    {
        uint8_t RXUFE : 1;             /*!< [0] Receive FIFO Underflow Interrupt Enable */
        uint8_t TXOFE : 1;             /*!< [1] Transmit FIFO Overflow Interrupt Enable */
        uint8_t RESERVED0 : 4;         /*!< [5:2]  */
        uint8_t RXFLUSH : 1;           /*!< [6] Receive FIFO/Buffer Flush */
        uint8_t TXFLUSH : 1;           /*!< [7] Transmit FIFO/Buffer Flush */
    } B;
} hw_uart_cfifo_t;

/*!
 * @name Constants and macros for entire UART_CFIFO register
 */
/*@{*/
#define HW_UART_CFIFO_ADDR(x)    ((x) + 0x11U)

#define HW_UART_CFIFO(x)         (*(__IO hw_uart_cfifo_t *) HW_UART_CFIFO_ADDR(x))
#define HW_UART_CFIFO_RD(x)      (HW_UART_CFIFO(x).U)
#define HW_UART_CFIFO_WR(x, v)   (HW_UART_CFIFO(x).U = (v))
#define HW_UART_CFIFO_SET(x, v)  (HW_UART_CFIFO_WR(x, HW_UART_CFIFO_RD(x) |  (v)))
#define HW_UART_CFIFO_CLR(x, v)  (HW_UART_CFIFO_WR(x, HW_UART_CFIFO_RD(x) & ~(v)))
#define HW_UART_CFIFO_TOG(x, v)  (HW_UART_CFIFO_WR(x, HW_UART_CFIFO_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual UART_CFIFO bitfields
 */

/*!
 * @name Register UART_CFIFO, field RXUFE[0] (RW)
 *
 * When this bit is set the RXUF flag will generate an interrupt to the host.
 *
 * Values:
 * - 0 - RXUF flag does not generate an interrupt to the host.
 * - 1 - RXUF flag generates an interrupt to the host.
 */
/*@{*/
#define BP_UART_CFIFO_RXUFE  (0U)          /*!< Bit position for UART_CFIFO_RXUFE. */
#define BM_UART_CFIFO_RXUFE  (0x01U)       /*!< Bit mask for UART_CFIFO_RXUFE. */
#define BS_UART_CFIFO_RXUFE  (1U)          /*!< Bit field size in bits for UART_CFIFO_RXUFE. */

/*! @brief Read current value of the UART_CFIFO_RXUFE field. */
#define BR_UART_CFIFO_RXUFE(x) (BITBAND_ACCESS8(HW_UART_CFIFO_ADDR(x), BP_UART_CFIFO_RXUFE))

/*! @brief Format value for bitfield UART_CFIFO_RXUFE. */
#define BF_UART_CFIFO_RXUFE(v) ((uint8_t)((uint8_t)(v) << BP_UART_CFIFO_RXUFE) & BM_UART_CFIFO_RXUFE)

/*! @brief Set the RXUFE field to a new value. */
#define BW_UART_CFIFO_RXUFE(x, v) (BITBAND_ACCESS8(HW_UART_CFIFO_ADDR(x), BP_UART_CFIFO_RXUFE) = (v))
/*@}*/

/*!
 * @name Register UART_CFIFO, field TXOFE[1] (RW)
 *
 * When this bit is set the TXOF flag will generate an interrupt to the host.
 *
 * Values:
 * - 0 - TXOF flag does not generate an interrupt to the host.
 * - 1 - TXOF flag generates an interrupt to the host.
 */
/*@{*/
#define BP_UART_CFIFO_TXOFE  (1U)          /*!< Bit position for UART_CFIFO_TXOFE. */
#define BM_UART_CFIFO_TXOFE  (0x02U)       /*!< Bit mask for UART_CFIFO_TXOFE. */
#define BS_UART_CFIFO_TXOFE  (1U)          /*!< Bit field size in bits for UART_CFIFO_TXOFE. */

/*! @brief Read current value of the UART_CFIFO_TXOFE field. */
#define BR_UART_CFIFO_TXOFE(x) (BITBAND_ACCESS8(HW_UART_CFIFO_ADDR(x), BP_UART_CFIFO_TXOFE))

/*! @brief Format value for bitfield UART_CFIFO_TXOFE. */
#define BF_UART_CFIFO_TXOFE(v) ((uint8_t)((uint8_t)(v) << BP_UART_CFIFO_TXOFE) & BM_UART_CFIFO_TXOFE)

/*! @brief Set the TXOFE field to a new value. */
#define BW_UART_CFIFO_TXOFE(x, v) (BITBAND_ACCESS8(HW_UART_CFIFO_ADDR(x), BP_UART_CFIFO_TXOFE) = (v))
/*@}*/

/*!
 * @name Register UART_CFIFO, field RXFLUSH[6] (WORZ)
 *
 * Writing to this bit causes all data that is stored in the receive FIFO/buffer
 * to be flushed. This does not affect data that is in the receive shift
 * register.
 *
 * Values:
 * - 0 - No flush operation occurs.
 * - 1 - All data in the receive FIFO/buffer is cleared out.
 */
/*@{*/
#define BP_UART_CFIFO_RXFLUSH (6U)         /*!< Bit position for UART_CFIFO_RXFLUSH. */
#define BM_UART_CFIFO_RXFLUSH (0x40U)      /*!< Bit mask for UART_CFIFO_RXFLUSH. */
#define BS_UART_CFIFO_RXFLUSH (1U)         /*!< Bit field size in bits for UART_CFIFO_RXFLUSH. */

/*! @brief Format value for bitfield UART_CFIFO_RXFLUSH. */
#define BF_UART_CFIFO_RXFLUSH(v) ((uint8_t)((uint8_t)(v) << BP_UART_CFIFO_RXFLUSH) & BM_UART_CFIFO_RXFLUSH)

/*! @brief Set the RXFLUSH field to a new value. */
#define BW_UART_CFIFO_RXFLUSH(x, v) (BITBAND_ACCESS8(HW_UART_CFIFO_ADDR(x), BP_UART_CFIFO_RXFLUSH) = (v))
/*@}*/

/*!
 * @name Register UART_CFIFO, field TXFLUSH[7] (WORZ)
 *
 * Writing to this bit causes all data that is stored in the transmit
 * FIFO/buffer to be flushed. This does not affect data that is in the transmit shift
 * register.
 *
 * Values:
 * - 0 - No flush operation occurs.
 * - 1 - All data in the transmit FIFO/Buffer is cleared out.
 */
/*@{*/
#define BP_UART_CFIFO_TXFLUSH (7U)         /*!< Bit position for UART_CFIFO_TXFLUSH. */
#define BM_UART_CFIFO_TXFLUSH (0x80U)      /*!< Bit mask for UART_CFIFO_TXFLUSH. */
#define BS_UART_CFIFO_TXFLUSH (1U)         /*!< Bit field size in bits for UART_CFIFO_TXFLUSH. */

/*! @brief Format value for bitfield UART_CFIFO_TXFLUSH. */
#define BF_UART_CFIFO_TXFLUSH(v) ((uint8_t)((uint8_t)(v) << BP_UART_CFIFO_TXFLUSH) & BM_UART_CFIFO_TXFLUSH)

/*! @brief Set the TXFLUSH field to a new value. */
#define BW_UART_CFIFO_TXFLUSH(x, v) (BITBAND_ACCESS8(HW_UART_CFIFO_ADDR(x), BP_UART_CFIFO_TXFLUSH) = (v))
/*@}*/

/*******************************************************************************
 * HW_UART_SFIFO - UART FIFO Status Register
 ******************************************************************************/

/*!
 * @brief HW_UART_SFIFO - UART FIFO Status Register (RW)
 *
 * Reset value: 0xC0U
 *
 * This register provides various status information regarding the transmit and
 * receiver buffers/FIFOs, including interrupt information. This register may be
 * written or read at anytime.
 */
typedef union _hw_uart_sfifo
{
    uint8_t U;
    struct _hw_uart_sfifo_bitfields
    {
        uint8_t RXUF : 1;              /*!< [0] Receiver Buffer Underflow Flag */
        uint8_t TXOF : 1;              /*!< [1] Transmitter Buffer Overflow Flag */
        uint8_t RESERVED0 : 4;         /*!< [5:2]  */
        uint8_t RXEMPT : 1;            /*!< [6] Receive Buffer/FIFO Empty */
        uint8_t TXEMPT : 1;            /*!< [7] Transmit Buffer/FIFO Empty */
    } B;
} hw_uart_sfifo_t;

/*!
 * @name Constants and macros for entire UART_SFIFO register
 */
/*@{*/
#define HW_UART_SFIFO_ADDR(x)    ((x) + 0x12U)

#define HW_UART_SFIFO(x)         (*(__IO hw_uart_sfifo_t *) HW_UART_SFIFO_ADDR(x))
#define HW_UART_SFIFO_RD(x)      (HW_UART_SFIFO(x).U)
#define HW_UART_SFIFO_WR(x, v)   (HW_UART_SFIFO(x).U = (v))
#define HW_UART_SFIFO_SET(x, v)  (HW_UART_SFIFO_WR(x, HW_UART_SFIFO_RD(x) |  (v)))
#define HW_UART_SFIFO_CLR(x, v)  (HW_UART_SFIFO_WR(x, HW_UART_SFIFO_RD(x) & ~(v)))
#define HW_UART_SFIFO_TOG(x, v)  (HW_UART_SFIFO_WR(x, HW_UART_SFIFO_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual UART_SFIFO bitfields
 */

/*!
 * @name Register UART_SFIFO, field RXUF[0] (RW)
 *
 * This flag indicates that more data has been read from the receive buffer than
 * was present. This bit will assert regardless of the value of CFIFO[RXUFE].
 * However, an interrupt will only be issued to the host if the CFIFO[RXUFE] bit is
 * set. This flag is cleared by writing a "1".
 *
 * Values:
 * - 0 - No receive buffer underflow has occurred since the last time the flag
 *     was cleared.
 * - 1 - At least one receive buffer underflow has occurred since the last time
 *     the flag was cleared.
 */
/*@{*/
#define BP_UART_SFIFO_RXUF   (0U)          /*!< Bit position for UART_SFIFO_RXUF. */
#define BM_UART_SFIFO_RXUF   (0x01U)       /*!< Bit mask for UART_SFIFO_RXUF. */
#define BS_UART_SFIFO_RXUF   (1U)          /*!< Bit field size in bits for UART_SFIFO_RXUF. */

/*! @brief Read current value of the UART_SFIFO_RXUF field. */
#define BR_UART_SFIFO_RXUF(x) (BITBAND_ACCESS8(HW_UART_SFIFO_ADDR(x), BP_UART_SFIFO_RXUF))

/*! @brief Format value for bitfield UART_SFIFO_RXUF. */
#define BF_UART_SFIFO_RXUF(v) ((uint8_t)((uint8_t)(v) << BP_UART_SFIFO_RXUF) & BM_UART_SFIFO_RXUF)

/*! @brief Set the RXUF field to a new value. */
#define BW_UART_SFIFO_RXUF(x, v) (BITBAND_ACCESS8(HW_UART_SFIFO_ADDR(x), BP_UART_SFIFO_RXUF) = (v))
/*@}*/

/*!
 * @name Register UART_SFIFO, field TXOF[1] (RW)
 *
 * This flag indicates that more data has been written to the transmit buffer
 * than it can hold. This bit will assert regardless of the value of CFIFO[TXOFE].
 * However, an interrupt will only be issued to the host if the CFIFO[TXOFE] bit
 * is set. This flag is cleared by writing a "1".
 *
 * Values:
 * - 0 - No transmit buffer overflow has occurred since the last time the flag
 *     was cleared.
 * - 1 - At least one transmit buffer overflow has occurred since the last time
 *     the flag was cleared.
 */
/*@{*/
#define BP_UART_SFIFO_TXOF   (1U)          /*!< Bit position for UART_SFIFO_TXOF. */
#define BM_UART_SFIFO_TXOF   (0x02U)       /*!< Bit mask for UART_SFIFO_TXOF. */
#define BS_UART_SFIFO_TXOF   (1U)          /*!< Bit field size in bits for UART_SFIFO_TXOF. */

/*! @brief Read current value of the UART_SFIFO_TXOF field. */
#define BR_UART_SFIFO_TXOF(x) (BITBAND_ACCESS8(HW_UART_SFIFO_ADDR(x), BP_UART_SFIFO_TXOF))

/*! @brief Format value for bitfield UART_SFIFO_TXOF. */
#define BF_UART_SFIFO_TXOF(v) ((uint8_t)((uint8_t)(v) << BP_UART_SFIFO_TXOF) & BM_UART_SFIFO_TXOF)

/*! @brief Set the TXOF field to a new value. */
#define BW_UART_SFIFO_TXOF(x, v) (BITBAND_ACCESS8(HW_UART_SFIFO_ADDR(x), BP_UART_SFIFO_TXOF) = (v))
/*@}*/

/*!
 * @name Register UART_SFIFO, field RXEMPT[6] (RO)
 *
 * This status bit asserts when there is no data in the receive FIFO/Buffer.
 * This bit does not take into account data that is in the receive shift register.
 *
 * Values:
 * - 0 - Receive buffer is not empty.
 * - 1 - Receive buffer is empty.
 */
/*@{*/
#define BP_UART_SFIFO_RXEMPT (6U)          /*!< Bit position for UART_SFIFO_RXEMPT. */
#define BM_UART_SFIFO_RXEMPT (0x40U)       /*!< Bit mask for UART_SFIFO_RXEMPT. */
#define BS_UART_SFIFO_RXEMPT (1U)          /*!< Bit field size in bits for UART_SFIFO_RXEMPT. */

/*! @brief Read current value of the UART_SFIFO_RXEMPT field. */
#define BR_UART_SFIFO_RXEMPT(x) (BITBAND_ACCESS8(HW_UART_SFIFO_ADDR(x), BP_UART_SFIFO_RXEMPT))
/*@}*/

/*!
 * @name Register UART_SFIFO, field TXEMPT[7] (RO)
 *
 * This status bit asserts when there is no data in the Transmit FIFO/buffer.
 * This bit does not take into account data that is in the transmit shift register.
 *
 * Values:
 * - 0 - Transmit buffer is not empty.
 * - 1 - Transmit buffer is empty.
 */
/*@{*/
#define BP_UART_SFIFO_TXEMPT (7U)          /*!< Bit position for UART_SFIFO_TXEMPT. */
#define BM_UART_SFIFO_TXEMPT (0x80U)       /*!< Bit mask for UART_SFIFO_TXEMPT. */
#define BS_UART_SFIFO_TXEMPT (1U)          /*!< Bit field size in bits for UART_SFIFO_TXEMPT. */

/*! @brief Read current value of the UART_SFIFO_TXEMPT field. */
#define BR_UART_SFIFO_TXEMPT(x) (BITBAND_ACCESS8(HW_UART_SFIFO_ADDR(x), BP_UART_SFIFO_TXEMPT))
/*@}*/

/*******************************************************************************
 * HW_UART_TWFIFO - UART FIFO Transmit Watermark
 ******************************************************************************/

/*!
 * @brief HW_UART_TWFIFO - UART FIFO Transmit Watermark (RW)
 *
 * Reset value: 0x00U
 *
 * This register provides the ability to set a programmable threshold for
 * notification of needing additional transmit data. This register may be read at any
 * time but should only be written when C2[TE] is not set. Changing the value of
 * the watermark will not clear the S1[TDRE] flag.
 */
typedef union _hw_uart_twfifo
{
    uint8_t U;
    struct _hw_uart_twfifo_bitfields
    {
        uint8_t TXWATER : 8;           /*!< [7:0] Transmit Watermark */
    } B;
} hw_uart_twfifo_t;

/*!
 * @name Constants and macros for entire UART_TWFIFO register
 */
/*@{*/
#define HW_UART_TWFIFO_ADDR(x)   ((x) + 0x13U)

#define HW_UART_TWFIFO(x)        (*(__IO hw_uart_twfifo_t *) HW_UART_TWFIFO_ADDR(x))
#define HW_UART_TWFIFO_RD(x)     (HW_UART_TWFIFO(x).U)
#define HW_UART_TWFIFO_WR(x, v)  (HW_UART_TWFIFO(x).U = (v))
#define HW_UART_TWFIFO_SET(x, v) (HW_UART_TWFIFO_WR(x, HW_UART_TWFIFO_RD(x) |  (v)))
#define HW_UART_TWFIFO_CLR(x, v) (HW_UART_TWFIFO_WR(x, HW_UART_TWFIFO_RD(x) & ~(v)))
#define HW_UART_TWFIFO_TOG(x, v) (HW_UART_TWFIFO_WR(x, HW_UART_TWFIFO_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual UART_TWFIFO bitfields
 */

/*!
 * @name Register UART_TWFIFO, field TXWATER[7:0] (RW)
 *
 * When the number of datawords in the transmit FIFO/buffer is equal to or less
 * than the value in this register field then an interrupt via S1[TDRE] or a DMA
 * request via C5[TDMAS] will be generated as determined by C5[TDMAS] and C2[TIE]
 * fields. For proper operation the value in the TXWATER field must be set to be
 * less than the size of the transmit buffer/FIFO size as indicated by
 * PFIFO[TXFIFOSIZE] and PFIFO[TXFE].
 */
/*@{*/
#define BP_UART_TWFIFO_TXWATER (0U)        /*!< Bit position for UART_TWFIFO_TXWATER. */
#define BM_UART_TWFIFO_TXWATER (0xFFU)     /*!< Bit mask for UART_TWFIFO_TXWATER. */
#define BS_UART_TWFIFO_TXWATER (8U)        /*!< Bit field size in bits for UART_TWFIFO_TXWATER. */

/*! @brief Read current value of the UART_TWFIFO_TXWATER field. */
#define BR_UART_TWFIFO_TXWATER(x) (HW_UART_TWFIFO(x).U)

/*! @brief Format value for bitfield UART_TWFIFO_TXWATER. */
#define BF_UART_TWFIFO_TXWATER(v) ((uint8_t)((uint8_t)(v) << BP_UART_TWFIFO_TXWATER) & BM_UART_TWFIFO_TXWATER)

/*! @brief Set the TXWATER field to a new value. */
#define BW_UART_TWFIFO_TXWATER(x, v) (HW_UART_TWFIFO_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_UART_TCFIFO - UART FIFO Transmit Count
 ******************************************************************************/

/*!
 * @brief HW_UART_TCFIFO - UART FIFO Transmit Count (RO)
 *
 * Reset value: 0x00U
 *
 * This is a read only register that indicates how many datawords are currently
 * in the transmit buffer/FIFO. It may be read at anytime.
 */
typedef union _hw_uart_tcfifo
{
    uint8_t U;
    struct _hw_uart_tcfifo_bitfields
    {
        uint8_t TXCOUNT : 8;           /*!< [7:0] Transmit Counter */
    } B;
} hw_uart_tcfifo_t;

/*!
 * @name Constants and macros for entire UART_TCFIFO register
 */
/*@{*/
#define HW_UART_TCFIFO_ADDR(x)   ((x) + 0x14U)

#define HW_UART_TCFIFO(x)        (*(__I hw_uart_tcfifo_t *) HW_UART_TCFIFO_ADDR(x))
#define HW_UART_TCFIFO_RD(x)     (HW_UART_TCFIFO(x).U)
/*@}*/

/*
 * Constants & macros for individual UART_TCFIFO bitfields
 */

/*!
 * @name Register UART_TCFIFO, field TXCOUNT[7:0] (RO)
 *
 * The value in this register indicates the number of datawords that are in the
 * transmit buffer/FIFO. If a dataword is in the process of being transmitted
 * (i.e. in the transmit shift register) it is not included in the count. This value
 * may be used in conjunction with the PFIFO[TXFIFOSIZE] field to calculate how
 * much room is left in the transmit buffer/FIFO.
 */
/*@{*/
#define BP_UART_TCFIFO_TXCOUNT (0U)        /*!< Bit position for UART_TCFIFO_TXCOUNT. */
#define BM_UART_TCFIFO_TXCOUNT (0xFFU)     /*!< Bit mask for UART_TCFIFO_TXCOUNT. */
#define BS_UART_TCFIFO_TXCOUNT (8U)        /*!< Bit field size in bits for UART_TCFIFO_TXCOUNT. */

/*! @brief Read current value of the UART_TCFIFO_TXCOUNT field. */
#define BR_UART_TCFIFO_TXCOUNT(x) (HW_UART_TCFIFO(x).U)
/*@}*/

/*******************************************************************************
 * HW_UART_RWFIFO - UART FIFO Receive Watermark
 ******************************************************************************/

/*!
 * @brief HW_UART_RWFIFO - UART FIFO Receive Watermark (RW)
 *
 * Reset value: 0x01U
 *
 * This register provides the ability to set a programmable threshold for
 * notification of needing to remove data from the receiver buffer/FIFO. This register
 * may be read at any time but should only be written when C2[RE] is not
 * asserted. Changing the value in this register will not clear the S1[RDRF] flag.
 */
typedef union _hw_uart_rwfifo
{
    uint8_t U;
    struct _hw_uart_rwfifo_bitfields
    {
        uint8_t RXWATER : 8;           /*!< [7:0] Receive Watermark */
    } B;
} hw_uart_rwfifo_t;

/*!
 * @name Constants and macros for entire UART_RWFIFO register
 */
/*@{*/
#define HW_UART_RWFIFO_ADDR(x)   ((x) + 0x15U)

#define HW_UART_RWFIFO(x)        (*(__IO hw_uart_rwfifo_t *) HW_UART_RWFIFO_ADDR(x))
#define HW_UART_RWFIFO_RD(x)     (HW_UART_RWFIFO(x).U)
#define HW_UART_RWFIFO_WR(x, v)  (HW_UART_RWFIFO(x).U = (v))
#define HW_UART_RWFIFO_SET(x, v) (HW_UART_RWFIFO_WR(x, HW_UART_RWFIFO_RD(x) |  (v)))
#define HW_UART_RWFIFO_CLR(x, v) (HW_UART_RWFIFO_WR(x, HW_UART_RWFIFO_RD(x) & ~(v)))
#define HW_UART_RWFIFO_TOG(x, v) (HW_UART_RWFIFO_WR(x, HW_UART_RWFIFO_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual UART_RWFIFO bitfields
 */

/*!
 * @name Register UART_RWFIFO, field RXWATER[7:0] (RW)
 *
 * When the number of datawords in the Receive FIFO/buffer is equal to or
 * greater than the value in this register field the event is flagged. An interrupt via
 * S1[RDRF] or a DMA request via C5[RDMAS] will be generated as determined by
 * C5[RDMAS] and C2[RIE] fields. For proper operation the value in the RXWATER
 * field must be set to be less than the size of the Receive buffer/FIFO size as
 * indicated by PFIFO[RXFIFOSIZE] and PFIFO[RXFE] and greater than 0.
 */
/*@{*/
#define BP_UART_RWFIFO_RXWATER (0U)        /*!< Bit position for UART_RWFIFO_RXWATER. */
#define BM_UART_RWFIFO_RXWATER (0xFFU)     /*!< Bit mask for UART_RWFIFO_RXWATER. */
#define BS_UART_RWFIFO_RXWATER (8U)        /*!< Bit field size in bits for UART_RWFIFO_RXWATER. */

/*! @brief Read current value of the UART_RWFIFO_RXWATER field. */
#define BR_UART_RWFIFO_RXWATER(x) (HW_UART_RWFIFO(x).U)

/*! @brief Format value for bitfield UART_RWFIFO_RXWATER. */
#define BF_UART_RWFIFO_RXWATER(v) ((uint8_t)((uint8_t)(v) << BP_UART_RWFIFO_RXWATER) & BM_UART_RWFIFO_RXWATER)

/*! @brief Set the RXWATER field to a new value. */
#define BW_UART_RWFIFO_RXWATER(x, v) (HW_UART_RWFIFO_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_UART_RCFIFO - UART FIFO Receive Count
 ******************************************************************************/

/*!
 * @brief HW_UART_RCFIFO - UART FIFO Receive Count (RO)
 *
 * Reset value: 0x00U
 *
 * This is a read only register that indicates how many datawords are currently
 * in the receive buffer/FIFO. It may be read at anytime.
 */
typedef union _hw_uart_rcfifo
{
    uint8_t U;
    struct _hw_uart_rcfifo_bitfields
    {
        uint8_t RXCOUNT : 8;           /*!< [7:0] Receive Counter */
    } B;
} hw_uart_rcfifo_t;

/*!
 * @name Constants and macros for entire UART_RCFIFO register
 */
/*@{*/
#define HW_UART_RCFIFO_ADDR(x)   ((x) + 0x16U)

#define HW_UART_RCFIFO(x)        (*(__I hw_uart_rcfifo_t *) HW_UART_RCFIFO_ADDR(x))
#define HW_UART_RCFIFO_RD(x)     (HW_UART_RCFIFO(x).U)
/*@}*/

/*
 * Constants & macros for individual UART_RCFIFO bitfields
 */

/*!
 * @name Register UART_RCFIFO, field RXCOUNT[7:0] (RO)
 *
 * The value in this register indicates the number of datawords that are in the
 * receive buffer/FIFO. If a dataword is in the process of being received (i.e.
 * in the receive shift register) it is not included in the count. This value may
 * be used in conjunction with the PFIFO[RXFIFOSIZE] field to calculate how much
 * room is left in the receive buffer/FIFO.
 */
/*@{*/
#define BP_UART_RCFIFO_RXCOUNT (0U)        /*!< Bit position for UART_RCFIFO_RXCOUNT. */
#define BM_UART_RCFIFO_RXCOUNT (0xFFU)     /*!< Bit mask for UART_RCFIFO_RXCOUNT. */
#define BS_UART_RCFIFO_RXCOUNT (8U)        /*!< Bit field size in bits for UART_RCFIFO_RXCOUNT. */

/*! @brief Read current value of the UART_RCFIFO_RXCOUNT field. */
#define BR_UART_RCFIFO_RXCOUNT(x) (HW_UART_RCFIFO(x).U)
/*@}*/

/*******************************************************************************
 * HW_UART_C7816 - UART 7816 Control Register
 ******************************************************************************/

/*!
 * @brief HW_UART_C7816 - UART 7816 Control Register (RW)
 *
 * Reset value: 0x00U
 *
 * The C7816 register is the primary control register for ISO-7816 specific
 * functionality. This register is specific to 7816 functionality and the values in
 * this register have no effect on UART operation and should be ignored if
 * ISO_7816E is not set/enabled. This register may be read at anytime but values should
 * only be changed when the ISO_7816E bit is not set.
 */
typedef union _hw_uart_c7816
{
    uint8_t U;
    struct _hw_uart_c7816_bitfields
    {
        uint8_t ISO_7816E : 1;         /*!< [0] ISO-7816 Functionality Enabled */
        uint8_t TTYPE : 1;             /*!< [1] Transfer Type */
        uint8_t INIT : 1;              /*!< [2] Detect Initial Character */
        uint8_t ANACK : 1;             /*!< [3] Generate NACK on Error */
        uint8_t ONACK : 1;             /*!< [4] Generate NACK on Overflow */
        uint8_t RESERVED0 : 3;         /*!< [7:5]  */
    } B;
} hw_uart_c7816_t;

/*!
 * @name Constants and macros for entire UART_C7816 register
 */
/*@{*/
#define HW_UART_C7816_ADDR(x)    ((x) + 0x18U)

#define HW_UART_C7816(x)         (*(__IO hw_uart_c7816_t *) HW_UART_C7816_ADDR(x))
#define HW_UART_C7816_RD(x)      (HW_UART_C7816(x).U)
#define HW_UART_C7816_WR(x, v)   (HW_UART_C7816(x).U = (v))
#define HW_UART_C7816_SET(x, v)  (HW_UART_C7816_WR(x, HW_UART_C7816_RD(x) |  (v)))
#define HW_UART_C7816_CLR(x, v)  (HW_UART_C7816_WR(x, HW_UART_C7816_RD(x) & ~(v)))
#define HW_UART_C7816_TOG(x, v)  (HW_UART_C7816_WR(x, HW_UART_C7816_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual UART_C7816 bitfields
 */

/*!
 * @name Register UART_C7816, field ISO_7816E[0] (RW)
 *
 * This bit indicates that the UART is operating according to the ISO-7816
 * protocol. This bit should only be modified when no transmit or receive is
 * occurring. If this bit is changed during a data transfer the data being transmitted or
 * received may be transferred incorrectly.
 *
 * Values:
 * - 0 - ISO-7816 functionality is turned off / not enabled.
 * - 1 - ISO-7816 functionality is turned on / enabled.
 */
/*@{*/
#define BP_UART_C7816_ISO_7816E (0U)       /*!< Bit position for UART_C7816_ISO_7816E. */
#define BM_UART_C7816_ISO_7816E (0x01U)    /*!< Bit mask for UART_C7816_ISO_7816E. */
#define BS_UART_C7816_ISO_7816E (1U)       /*!< Bit field size in bits for UART_C7816_ISO_7816E. */

/*! @brief Read current value of the UART_C7816_ISO_7816E field. */
#define BR_UART_C7816_ISO_7816E(x) (BITBAND_ACCESS8(HW_UART_C7816_ADDR(x), BP_UART_C7816_ISO_7816E))

/*! @brief Format value for bitfield UART_C7816_ISO_7816E. */
#define BF_UART_C7816_ISO_7816E(v) ((uint8_t)((uint8_t)(v) << BP_UART_C7816_ISO_7816E) & BM_UART_C7816_ISO_7816E)

/*! @brief Set the ISO_7816E field to a new value. */
#define BW_UART_C7816_ISO_7816E(x, v) (BITBAND_ACCESS8(HW_UART_C7816_ADDR(x), BP_UART_C7816_ISO_7816E) = (v))
/*@}*/

/*!
 * @name Register UART_C7816, field TTYPE[1] (RW)
 *
 * This bit indicates the transfer protocol being used. Refer to ISO-7816 /
 * smartcard support for more details.
 *
 * Values:
 * - 0 - T = 0 Per the ISO-7816 specification.
 * - 1 - T = 1 Per the ISO-7816 specification.
 */
/*@{*/
#define BP_UART_C7816_TTYPE  (1U)          /*!< Bit position for UART_C7816_TTYPE. */
#define BM_UART_C7816_TTYPE  (0x02U)       /*!< Bit mask for UART_C7816_TTYPE. */
#define BS_UART_C7816_TTYPE  (1U)          /*!< Bit field size in bits for UART_C7816_TTYPE. */

/*! @brief Read current value of the UART_C7816_TTYPE field. */
#define BR_UART_C7816_TTYPE(x) (BITBAND_ACCESS8(HW_UART_C7816_ADDR(x), BP_UART_C7816_TTYPE))

/*! @brief Format value for bitfield UART_C7816_TTYPE. */
#define BF_UART_C7816_TTYPE(v) ((uint8_t)((uint8_t)(v) << BP_UART_C7816_TTYPE) & BM_UART_C7816_TTYPE)

/*! @brief Set the TTYPE field to a new value. */
#define BW_UART_C7816_TTYPE(x, v) (BITBAND_ACCESS8(HW_UART_C7816_ADDR(x), BP_UART_C7816_TTYPE) = (v))
/*@}*/

/*!
 * @name Register UART_C7816, field INIT[2] (RW)
 *
 * When this bit is set, all received characters will be searched for a valid
 * initial character. If an invalid initial character is identified then a NACK
 * will be sent if ANACK is set. All received data is discarded and error flags
 * blocked (S1[NF], S1[OR], S1[FE], S1[PF], IS7816[WT], IS7816[CWT], IS7816[BWT],
 * IS7816[GTV]) until a valid initial character is detected. Upon detection of a
 * valid initial character the configuration values S2[MSBF], C3[TXINV] and
 * S2[RXINV] are automatically updated to reflect the initial character that was
 * received. The actual INIT data value is not stored in the receive buffer.
 * Additionally, upon detection of a valid initial character the IS7816[INITD] flag is set
 * and an interrupt issued as programmed by the IE7816[INITDE] bit. When a valid
 * initial character is detected the INIT bit is automatically cleared.
 *
 * Values:
 * - 0 - Normal operating mode. Receiver does not seek to identify initial
 *     character.
 * - 1 - Receiver searches for initial character.
 */
/*@{*/
#define BP_UART_C7816_INIT   (2U)          /*!< Bit position for UART_C7816_INIT. */
#define BM_UART_C7816_INIT   (0x04U)       /*!< Bit mask for UART_C7816_INIT. */
#define BS_UART_C7816_INIT   (1U)          /*!< Bit field size in bits for UART_C7816_INIT. */

/*! @brief Read current value of the UART_C7816_INIT field. */
#define BR_UART_C7816_INIT(x) (BITBAND_ACCESS8(HW_UART_C7816_ADDR(x), BP_UART_C7816_INIT))

/*! @brief Format value for bitfield UART_C7816_INIT. */
#define BF_UART_C7816_INIT(v) ((uint8_t)((uint8_t)(v) << BP_UART_C7816_INIT) & BM_UART_C7816_INIT)

/*! @brief Set the INIT field to a new value. */
#define BW_UART_C7816_INIT(x, v) (BITBAND_ACCESS8(HW_UART_C7816_ADDR(x), BP_UART_C7816_INIT) = (v))
/*@}*/

/*!
 * @name Register UART_C7816, field ANACK[3] (RW)
 *
 * When this bit is set, the receiver will automatically generate a NACK
 * response if a parity error occurs or if INIT is set and an invalid initial character
 * is detected. A NACK is only generated if TTYPE = 0. If ANACK is set the UART
 * will attempt to retransmit the data indefinitely. To stop retransmission
 * attempts, clear C2[TE] or ISO_7816E and do not set until S1[TC] set C2[TE] again.
 *
 * Values:
 * - 0 - No NACK is automatically generated.
 * - 1 - A NACK is automatically generated if a parity error is detected or if
 *     an invalid initial character is detected.
 */
/*@{*/
#define BP_UART_C7816_ANACK  (3U)          /*!< Bit position for UART_C7816_ANACK. */
#define BM_UART_C7816_ANACK  (0x08U)       /*!< Bit mask for UART_C7816_ANACK. */
#define BS_UART_C7816_ANACK  (1U)          /*!< Bit field size in bits for UART_C7816_ANACK. */

/*! @brief Read current value of the UART_C7816_ANACK field. */
#define BR_UART_C7816_ANACK(x) (BITBAND_ACCESS8(HW_UART_C7816_ADDR(x), BP_UART_C7816_ANACK))

/*! @brief Format value for bitfield UART_C7816_ANACK. */
#define BF_UART_C7816_ANACK(v) ((uint8_t)((uint8_t)(v) << BP_UART_C7816_ANACK) & BM_UART_C7816_ANACK)

/*! @brief Set the ANACK field to a new value. */
#define BW_UART_C7816_ANACK(x, v) (BITBAND_ACCESS8(HW_UART_C7816_ADDR(x), BP_UART_C7816_ANACK) = (v))
/*@}*/

/*!
 * @name Register UART_C7816, field ONACK[4] (RW)
 *
 * When this bit is set, the receiver will automatically generate a NACK
 * response if a receive buffer overrun occurs as indicated by the S1[OR] field. In many
 * systems this will result in the transmitter resending the packet that
 * overflowed until the retransmit threshold for that transmitter has been reached. A
 * NACK is only generated if TTYPE=0. This bit operates independently of ANACK. See
 * Overrun NACK considerations.
 *
 * Values:
 * - 0 - The received data does not generate a NACK when the receipt of the data
 *     results in an overflow event.
 * - 1 - If the receiver buffer overflows, a NACK is automatically sent on a
 *     received character.
 */
/*@{*/
#define BP_UART_C7816_ONACK  (4U)          /*!< Bit position for UART_C7816_ONACK. */
#define BM_UART_C7816_ONACK  (0x10U)       /*!< Bit mask for UART_C7816_ONACK. */
#define BS_UART_C7816_ONACK  (1U)          /*!< Bit field size in bits for UART_C7816_ONACK. */

/*! @brief Read current value of the UART_C7816_ONACK field. */
#define BR_UART_C7816_ONACK(x) (BITBAND_ACCESS8(HW_UART_C7816_ADDR(x), BP_UART_C7816_ONACK))

/*! @brief Format value for bitfield UART_C7816_ONACK. */
#define BF_UART_C7816_ONACK(v) ((uint8_t)((uint8_t)(v) << BP_UART_C7816_ONACK) & BM_UART_C7816_ONACK)

/*! @brief Set the ONACK field to a new value. */
#define BW_UART_C7816_ONACK(x, v) (BITBAND_ACCESS8(HW_UART_C7816_ADDR(x), BP_UART_C7816_ONACK) = (v))
/*@}*/

/*******************************************************************************
 * HW_UART_IE7816 - UART 7816 Interrupt Enable Register
 ******************************************************************************/

/*!
 * @brief HW_UART_IE7816 - UART 7816 Interrupt Enable Register (RW)
 *
 * Reset value: 0x00U
 *
 * The IE7816 register controls which flags result in an interrupt being issued.
 * This register is specific to 7816 functionality, the corresponding flags that
 * drive the interrupts will not assert when 7816E is not set/enabled. However,
 * these flags may remain set if they asserted while 7816E was set and not
 * subsequently cleared. This register maybe read or written at anytime.
 */
typedef union _hw_uart_ie7816
{
    uint8_t U;
    struct _hw_uart_ie7816_bitfields
    {
        uint8_t RXTE : 1;              /*!< [0] Receive Threshold Exceeded Interrupt
                                        * Enable */
        uint8_t TXTE : 1;              /*!< [1] Transmit Threshold Exceeded Interrupt
                                        * Enable */
        uint8_t GTVE : 1;              /*!< [2] Guard Timer Violated Interrupt Enable */
        uint8_t RESERVED0 : 1;         /*!< [3]  */
        uint8_t INITDE : 1;            /*!< [4] Initial Character Detected Interrupt
                                        * Enable */
        uint8_t BWTE : 1;              /*!< [5] Block Wait Timer Interrupt Enable */
        uint8_t CWTE : 1;              /*!< [6] Character Wait Timer Interrupt Enable */
        uint8_t WTE : 1;               /*!< [7] Wait Timer Interrupt Enable */
    } B;
} hw_uart_ie7816_t;

/*!
 * @name Constants and macros for entire UART_IE7816 register
 */
/*@{*/
#define HW_UART_IE7816_ADDR(x)   ((x) + 0x19U)

#define HW_UART_IE7816(x)        (*(__IO hw_uart_ie7816_t *) HW_UART_IE7816_ADDR(x))
#define HW_UART_IE7816_RD(x)     (HW_UART_IE7816(x).U)
#define HW_UART_IE7816_WR(x, v)  (HW_UART_IE7816(x).U = (v))
#define HW_UART_IE7816_SET(x, v) (HW_UART_IE7816_WR(x, HW_UART_IE7816_RD(x) |  (v)))
#define HW_UART_IE7816_CLR(x, v) (HW_UART_IE7816_WR(x, HW_UART_IE7816_RD(x) & ~(v)))
#define HW_UART_IE7816_TOG(x, v) (HW_UART_IE7816_WR(x, HW_UART_IE7816_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual UART_IE7816 bitfields
 */

/*!
 * @name Register UART_IE7816, field RXTE[0] (RW)
 *
 * Values:
 * - 0 - The assertion of the IS7816[RXT] bit will not result in the generation
 *     of an interrupt.
 * - 1 - The assertion of the IS7816[RXT] bit will result in the generation of
 *     an interrupt.
 */
/*@{*/
#define BP_UART_IE7816_RXTE  (0U)          /*!< Bit position for UART_IE7816_RXTE. */
#define BM_UART_IE7816_RXTE  (0x01U)       /*!< Bit mask for UART_IE7816_RXTE. */
#define BS_UART_IE7816_RXTE  (1U)          /*!< Bit field size in bits for UART_IE7816_RXTE. */

/*! @brief Read current value of the UART_IE7816_RXTE field. */
#define BR_UART_IE7816_RXTE(x) (BITBAND_ACCESS8(HW_UART_IE7816_ADDR(x), BP_UART_IE7816_RXTE))

/*! @brief Format value for bitfield UART_IE7816_RXTE. */
#define BF_UART_IE7816_RXTE(v) ((uint8_t)((uint8_t)(v) << BP_UART_IE7816_RXTE) & BM_UART_IE7816_RXTE)

/*! @brief Set the RXTE field to a new value. */
#define BW_UART_IE7816_RXTE(x, v) (BITBAND_ACCESS8(HW_UART_IE7816_ADDR(x), BP_UART_IE7816_RXTE) = (v))
/*@}*/

/*!
 * @name Register UART_IE7816, field TXTE[1] (RW)
 *
 * Values:
 * - 0 - The assertion of the IS7816[TXT] bit will not result in the generation
 *     of an interrupt.
 * - 1 - The assertion of the IS7816[TXT] bit will result in the generation of
 *     an interrupt.
 */
/*@{*/
#define BP_UART_IE7816_TXTE  (1U)          /*!< Bit position for UART_IE7816_TXTE. */
#define BM_UART_IE7816_TXTE  (0x02U)       /*!< Bit mask for UART_IE7816_TXTE. */
#define BS_UART_IE7816_TXTE  (1U)          /*!< Bit field size in bits for UART_IE7816_TXTE. */

/*! @brief Read current value of the UART_IE7816_TXTE field. */
#define BR_UART_IE7816_TXTE(x) (BITBAND_ACCESS8(HW_UART_IE7816_ADDR(x), BP_UART_IE7816_TXTE))

/*! @brief Format value for bitfield UART_IE7816_TXTE. */
#define BF_UART_IE7816_TXTE(v) ((uint8_t)((uint8_t)(v) << BP_UART_IE7816_TXTE) & BM_UART_IE7816_TXTE)

/*! @brief Set the TXTE field to a new value. */
#define BW_UART_IE7816_TXTE(x, v) (BITBAND_ACCESS8(HW_UART_IE7816_ADDR(x), BP_UART_IE7816_TXTE) = (v))
/*@}*/

/*!
 * @name Register UART_IE7816, field GTVE[2] (RW)
 *
 * Values:
 * - 0 - The assertion of the IS7816[GTV] bit will not result in the generation
 *     of an interrupt.
 * - 1 - The assertion of the IS7816[GTV] bit will result in the generation of
 *     an interrupt.
 */
/*@{*/
#define BP_UART_IE7816_GTVE  (2U)          /*!< Bit position for UART_IE7816_GTVE. */
#define BM_UART_IE7816_GTVE  (0x04U)       /*!< Bit mask for UART_IE7816_GTVE. */
#define BS_UART_IE7816_GTVE  (1U)          /*!< Bit field size in bits for UART_IE7816_GTVE. */

/*! @brief Read current value of the UART_IE7816_GTVE field. */
#define BR_UART_IE7816_GTVE(x) (BITBAND_ACCESS8(HW_UART_IE7816_ADDR(x), BP_UART_IE7816_GTVE))

/*! @brief Format value for bitfield UART_IE7816_GTVE. */
#define BF_UART_IE7816_GTVE(v) ((uint8_t)((uint8_t)(v) << BP_UART_IE7816_GTVE) & BM_UART_IE7816_GTVE)

/*! @brief Set the GTVE field to a new value. */
#define BW_UART_IE7816_GTVE(x, v) (BITBAND_ACCESS8(HW_UART_IE7816_ADDR(x), BP_UART_IE7816_GTVE) = (v))
/*@}*/

/*!
 * @name Register UART_IE7816, field INITDE[4] (RW)
 *
 * Values:
 * - 0 - The assertion of the IS7816[INITD] bit will not result in the
 *     generation of an interrupt.
 * - 1 - The assertion of the IS7816[INITD] bit will result in the generation of
 *     an interrupt.
 */
/*@{*/
#define BP_UART_IE7816_INITDE (4U)         /*!< Bit position for UART_IE7816_INITDE. */
#define BM_UART_IE7816_INITDE (0x10U)      /*!< Bit mask for UART_IE7816_INITDE. */
#define BS_UART_IE7816_INITDE (1U)         /*!< Bit field size in bits for UART_IE7816_INITDE. */

/*! @brief Read current value of the UART_IE7816_INITDE field. */
#define BR_UART_IE7816_INITDE(x) (BITBAND_ACCESS8(HW_UART_IE7816_ADDR(x), BP_UART_IE7816_INITDE))

/*! @brief Format value for bitfield UART_IE7816_INITDE. */
#define BF_UART_IE7816_INITDE(v) ((uint8_t)((uint8_t)(v) << BP_UART_IE7816_INITDE) & BM_UART_IE7816_INITDE)

/*! @brief Set the INITDE field to a new value. */
#define BW_UART_IE7816_INITDE(x, v) (BITBAND_ACCESS8(HW_UART_IE7816_ADDR(x), BP_UART_IE7816_INITDE) = (v))
/*@}*/

/*!
 * @name Register UART_IE7816, field BWTE[5] (RW)
 *
 * Values:
 * - 0 - The assertion of the IS7816[BWT] bit will not result in the generation
 *     of an interrupt.
 * - 1 - The assertion of the IS7816[BWT] bit will result in the generation of
 *     an interrupt.
 */
/*@{*/
#define BP_UART_IE7816_BWTE  (5U)          /*!< Bit position for UART_IE7816_BWTE. */
#define BM_UART_IE7816_BWTE  (0x20U)       /*!< Bit mask for UART_IE7816_BWTE. */
#define BS_UART_IE7816_BWTE  (1U)          /*!< Bit field size in bits for UART_IE7816_BWTE. */

/*! @brief Read current value of the UART_IE7816_BWTE field. */
#define BR_UART_IE7816_BWTE(x) (BITBAND_ACCESS8(HW_UART_IE7816_ADDR(x), BP_UART_IE7816_BWTE))

/*! @brief Format value for bitfield UART_IE7816_BWTE. */
#define BF_UART_IE7816_BWTE(v) ((uint8_t)((uint8_t)(v) << BP_UART_IE7816_BWTE) & BM_UART_IE7816_BWTE)

/*! @brief Set the BWTE field to a new value. */
#define BW_UART_IE7816_BWTE(x, v) (BITBAND_ACCESS8(HW_UART_IE7816_ADDR(x), BP_UART_IE7816_BWTE) = (v))
/*@}*/

/*!
 * @name Register UART_IE7816, field CWTE[6] (RW)
 *
 * Values:
 * - 0 - The assertion of the IS7816[CWT] bit will not result in the generation
 *     of an interrupt.
 * - 1 - The assertion of the IS7816[CWT] bit will result in the generation of
 *     an interrupt.
 */
/*@{*/
#define BP_UART_IE7816_CWTE  (6U)          /*!< Bit position for UART_IE7816_CWTE. */
#define BM_UART_IE7816_CWTE  (0x40U)       /*!< Bit mask for UART_IE7816_CWTE. */
#define BS_UART_IE7816_CWTE  (1U)          /*!< Bit field size in bits for UART_IE7816_CWTE. */

/*! @brief Read current value of the UART_IE7816_CWTE field. */
#define BR_UART_IE7816_CWTE(x) (BITBAND_ACCESS8(HW_UART_IE7816_ADDR(x), BP_UART_IE7816_CWTE))

/*! @brief Format value for bitfield UART_IE7816_CWTE. */
#define BF_UART_IE7816_CWTE(v) ((uint8_t)((uint8_t)(v) << BP_UART_IE7816_CWTE) & BM_UART_IE7816_CWTE)

/*! @brief Set the CWTE field to a new value. */
#define BW_UART_IE7816_CWTE(x, v) (BITBAND_ACCESS8(HW_UART_IE7816_ADDR(x), BP_UART_IE7816_CWTE) = (v))
/*@}*/

/*!
 * @name Register UART_IE7816, field WTE[7] (RW)
 *
 * Values:
 * - 0 - The assertion of the IS7816[WT] bit will not result in the generation
 *     of an interrupt.
 * - 1 - The assertion of the IS7816[WT] bit will result in the generation of an
 *     interrupt.
 */
/*@{*/
#define BP_UART_IE7816_WTE   (7U)          /*!< Bit position for UART_IE7816_WTE. */
#define BM_UART_IE7816_WTE   (0x80U)       /*!< Bit mask for UART_IE7816_WTE. */
#define BS_UART_IE7816_WTE   (1U)          /*!< Bit field size in bits for UART_IE7816_WTE. */

/*! @brief Read current value of the UART_IE7816_WTE field. */
#define BR_UART_IE7816_WTE(x) (BITBAND_ACCESS8(HW_UART_IE7816_ADDR(x), BP_UART_IE7816_WTE))

/*! @brief Format value for bitfield UART_IE7816_WTE. */
#define BF_UART_IE7816_WTE(v) ((uint8_t)((uint8_t)(v) << BP_UART_IE7816_WTE) & BM_UART_IE7816_WTE)

/*! @brief Set the WTE field to a new value. */
#define BW_UART_IE7816_WTE(x, v) (BITBAND_ACCESS8(HW_UART_IE7816_ADDR(x), BP_UART_IE7816_WTE) = (v))
/*@}*/

/*******************************************************************************
 * HW_UART_IS7816 - UART 7816 Interrupt Status Register
 ******************************************************************************/

/*!
 * @brief HW_UART_IS7816 - UART 7816 Interrupt Status Register (RW)
 *
 * Reset value: 0x00U
 *
 * The IS7816 register provides a mechanism to read and clear the interrupt
 * flags. All flags/interrupts are cleared by writing a "1" to the bit location.
 * Writing a "0" has no effect. All bits are "sticky", meaning they only indicate
 * that the flag condition occurred since the last time the bit was cleared not that
 * the condition currently exists. The status flags are set regardless of if the
 * corresponding bit in the IC7816 is set or cleared, the IC7816 only controls
 * if a interrupt is issued to the host processor. This register is specific to
 * 7816 functionality and the values in this register have no affect on UART
 * operation and should be ignored if 7816E is not set/enabled. This register may be
 * read or written at anytime.
 */
typedef union _hw_uart_is7816
{
    uint8_t U;
    struct _hw_uart_is7816_bitfields
    {
        uint8_t RXT : 1;               /*!< [0] Receive Threshold Exceeded Interrupt */
        uint8_t TXT : 1;               /*!< [1] Transmit Threshold Exceeded Interrupt */
        uint8_t GTV : 1;               /*!< [2] Guard Timer Violated Interrupt */
        uint8_t RESERVED0 : 1;         /*!< [3]  */
        uint8_t INITD : 1;             /*!< [4] Initial Character Detected Interrupt */
        uint8_t BWT : 1;               /*!< [5] Block Wait Timer Interrupt */
        uint8_t CWT : 1;               /*!< [6] Character Wait Timer Interrupt */
        uint8_t WT : 1;                /*!< [7] Wait Timer Interrupt */
    } B;
} hw_uart_is7816_t;

/*!
 * @name Constants and macros for entire UART_IS7816 register
 */
/*@{*/
#define HW_UART_IS7816_ADDR(x)   ((x) + 0x1AU)

#define HW_UART_IS7816(x)        (*(__IO hw_uart_is7816_t *) HW_UART_IS7816_ADDR(x))
#define HW_UART_IS7816_RD(x)     (HW_UART_IS7816(x).U)
#define HW_UART_IS7816_WR(x, v)  (HW_UART_IS7816(x).U = (v))
#define HW_UART_IS7816_SET(x, v) (HW_UART_IS7816_WR(x, HW_UART_IS7816_RD(x) |  (v)))
#define HW_UART_IS7816_CLR(x, v) (HW_UART_IS7816_WR(x, HW_UART_IS7816_RD(x) & ~(v)))
#define HW_UART_IS7816_TOG(x, v) (HW_UART_IS7816_WR(x, HW_UART_IS7816_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual UART_IS7816 bitfields
 */

/*!
 * @name Register UART_IS7816, field RXT[0] (RW)
 *
 * This flag indicates that there were more than ET7816[RXTHRESHOLD] consecutive
 * NACKS generated in response to parity errors on received data. This flag
 * requires ANACK to be set. Additionally, this flag only asserts when C7816[TTYPE] =
 * 0. Clearing this bit also resets the counter keeping track of consecutive
 * NACKS. The UART will continue to attempt to receive data regardless of if this
 * flag is set. If 7816E is cleared/disabled, RE is cleared/disabled, C7816[TTYPE]
 * = 1 or packet is received without needing to issue a NACK, the internal NACK
 * detection counter is cleared and the count restarts from zero on the next
 * transmitted NACK. This interrupt is cleared by writing `1'.
 *
 * Values:
 * - 0 - The number of consecutive NACKS generated as a result of parity errors
 *     and buffer overruns is less than or equal to the value in
 *     ET7816[RXTHRESHOLD].
 * - 1 - The number of consecutive NACKS generated as a result of parity errors
 *     and buffer overruns is greater than the value in ET7816[RXTHRESHOLD].
 */
/*@{*/
#define BP_UART_IS7816_RXT   (0U)          /*!< Bit position for UART_IS7816_RXT. */
#define BM_UART_IS7816_RXT   (0x01U)       /*!< Bit mask for UART_IS7816_RXT. */
#define BS_UART_IS7816_RXT   (1U)          /*!< Bit field size in bits for UART_IS7816_RXT. */

/*! @brief Read current value of the UART_IS7816_RXT field. */
#define BR_UART_IS7816_RXT(x) (BITBAND_ACCESS8(HW_UART_IS7816_ADDR(x), BP_UART_IS7816_RXT))

/*! @brief Format value for bitfield UART_IS7816_RXT. */
#define BF_UART_IS7816_RXT(v) ((uint8_t)((uint8_t)(v) << BP_UART_IS7816_RXT) & BM_UART_IS7816_RXT)

/*! @brief Set the RXT field to a new value. */
#define BW_UART_IS7816_RXT(x, v) (BITBAND_ACCESS8(HW_UART_IS7816_ADDR(x), BP_UART_IS7816_RXT) = (v))
/*@}*/

/*!
 * @name Register UART_IS7816, field TXT[1] (RW)
 *
 * This flag indicates that the transmit NACK threshold has been exceeded as
 * indicated by the ET7816[TXTHRESHOLD] field. Regardless if this flag is set, the
 * UART will continue to retransmit indefinitely. This flag only asserts when
 * C7816[TTYPE] = 0. If 7816E is cleared/disabled, ANACK is cleared/disabled, C2[TE]
 * is cleared/disabled, C7816[TTYPE] = 1 or packet is transferred without
 * receiving a NACK the internal NACK detection counter is cleared and the count
 * restarts from zero on the next received NACK. This interrupt is cleared by writing
 * `1'.
 *
 * Values:
 * - 0 - The number of retries and corresponding NACKS does not exceed the value
 *     in the ET7816[TXTHRESHOLD] field.
 * - 1 - The number of retries and corresponding NACKS exceeds the value in the
 *     ET7816[TXTHRESHOLD] field.
 */
/*@{*/
#define BP_UART_IS7816_TXT   (1U)          /*!< Bit position for UART_IS7816_TXT. */
#define BM_UART_IS7816_TXT   (0x02U)       /*!< Bit mask for UART_IS7816_TXT. */
#define BS_UART_IS7816_TXT   (1U)          /*!< Bit field size in bits for UART_IS7816_TXT. */

/*! @brief Read current value of the UART_IS7816_TXT field. */
#define BR_UART_IS7816_TXT(x) (BITBAND_ACCESS8(HW_UART_IS7816_ADDR(x), BP_UART_IS7816_TXT))

/*! @brief Format value for bitfield UART_IS7816_TXT. */
#define BF_UART_IS7816_TXT(v) ((uint8_t)((uint8_t)(v) << BP_UART_IS7816_TXT) & BM_UART_IS7816_TXT)

/*! @brief Set the TXT field to a new value. */
#define BW_UART_IS7816_TXT(x, v) (BITBAND_ACCESS8(HW_UART_IS7816_ADDR(x), BP_UART_IS7816_TXT) = (v))
/*@}*/

/*!
 * @name Register UART_IS7816, field GTV[2] (RW)
 *
 * This flag indicates that one or more of the character guard time, block guard
 * time or guard time were violated. This interrupt is cleared by writing `1'.
 *
 * Values:
 * - 0 - A guard time (GT, CGT or BGT) has not been violated.
 * - 1 - A guard time (GT, CGT or BGT) has been violated.
 */
/*@{*/
#define BP_UART_IS7816_GTV   (2U)          /*!< Bit position for UART_IS7816_GTV. */
#define BM_UART_IS7816_GTV   (0x04U)       /*!< Bit mask for UART_IS7816_GTV. */
#define BS_UART_IS7816_GTV   (1U)          /*!< Bit field size in bits for UART_IS7816_GTV. */

/*! @brief Read current value of the UART_IS7816_GTV field. */
#define BR_UART_IS7816_GTV(x) (BITBAND_ACCESS8(HW_UART_IS7816_ADDR(x), BP_UART_IS7816_GTV))

/*! @brief Format value for bitfield UART_IS7816_GTV. */
#define BF_UART_IS7816_GTV(v) ((uint8_t)((uint8_t)(v) << BP_UART_IS7816_GTV) & BM_UART_IS7816_GTV)

/*! @brief Set the GTV field to a new value. */
#define BW_UART_IS7816_GTV(x, v) (BITBAND_ACCESS8(HW_UART_IS7816_ADDR(x), BP_UART_IS7816_GTV) = (v))
/*@}*/

/*!
 * @name Register UART_IS7816, field INITD[4] (RW)
 *
 * This flag indicates that a valid initial character was received. This
 * interrupt is cleared by writing `1'.
 *
 * Values:
 * - 0 - A valid initial character has not been received.
 * - 1 - A valid initial character has been received.
 */
/*@{*/
#define BP_UART_IS7816_INITD (4U)          /*!< Bit position for UART_IS7816_INITD. */
#define BM_UART_IS7816_INITD (0x10U)       /*!< Bit mask for UART_IS7816_INITD. */
#define BS_UART_IS7816_INITD (1U)          /*!< Bit field size in bits for UART_IS7816_INITD. */

/*! @brief Read current value of the UART_IS7816_INITD field. */
#define BR_UART_IS7816_INITD(x) (BITBAND_ACCESS8(HW_UART_IS7816_ADDR(x), BP_UART_IS7816_INITD))

/*! @brief Format value for bitfield UART_IS7816_INITD. */
#define BF_UART_IS7816_INITD(v) ((uint8_t)((uint8_t)(v) << BP_UART_IS7816_INITD) & BM_UART_IS7816_INITD)

/*! @brief Set the INITD field to a new value. */
#define BW_UART_IS7816_INITD(x, v) (BITBAND_ACCESS8(HW_UART_IS7816_ADDR(x), BP_UART_IS7816_INITD) = (v))
/*@}*/

/*!
 * @name Register UART_IS7816, field BWT[5] (RW)
 *
 * This flag indicates that the block wait time, the time between the leading
 * edge of first received character of a block and the leading edge of the last
 * character the previously transmitted block. This flag only asserts when
 * C7816[TTYPE] = 1.This interrupt is cleared by writing '1'.
 *
 * Values:
 * - 0 - Block wait time (BWT) has not been violated.
 * - 1 - Block wait tTime (BWT) has been violated.
 */
/*@{*/
#define BP_UART_IS7816_BWT   (5U)          /*!< Bit position for UART_IS7816_BWT. */
#define BM_UART_IS7816_BWT   (0x20U)       /*!< Bit mask for UART_IS7816_BWT. */
#define BS_UART_IS7816_BWT   (1U)          /*!< Bit field size in bits for UART_IS7816_BWT. */

/*! @brief Read current value of the UART_IS7816_BWT field. */
#define BR_UART_IS7816_BWT(x) (BITBAND_ACCESS8(HW_UART_IS7816_ADDR(x), BP_UART_IS7816_BWT))

/*! @brief Format value for bitfield UART_IS7816_BWT. */
#define BF_UART_IS7816_BWT(v) ((uint8_t)((uint8_t)(v) << BP_UART_IS7816_BWT) & BM_UART_IS7816_BWT)

/*! @brief Set the BWT field to a new value. */
#define BW_UART_IS7816_BWT(x, v) (BITBAND_ACCESS8(HW_UART_IS7816_ADDR(x), BP_UART_IS7816_BWT) = (v))
/*@}*/

/*!
 * @name Register UART_IS7816, field CWT[6] (RW)
 *
 * This flag indicates that the character wait time, the time between the
 * leading edges of two consecutive characters in a block has exceed the programed
 * value. This flag only asserts when C7816[TTYPE] = 1. This interrupt is cleared by
 * writing `1'.
 *
 * Values:
 * - 0 - Character wait time (CWT) has not been violated.
 * - 1 - Character wait time (CWT) has been violated.
 */
/*@{*/
#define BP_UART_IS7816_CWT   (6U)          /*!< Bit position for UART_IS7816_CWT. */
#define BM_UART_IS7816_CWT   (0x40U)       /*!< Bit mask for UART_IS7816_CWT. */
#define BS_UART_IS7816_CWT   (1U)          /*!< Bit field size in bits for UART_IS7816_CWT. */

/*! @brief Read current value of the UART_IS7816_CWT field. */
#define BR_UART_IS7816_CWT(x) (BITBAND_ACCESS8(HW_UART_IS7816_ADDR(x), BP_UART_IS7816_CWT))

/*! @brief Format value for bitfield UART_IS7816_CWT. */
#define BF_UART_IS7816_CWT(v) ((uint8_t)((uint8_t)(v) << BP_UART_IS7816_CWT) & BM_UART_IS7816_CWT)

/*! @brief Set the CWT field to a new value. */
#define BW_UART_IS7816_CWT(x, v) (BITBAND_ACCESS8(HW_UART_IS7816_ADDR(x), BP_UART_IS7816_CWT) = (v))
/*@}*/

/*!
 * @name Register UART_IS7816, field WT[7] (RW)
 *
 * This flag indicates that the wait time, the time between the leading edge of
 * a character being transmitted and the leading edge of the next response
 * character has exceeded the programed value. This flag only asserts when C7816[TTYPE]
 * = 0. This interrupt is cleared by writing `1'.
 *
 * Values:
 * - 0 - Wait time (WT) has not been violated.
 * - 1 - Wait time (WT) has been violated.
 */
/*@{*/
#define BP_UART_IS7816_WT    (7U)          /*!< Bit position for UART_IS7816_WT. */
#define BM_UART_IS7816_WT    (0x80U)       /*!< Bit mask for UART_IS7816_WT. */
#define BS_UART_IS7816_WT    (1U)          /*!< Bit field size in bits for UART_IS7816_WT. */

/*! @brief Read current value of the UART_IS7816_WT field. */
#define BR_UART_IS7816_WT(x) (BITBAND_ACCESS8(HW_UART_IS7816_ADDR(x), BP_UART_IS7816_WT))

/*! @brief Format value for bitfield UART_IS7816_WT. */
#define BF_UART_IS7816_WT(v) ((uint8_t)((uint8_t)(v) << BP_UART_IS7816_WT) & BM_UART_IS7816_WT)

/*! @brief Set the WT field to a new value. */
#define BW_UART_IS7816_WT(x, v) (BITBAND_ACCESS8(HW_UART_IS7816_ADDR(x), BP_UART_IS7816_WT) = (v))
/*@}*/

/*******************************************************************************
 * HW_UART_WP7816T0 - UART 7816 Wait Parameter Register
 ******************************************************************************/

/*!
 * @brief HW_UART_WP7816T0 - UART 7816 Wait Parameter Register (RW)
 *
 * Reset value: 0x0AU
 *
 * The WP7816 register contains constants used in the generation of various wait
 * timer counters. To save register space this register is used differently when
 * C7816[TTYPE] = 0 and C7816[TTYPE] = 1. This register may be read at anytime.
 * This register must only be written when C7816[ISO_7816E] is not set.
 */
typedef union _hw_uart_wp7816t0
{
    uint8_t U;
    struct _hw_uart_wp7816t0_bitfields
    {
        uint8_t WI : 8;                /*!< [7:0] Wait Timer Interrupt (C7816[TTYPE] = 0) */
    } B;
} hw_uart_wp7816t0_t;

/*!
 * @name Constants and macros for entire UART_WP7816T0 register
 */
/*@{*/
#define HW_UART_WP7816T0_ADDR(x) ((x) + 0x1BU)

#define HW_UART_WP7816T0(x)      (*(__IO hw_uart_wp7816t0_t *) HW_UART_WP7816T0_ADDR(x))
#define HW_UART_WP7816T0_RD(x)   (HW_UART_WP7816T0(x).U)
#define HW_UART_WP7816T0_WR(x, v) (HW_UART_WP7816T0(x).U = (v))
#define HW_UART_WP7816T0_SET(x, v) (HW_UART_WP7816T0_WR(x, HW_UART_WP7816T0_RD(x) |  (v)))
#define HW_UART_WP7816T0_CLR(x, v) (HW_UART_WP7816T0_WR(x, HW_UART_WP7816T0_RD(x) & ~(v)))
#define HW_UART_WP7816T0_TOG(x, v) (HW_UART_WP7816T0_WR(x, HW_UART_WP7816T0_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual UART_WP7816T0 bitfields
 */

/*!
 * @name Register UART_WP7816T0, field WI[7:0] (RW)
 *
 * This value is used to calculate the value used for the WT counter. It
 * represents a value between 1 and 255. The value of zero is not valid. This value is
 * only used when C7816[TTYPE] = 0. See Wait time and guard time parameters.
 */
/*@{*/
#define BP_UART_WP7816T0_WI  (0U)          /*!< Bit position for UART_WP7816T0_WI. */
#define BM_UART_WP7816T0_WI  (0xFFU)       /*!< Bit mask for UART_WP7816T0_WI. */
#define BS_UART_WP7816T0_WI  (8U)          /*!< Bit field size in bits for UART_WP7816T0_WI. */

/*! @brief Read current value of the UART_WP7816T0_WI field. */
#define BR_UART_WP7816T0_WI(x) (HW_UART_WP7816T0(x).U)

/*! @brief Format value for bitfield UART_WP7816T0_WI. */
#define BF_UART_WP7816T0_WI(v) ((uint8_t)((uint8_t)(v) << BP_UART_WP7816T0_WI) & BM_UART_WP7816T0_WI)

/*! @brief Set the WI field to a new value. */
#define BW_UART_WP7816T0_WI(x, v) (HW_UART_WP7816T0_WR(x, v))
/*@}*/
/*******************************************************************************
 * HW_UART_WP7816T1 - UART 7816 Wait Parameter Register
 ******************************************************************************/

/*!
 * @brief HW_UART_WP7816T1 - UART 7816 Wait Parameter Register (RW)
 *
 * Reset value: 0x0AU
 *
 * The WP7816 register contains constants used in the generation of various wait
 * timer counters. To save register space this register is used differently when
 * C7816[TTYPE] = 0 and C7816[TTYPE] = 1. This register maybe read at anytime.
 * This register must only be written when C7816[ISO_7816E] is not set.
 */
typedef union _hw_uart_wp7816t1
{
    uint8_t U;
    struct _hw_uart_wp7816t1_bitfields
    {
        uint8_t BWI : 4;               /*!< [3:0] Block Wait Time Integer(C7816[TTYPE] = 1)
                                        * */
        uint8_t CWI : 4;               /*!< [7:4] Character Wait Time Integer (C7816[TTYPE]
                                        * = 1) */
    } B;
} hw_uart_wp7816t1_t;

/*!
 * @name Constants and macros for entire UART_WP7816T1 register
 */
/*@{*/
#define HW_UART_WP7816T1_ADDR(x) ((x) + 0x1BU)

#define HW_UART_WP7816T1(x)      (*(__IO hw_uart_wp7816t1_t *) HW_UART_WP7816T1_ADDR(x))
#define HW_UART_WP7816T1_RD(x)   (HW_UART_WP7816T1(x).U)
#define HW_UART_WP7816T1_WR(x, v) (HW_UART_WP7816T1(x).U = (v))
#define HW_UART_WP7816T1_SET(x, v) (HW_UART_WP7816T1_WR(x, HW_UART_WP7816T1_RD(x) |  (v)))
#define HW_UART_WP7816T1_CLR(x, v) (HW_UART_WP7816T1_WR(x, HW_UART_WP7816T1_RD(x) & ~(v)))
#define HW_UART_WP7816T1_TOG(x, v) (HW_UART_WP7816T1_WR(x, HW_UART_WP7816T1_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual UART_WP7816T1 bitfields
 */

/*!
 * @name Register UART_WP7816T1, field BWI[3:0] (RW)
 *
 * This value is used to calculate the value used for the BWT counter. It
 * represent a value between 0 and 15. This value is only used when C7816[TTYPE] = 1.
 * See Wait time and guard time parameters.
 */
/*@{*/
#define BP_UART_WP7816T1_BWI (0U)          /*!< Bit position for UART_WP7816T1_BWI. */
#define BM_UART_WP7816T1_BWI (0x0FU)       /*!< Bit mask for UART_WP7816T1_BWI. */
#define BS_UART_WP7816T1_BWI (4U)          /*!< Bit field size in bits for UART_WP7816T1_BWI. */

/*! @brief Read current value of the UART_WP7816T1_BWI field. */
#define BR_UART_WP7816T1_BWI(x) (HW_UART_WP7816T1(x).B.BWI)

/*! @brief Format value for bitfield UART_WP7816T1_BWI. */
#define BF_UART_WP7816T1_BWI(v) ((uint8_t)((uint8_t)(v) << BP_UART_WP7816T1_BWI) & BM_UART_WP7816T1_BWI)

/*! @brief Set the BWI field to a new value. */
#define BW_UART_WP7816T1_BWI(x, v) (HW_UART_WP7816T1_WR(x, (HW_UART_WP7816T1_RD(x) & ~BM_UART_WP7816T1_BWI) | BF_UART_WP7816T1_BWI(v)))
/*@}*/

/*!
 * @name Register UART_WP7816T1, field CWI[7:4] (RW)
 *
 * This value is used to calculate the value used for the CWT counter. It
 * represents a value between 0 and 15. This value is only used when C7816[TTYPE] = 1.
 * See Wait time and guard time parameters.
 */
/*@{*/
#define BP_UART_WP7816T1_CWI (4U)          /*!< Bit position for UART_WP7816T1_CWI. */
#define BM_UART_WP7816T1_CWI (0xF0U)       /*!< Bit mask for UART_WP7816T1_CWI. */
#define BS_UART_WP7816T1_CWI (4U)          /*!< Bit field size in bits for UART_WP7816T1_CWI. */

/*! @brief Read current value of the UART_WP7816T1_CWI field. */
#define BR_UART_WP7816T1_CWI(x) (HW_UART_WP7816T1(x).B.CWI)

/*! @brief Format value for bitfield UART_WP7816T1_CWI. */
#define BF_UART_WP7816T1_CWI(v) ((uint8_t)((uint8_t)(v) << BP_UART_WP7816T1_CWI) & BM_UART_WP7816T1_CWI)

/*! @brief Set the CWI field to a new value. */
#define BW_UART_WP7816T1_CWI(x, v) (HW_UART_WP7816T1_WR(x, (HW_UART_WP7816T1_RD(x) & ~BM_UART_WP7816T1_CWI) | BF_UART_WP7816T1_CWI(v)))
/*@}*/

/*******************************************************************************
 * HW_UART_WN7816 - UART 7816 Wait N Register
 ******************************************************************************/

/*!
 * @brief HW_UART_WN7816 - UART 7816 Wait N Register (RW)
 *
 * Reset value: 0x00U
 *
 * The WN7816 register contains a parameter that is used in the calculation of
 * the guard time counter. This register may be read at anytime. This register
 * must only be written when C7816[ISO_7816E] is not set.
 */
typedef union _hw_uart_wn7816
{
    uint8_t U;
    struct _hw_uart_wn7816_bitfields
    {
        uint8_t GTN : 8;               /*!< [7:0] Guard Band N */
    } B;
} hw_uart_wn7816_t;

/*!
 * @name Constants and macros for entire UART_WN7816 register
 */
/*@{*/
#define HW_UART_WN7816_ADDR(x)   ((x) + 0x1CU)

#define HW_UART_WN7816(x)        (*(__IO hw_uart_wn7816_t *) HW_UART_WN7816_ADDR(x))
#define HW_UART_WN7816_RD(x)     (HW_UART_WN7816(x).U)
#define HW_UART_WN7816_WR(x, v)  (HW_UART_WN7816(x).U = (v))
#define HW_UART_WN7816_SET(x, v) (HW_UART_WN7816_WR(x, HW_UART_WN7816_RD(x) |  (v)))
#define HW_UART_WN7816_CLR(x, v) (HW_UART_WN7816_WR(x, HW_UART_WN7816_RD(x) & ~(v)))
#define HW_UART_WN7816_TOG(x, v) (HW_UART_WN7816_WR(x, HW_UART_WN7816_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual UART_WN7816 bitfields
 */

/*!
 * @name Register UART_WN7816, field GTN[7:0] (RW)
 *
 * This register field defines a parameter used in the calculation of GT, CGT
 * and BGT counters. The value represents an integer number 0-255. See Wait time
 * and guard time parameters.
 */
/*@{*/
#define BP_UART_WN7816_GTN   (0U)          /*!< Bit position for UART_WN7816_GTN. */
#define BM_UART_WN7816_GTN   (0xFFU)       /*!< Bit mask for UART_WN7816_GTN. */
#define BS_UART_WN7816_GTN   (8U)          /*!< Bit field size in bits for UART_WN7816_GTN. */

/*! @brief Read current value of the UART_WN7816_GTN field. */
#define BR_UART_WN7816_GTN(x) (HW_UART_WN7816(x).U)

/*! @brief Format value for bitfield UART_WN7816_GTN. */
#define BF_UART_WN7816_GTN(v) ((uint8_t)((uint8_t)(v) << BP_UART_WN7816_GTN) & BM_UART_WN7816_GTN)

/*! @brief Set the GTN field to a new value. */
#define BW_UART_WN7816_GTN(x, v) (HW_UART_WN7816_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_UART_WF7816 - UART 7816 Wait FD Register
 ******************************************************************************/

/*!
 * @brief HW_UART_WF7816 - UART 7816 Wait FD Register (RW)
 *
 * Reset value: 0x01U
 *
 * The WF7816 contains parameters that are used in the generation of various
 * counters including GT, CGT, BGT, WT and BWT. This register may be read from at
 * anytime. This register must only be written to when C7816[ISO_7816E] is not set.
 */
typedef union _hw_uart_wf7816
{
    uint8_t U;
    struct _hw_uart_wf7816_bitfields
    {
        uint8_t GTFD : 8;              /*!< [7:0] FD Multiplier */
    } B;
} hw_uart_wf7816_t;

/*!
 * @name Constants and macros for entire UART_WF7816 register
 */
/*@{*/
#define HW_UART_WF7816_ADDR(x)   ((x) + 0x1DU)

#define HW_UART_WF7816(x)        (*(__IO hw_uart_wf7816_t *) HW_UART_WF7816_ADDR(x))
#define HW_UART_WF7816_RD(x)     (HW_UART_WF7816(x).U)
#define HW_UART_WF7816_WR(x, v)  (HW_UART_WF7816(x).U = (v))
#define HW_UART_WF7816_SET(x, v) (HW_UART_WF7816_WR(x, HW_UART_WF7816_RD(x) |  (v)))
#define HW_UART_WF7816_CLR(x, v) (HW_UART_WF7816_WR(x, HW_UART_WF7816_RD(x) & ~(v)))
#define HW_UART_WF7816_TOG(x, v) (HW_UART_WF7816_WR(x, HW_UART_WF7816_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual UART_WF7816 bitfields
 */

/*!
 * @name Register UART_WF7816, field GTFD[7:0] (RW)
 *
 * This field is used as another multiplier in the calculation of WT and BWT.
 * This values represents a number between 1 and 255. The value of 0 is invalid.
 * This value is NOT used in baud rate generation. See Wait time and guard time
 * parameters and Baud rate generation.
 */
/*@{*/
#define BP_UART_WF7816_GTFD  (0U)          /*!< Bit position for UART_WF7816_GTFD. */
#define BM_UART_WF7816_GTFD  (0xFFU)       /*!< Bit mask for UART_WF7816_GTFD. */
#define BS_UART_WF7816_GTFD  (8U)          /*!< Bit field size in bits for UART_WF7816_GTFD. */

/*! @brief Read current value of the UART_WF7816_GTFD field. */
#define BR_UART_WF7816_GTFD(x) (HW_UART_WF7816(x).U)

/*! @brief Format value for bitfield UART_WF7816_GTFD. */
#define BF_UART_WF7816_GTFD(v) ((uint8_t)((uint8_t)(v) << BP_UART_WF7816_GTFD) & BM_UART_WF7816_GTFD)

/*! @brief Set the GTFD field to a new value. */
#define BW_UART_WF7816_GTFD(x, v) (HW_UART_WF7816_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_UART_ET7816 - UART 7816 Error Threshold Register
 ******************************************************************************/

/*!
 * @brief HW_UART_ET7816 - UART 7816 Error Threshold Register (RW)
 *
 * Reset value: 0x00U
 *
 * The ET7816 register contains fields that determine the number of NACKs that
 * must be received or transmitted before the host processor is notified. This
 * register may be read at anytime. This register must only be written when
 * C7816[ISO_7816E] is not set.
 */
typedef union _hw_uart_et7816
{
    uint8_t U;
    struct _hw_uart_et7816_bitfields
    {
        uint8_t RXTHRESHOLD : 4;       /*!< [3:0] Receive NACK Threshold */
        uint8_t TXTHRESHOLD : 4;       /*!< [7:4] Transmit NACK Threshold */
    } B;
} hw_uart_et7816_t;

/*!
 * @name Constants and macros for entire UART_ET7816 register
 */
/*@{*/
#define HW_UART_ET7816_ADDR(x)   ((x) + 0x1EU)

#define HW_UART_ET7816(x)        (*(__IO hw_uart_et7816_t *) HW_UART_ET7816_ADDR(x))
#define HW_UART_ET7816_RD(x)     (HW_UART_ET7816(x).U)
#define HW_UART_ET7816_WR(x, v)  (HW_UART_ET7816(x).U = (v))
#define HW_UART_ET7816_SET(x, v) (HW_UART_ET7816_WR(x, HW_UART_ET7816_RD(x) |  (v)))
#define HW_UART_ET7816_CLR(x, v) (HW_UART_ET7816_WR(x, HW_UART_ET7816_RD(x) & ~(v)))
#define HW_UART_ET7816_TOG(x, v) (HW_UART_ET7816_WR(x, HW_UART_ET7816_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual UART_ET7816 bitfields
 */

/*!
 * @name Register UART_ET7816, field RXTHRESHOLD[3:0] (RW)
 *
 * The value written to this field indicates the maximum number of consecutive
 * NACKs generated as a result of a parity error or receiver buffer overruns
 * before the host processor is notified. Once the counter exceeds that value in the
 * field the IS7816[RXT] will be asserted. This field is only meaningful when
 * C7816[TTYPE] = 0. The value read from this field represents the number of
 * consecutive NACKs that have been transmitted since the last successful reception. This
 * counter saturates at 4'hF and does not wrap around. Regardless of the number
 * of NACKs sent, the UART will continue to receive valid packets indefinitely.
 * For additional information see IS7816[RXT] bit description.
 */
/*@{*/
#define BP_UART_ET7816_RXTHRESHOLD (0U)    /*!< Bit position for UART_ET7816_RXTHRESHOLD. */
#define BM_UART_ET7816_RXTHRESHOLD (0x0FU) /*!< Bit mask for UART_ET7816_RXTHRESHOLD. */
#define BS_UART_ET7816_RXTHRESHOLD (4U)    /*!< Bit field size in bits for UART_ET7816_RXTHRESHOLD. */

/*! @brief Read current value of the UART_ET7816_RXTHRESHOLD field. */
#define BR_UART_ET7816_RXTHRESHOLD(x) (HW_UART_ET7816(x).B.RXTHRESHOLD)

/*! @brief Format value for bitfield UART_ET7816_RXTHRESHOLD. */
#define BF_UART_ET7816_RXTHRESHOLD(v) ((uint8_t)((uint8_t)(v) << BP_UART_ET7816_RXTHRESHOLD) & BM_UART_ET7816_RXTHRESHOLD)

/*! @brief Set the RXTHRESHOLD field to a new value. */
#define BW_UART_ET7816_RXTHRESHOLD(x, v) (HW_UART_ET7816_WR(x, (HW_UART_ET7816_RD(x) & ~BM_UART_ET7816_RXTHRESHOLD) | BF_UART_ET7816_RXTHRESHOLD(v)))
/*@}*/

/*!
 * @name Register UART_ET7816, field TXTHRESHOLD[7:4] (RW)
 *
 * The value written to this field indicates the maximum number of failed
 * attempts (NACKs) a transmitted character can have before the host processor is
 * notified. Meaning a value of 0 will always result in TXT asserting on the first
 * NACK that is received. A value of 1 will result in TXT being asserted on the
 * second NACK that is received. This field is only meaningful when C7816[TTYPE] = 0
 * and C7816[ANACK] = 1. The value read from this field represents the number of
 * consecutive NACKs that have been received since the last successful
 * transmission. This counter saturates at 4'hF and does not wrap around. Regardless of how
 * many NACKs that are received, the UART will continue to retransmit
 * indefinitely. This flag only asserts when C7816[TTYPE] = 0. For additional information
 * see the IS7816[TXT] bit description.
 */
/*@{*/
#define BP_UART_ET7816_TXTHRESHOLD (4U)    /*!< Bit position for UART_ET7816_TXTHRESHOLD. */
#define BM_UART_ET7816_TXTHRESHOLD (0xF0U) /*!< Bit mask for UART_ET7816_TXTHRESHOLD. */
#define BS_UART_ET7816_TXTHRESHOLD (4U)    /*!< Bit field size in bits for UART_ET7816_TXTHRESHOLD. */

/*! @brief Read current value of the UART_ET7816_TXTHRESHOLD field. */
#define BR_UART_ET7816_TXTHRESHOLD(x) (HW_UART_ET7816(x).B.TXTHRESHOLD)

/*! @brief Format value for bitfield UART_ET7816_TXTHRESHOLD. */
#define BF_UART_ET7816_TXTHRESHOLD(v) ((uint8_t)((uint8_t)(v) << BP_UART_ET7816_TXTHRESHOLD) & BM_UART_ET7816_TXTHRESHOLD)

/*! @brief Set the TXTHRESHOLD field to a new value. */
#define BW_UART_ET7816_TXTHRESHOLD(x, v) (HW_UART_ET7816_WR(x, (HW_UART_ET7816_RD(x) & ~BM_UART_ET7816_TXTHRESHOLD) | BF_UART_ET7816_TXTHRESHOLD(v)))
/*@}*/

/*******************************************************************************
 * HW_UART_TL7816 - UART 7816 Transmit Length Register
 ******************************************************************************/

/*!
 * @brief HW_UART_TL7816 - UART 7816 Transmit Length Register (RW)
 *
 * Reset value: 0x00U
 *
 * The TL7816 register is used to indicate how many characters are contained in
 * the block being transmitted. This register is only used when C7816[TTYPE] = 1.
 * This register may be read at anytime. This register should only be written
 * when C2[TE] is not enabled.
 */
typedef union _hw_uart_tl7816
{
    uint8_t U;
    struct _hw_uart_tl7816_bitfields
    {
        uint8_t TLEN : 8;              /*!< [7:0] Transmit Length */
    } B;
} hw_uart_tl7816_t;

/*!
 * @name Constants and macros for entire UART_TL7816 register
 */
/*@{*/
#define HW_UART_TL7816_ADDR(x)   ((x) + 0x1FU)

#define HW_UART_TL7816(x)        (*(__IO hw_uart_tl7816_t *) HW_UART_TL7816_ADDR(x))
#define HW_UART_TL7816_RD(x)     (HW_UART_TL7816(x).U)
#define HW_UART_TL7816_WR(x, v)  (HW_UART_TL7816(x).U = (v))
#define HW_UART_TL7816_SET(x, v) (HW_UART_TL7816_WR(x, HW_UART_TL7816_RD(x) |  (v)))
#define HW_UART_TL7816_CLR(x, v) (HW_UART_TL7816_WR(x, HW_UART_TL7816_RD(x) & ~(v)))
#define HW_UART_TL7816_TOG(x, v) (HW_UART_TL7816_WR(x, HW_UART_TL7816_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual UART_TL7816 bitfields
 */

/*!
 * @name Register UART_TL7816, field TLEN[7:0] (RW)
 *
 * This value plus 4 indicates the number of characters contained in the block
 * being transmitted. This register is automatically decremented by 1 for each
 * character in the information field portion of the block. Additionally, this
 * register is automatically decremented by 1 for the first character of a CRC in the
 * epilogue field. Hence, this register should be programmed with the number of
 * bytes in the data packet if a LRC is being transmitted, and the number of bytes
 * + 1 if a CRC is being transmitted. This register is not decremented for
 * characters that are assumed to be part of the Prologue field (first three
 * characters transmitted in a block) or the LRC or last CRC character in the Epilogue
 * field (last character transmitted). This field should only be programed or
 * adjusted when C2[TE] is cleared.
 */
/*@{*/
#define BP_UART_TL7816_TLEN  (0U)          /*!< Bit position for UART_TL7816_TLEN. */
#define BM_UART_TL7816_TLEN  (0xFFU)       /*!< Bit mask for UART_TL7816_TLEN. */
#define BS_UART_TL7816_TLEN  (8U)          /*!< Bit field size in bits for UART_TL7816_TLEN. */

/*! @brief Read current value of the UART_TL7816_TLEN field. */
#define BR_UART_TL7816_TLEN(x) (HW_UART_TL7816(x).U)

/*! @brief Format value for bitfield UART_TL7816_TLEN. */
#define BF_UART_TL7816_TLEN(v) ((uint8_t)((uint8_t)(v) << BP_UART_TL7816_TLEN) & BM_UART_TL7816_TLEN)

/*! @brief Set the TLEN field to a new value. */
#define BW_UART_TL7816_TLEN(x, v) (HW_UART_TL7816_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_UART_C6 - UART CEA709.1-B Control Register 6
 ******************************************************************************/

/*!
 * @brief HW_UART_C6 - UART CEA709.1-B Control Register 6 (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_uart_c6
{
    uint8_t U;
    struct _hw_uart_c6_bitfields
    {
        uint8_t RESERVED0 : 4;         /*!< [3:0]  */
        uint8_t CP : 1;                /*!< [4] Collision Signal Polarity */
        uint8_t CE : 1;                /*!< [5] Collision Enable */
        uint8_t TX709 : 1;             /*!< [6] CEA709.1-B Transmit Enable */
        uint8_t EN709 : 1;             /*!< [7] EN709 */
    } B;
} hw_uart_c6_t;

/*!
 * @name Constants and macros for entire UART_C6 register
 */
/*@{*/
#define HW_UART_C6_ADDR(x)       ((x) + 0x21U)

#define HW_UART_C6(x)            (*(__IO hw_uart_c6_t *) HW_UART_C6_ADDR(x))
#define HW_UART_C6_RD(x)         (HW_UART_C6(x).U)
#define HW_UART_C6_WR(x, v)      (HW_UART_C6(x).U = (v))
#define HW_UART_C6_SET(x, v)     (HW_UART_C6_WR(x, HW_UART_C6_RD(x) |  (v)))
#define HW_UART_C6_CLR(x, v)     (HW_UART_C6_WR(x, HW_UART_C6_RD(x) & ~(v)))
#define HW_UART_C6_TOG(x, v)     (HW_UART_C6_WR(x, HW_UART_C6_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual UART_C6 bitfields
 */

/*!
 * @name Register UART_C6, field CP[4] (RW)
 *
 * This bit indicates the polarity of collision signal.
 *
 * Values:
 * - 0 - Collision signal is active low.
 * - 1 - Collision signal is active high.
 */
/*@{*/
#define BP_UART_C6_CP        (4U)          /*!< Bit position for UART_C6_CP. */
#define BM_UART_C6_CP        (0x10U)       /*!< Bit mask for UART_C6_CP. */
#define BS_UART_C6_CP        (1U)          /*!< Bit field size in bits for UART_C6_CP. */

/*! @brief Read current value of the UART_C6_CP field. */
#define BR_UART_C6_CP(x)     (BITBAND_ACCESS8(HW_UART_C6_ADDR(x), BP_UART_C6_CP))

/*! @brief Format value for bitfield UART_C6_CP. */
#define BF_UART_C6_CP(v)     ((uint8_t)((uint8_t)(v) << BP_UART_C6_CP) & BM_UART_C6_CP)

/*! @brief Set the CP field to a new value. */
#define BW_UART_C6_CP(x, v)  (BITBAND_ACCESS8(HW_UART_C6_ADDR(x), BP_UART_C6_CP) = (v))
/*@}*/

/*!
 * @name Register UART_C6, field CE[5] (RW)
 *
 * This bit enables the collision detect functionality.
 *
 * Values:
 * - 0 - Collision detect feature is disabled.
 * - 1 - Collision detect feature is enabled.
 */
/*@{*/
#define BP_UART_C6_CE        (5U)          /*!< Bit position for UART_C6_CE. */
#define BM_UART_C6_CE        (0x20U)       /*!< Bit mask for UART_C6_CE. */
#define BS_UART_C6_CE        (1U)          /*!< Bit field size in bits for UART_C6_CE. */

/*! @brief Read current value of the UART_C6_CE field. */
#define BR_UART_C6_CE(x)     (BITBAND_ACCESS8(HW_UART_C6_ADDR(x), BP_UART_C6_CE))

/*! @brief Format value for bitfield UART_C6_CE. */
#define BF_UART_C6_CE(v)     ((uint8_t)((uint8_t)(v) << BP_UART_C6_CE) & BM_UART_C6_CE)

/*! @brief Set the CE field to a new value. */
#define BW_UART_C6_CE(x, v)  (BITBAND_ACCESS8(HW_UART_C6_ADDR(x), BP_UART_C6_CE) = (v))
/*@}*/

/*!
 * @name Register UART_C6, field TX709[6] (RW)
 *
 * This register is used to start CEA709.1-B transmission.
 *
 * Values:
 * - 0 - CEA709.1-B transmitter is disabled.
 * - 1 - CEA709.1-B transmitter is enabled.
 */
/*@{*/
#define BP_UART_C6_TX709     (6U)          /*!< Bit position for UART_C6_TX709. */
#define BM_UART_C6_TX709     (0x40U)       /*!< Bit mask for UART_C6_TX709. */
#define BS_UART_C6_TX709     (1U)          /*!< Bit field size in bits for UART_C6_TX709. */

/*! @brief Read current value of the UART_C6_TX709 field. */
#define BR_UART_C6_TX709(x)  (BITBAND_ACCESS8(HW_UART_C6_ADDR(x), BP_UART_C6_TX709))

/*! @brief Format value for bitfield UART_C6_TX709. */
#define BF_UART_C6_TX709(v)  ((uint8_t)((uint8_t)(v) << BP_UART_C6_TX709) & BM_UART_C6_TX709)

/*! @brief Set the TX709 field to a new value. */
#define BW_UART_C6_TX709(x, v) (BITBAND_ACCESS8(HW_UART_C6_ADDR(x), BP_UART_C6_TX709) = (v))
/*@}*/

/*!
 * @name Register UART_C6, field EN709[7] (RW)
 *
 * This register is used to enable the CEA709.1-B feature.
 *
 * Values:
 * - 0 - CEA709.1-B is disabled.
 * - 1 - CEA709.1-B is enabled
 */
/*@{*/
#define BP_UART_C6_EN709     (7U)          /*!< Bit position for UART_C6_EN709. */
#define BM_UART_C6_EN709     (0x80U)       /*!< Bit mask for UART_C6_EN709. */
#define BS_UART_C6_EN709     (1U)          /*!< Bit field size in bits for UART_C6_EN709. */

/*! @brief Read current value of the UART_C6_EN709 field. */
#define BR_UART_C6_EN709(x)  (BITBAND_ACCESS8(HW_UART_C6_ADDR(x), BP_UART_C6_EN709))

/*! @brief Format value for bitfield UART_C6_EN709. */
#define BF_UART_C6_EN709(v)  ((uint8_t)((uint8_t)(v) << BP_UART_C6_EN709) & BM_UART_C6_EN709)

/*! @brief Set the EN709 field to a new value. */
#define BW_UART_C6_EN709(x, v) (BITBAND_ACCESS8(HW_UART_C6_ADDR(x), BP_UART_C6_EN709) = (v))
/*@}*/

/*******************************************************************************
 * HW_UART_PCTH - UART CEA709.1-B Packet Cycle Time Counter High
 ******************************************************************************/

/*!
 * @brief HW_UART_PCTH - UART CEA709.1-B Packet Cycle Time Counter High (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_uart_pcth
{
    uint8_t U;
    struct _hw_uart_pcth_bitfields
    {
        uint8_t PCTH : 8;              /*!< [7:0] Packet Cycle Time Counter High */
    } B;
} hw_uart_pcth_t;

/*!
 * @name Constants and macros for entire UART_PCTH register
 */
/*@{*/
#define HW_UART_PCTH_ADDR(x)     ((x) + 0x22U)

#define HW_UART_PCTH(x)          (*(__IO hw_uart_pcth_t *) HW_UART_PCTH_ADDR(x))
#define HW_UART_PCTH_RD(x)       (HW_UART_PCTH(x).U)
#define HW_UART_PCTH_WR(x, v)    (HW_UART_PCTH(x).U = (v))
#define HW_UART_PCTH_SET(x, v)   (HW_UART_PCTH_WR(x, HW_UART_PCTH_RD(x) |  (v)))
#define HW_UART_PCTH_CLR(x, v)   (HW_UART_PCTH_WR(x, HW_UART_PCTH_RD(x) & ~(v)))
#define HW_UART_PCTH_TOG(x, v)   (HW_UART_PCTH_WR(x, HW_UART_PCTH_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual UART_PCTH bitfields
 */

/*!
 * @name Register UART_PCTH, field PCTH[7:0] (RW)
 *
 * This register indicates the most significant byte of maximum period after the
 * line code violation for which the bus could remain idle without decrementing
 * back log count. If the time elapsed after line code violation is greater than
 * packet cycle timer then packet cycle timer expired interrupt is generated. It
 * is measured in terms of bit times, i.e the time that it takes for a single bit
 * or one differential Manchester symbol to be transmitted. This is medium
 * dependent and hence does not usually require adjustment and is programmed only once.
 */
/*@{*/
#define BP_UART_PCTH_PCTH    (0U)          /*!< Bit position for UART_PCTH_PCTH. */
#define BM_UART_PCTH_PCTH    (0xFFU)       /*!< Bit mask for UART_PCTH_PCTH. */
#define BS_UART_PCTH_PCTH    (8U)          /*!< Bit field size in bits for UART_PCTH_PCTH. */

/*! @brief Read current value of the UART_PCTH_PCTH field. */
#define BR_UART_PCTH_PCTH(x) (HW_UART_PCTH(x).U)

/*! @brief Format value for bitfield UART_PCTH_PCTH. */
#define BF_UART_PCTH_PCTH(v) ((uint8_t)((uint8_t)(v) << BP_UART_PCTH_PCTH) & BM_UART_PCTH_PCTH)

/*! @brief Set the PCTH field to a new value. */
#define BW_UART_PCTH_PCTH(x, v) (HW_UART_PCTH_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_UART_PCTL - UART CEA709.1-B Packet Cycle Time Counter Low
 ******************************************************************************/

/*!
 * @brief HW_UART_PCTL - UART CEA709.1-B Packet Cycle Time Counter Low (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_uart_pctl
{
    uint8_t U;
    struct _hw_uart_pctl_bitfields
    {
        uint8_t PCTL : 8;              /*!< [7:0] Packet Cycle Time Counter Low */
    } B;
} hw_uart_pctl_t;

/*!
 * @name Constants and macros for entire UART_PCTL register
 */
/*@{*/
#define HW_UART_PCTL_ADDR(x)     ((x) + 0x23U)

#define HW_UART_PCTL(x)          (*(__IO hw_uart_pctl_t *) HW_UART_PCTL_ADDR(x))
#define HW_UART_PCTL_RD(x)       (HW_UART_PCTL(x).U)
#define HW_UART_PCTL_WR(x, v)    (HW_UART_PCTL(x).U = (v))
#define HW_UART_PCTL_SET(x, v)   (HW_UART_PCTL_WR(x, HW_UART_PCTL_RD(x) |  (v)))
#define HW_UART_PCTL_CLR(x, v)   (HW_UART_PCTL_WR(x, HW_UART_PCTL_RD(x) & ~(v)))
#define HW_UART_PCTL_TOG(x, v)   (HW_UART_PCTL_WR(x, HW_UART_PCTL_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual UART_PCTL bitfields
 */

/*!
 * @name Register UART_PCTL, field PCTL[7:0] (RW)
 *
 * This register indicates the least significant byte of maximum period after
 * the line code violation for which the bus could remain idle without decrementing
 * back log count. If the time elapsed after line code violation is greater than
 * packet cycle timer, then packet cycle timer expired interrupt is generated.
 * It is measured in terms of bit times, i.e the time that it takes for a single
 * bit or one Differential Manchester symbol to be transmitted. This is medium
 * dependent and hence does not usually require adjustment and is programmed only
 * once.
 */
/*@{*/
#define BP_UART_PCTL_PCTL    (0U)          /*!< Bit position for UART_PCTL_PCTL. */
#define BM_UART_PCTL_PCTL    (0xFFU)       /*!< Bit mask for UART_PCTL_PCTL. */
#define BS_UART_PCTL_PCTL    (8U)          /*!< Bit field size in bits for UART_PCTL_PCTL. */

/*! @brief Read current value of the UART_PCTL_PCTL field. */
#define BR_UART_PCTL_PCTL(x) (HW_UART_PCTL(x).U)

/*! @brief Format value for bitfield UART_PCTL_PCTL. */
#define BF_UART_PCTL_PCTL(v) ((uint8_t)((uint8_t)(v) << BP_UART_PCTL_PCTL) & BM_UART_PCTL_PCTL)

/*! @brief Set the PCTL field to a new value. */
#define BW_UART_PCTL_PCTL(x, v) (HW_UART_PCTL_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_UART_B1T - UART CEA709.1-B Beta1 Timer
 ******************************************************************************/

/*!
 * @brief HW_UART_B1T - UART CEA709.1-B Beta1 Timer (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_uart_b1t
{
    uint8_t U;
    struct _hw_uart_b1t_bitfields
    {
        uint8_t B1T : 8;               /*!< [7:0] Beta1 Timer */
    } B;
} hw_uart_b1t_t;

/*!
 * @name Constants and macros for entire UART_B1T register
 */
/*@{*/
#define HW_UART_B1T_ADDR(x)      ((x) + 0x24U)

#define HW_UART_B1T(x)           (*(__IO hw_uart_b1t_t *) HW_UART_B1T_ADDR(x))
#define HW_UART_B1T_RD(x)        (HW_UART_B1T(x).U)
#define HW_UART_B1T_WR(x, v)     (HW_UART_B1T(x).U = (v))
#define HW_UART_B1T_SET(x, v)    (HW_UART_B1T_WR(x, HW_UART_B1T_RD(x) |  (v)))
#define HW_UART_B1T_CLR(x, v)    (HW_UART_B1T_WR(x, HW_UART_B1T_RD(x) & ~(v)))
#define HW_UART_B1T_TOG(x, v)    (HW_UART_B1T_WR(x, HW_UART_B1T_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual UART_B1T bitfields
 */

/*!
 * @name Register UART_B1T, field B1T[7:0] (RW)
 *
 * Beta1 delay is a value that is system dependent and usually does not require
 * adjustment. It is programmed only once and measured in bit times.
 */
/*@{*/
#define BP_UART_B1T_B1T      (0U)          /*!< Bit position for UART_B1T_B1T. */
#define BM_UART_B1T_B1T      (0xFFU)       /*!< Bit mask for UART_B1T_B1T. */
#define BS_UART_B1T_B1T      (8U)          /*!< Bit field size in bits for UART_B1T_B1T. */

/*! @brief Read current value of the UART_B1T_B1T field. */
#define BR_UART_B1T_B1T(x)   (HW_UART_B1T(x).U)

/*! @brief Format value for bitfield UART_B1T_B1T. */
#define BF_UART_B1T_B1T(v)   ((uint8_t)((uint8_t)(v) << BP_UART_B1T_B1T) & BM_UART_B1T_B1T)

/*! @brief Set the B1T field to a new value. */
#define BW_UART_B1T_B1T(x, v) (HW_UART_B1T_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_UART_SDTH - UART CEA709.1-B Secondary Delay Timer High
 ******************************************************************************/

/*!
 * @brief HW_UART_SDTH - UART CEA709.1-B Secondary Delay Timer High (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_uart_sdth
{
    uint8_t U;
    struct _hw_uart_sdth_bitfields
    {
        uint8_t SDTH : 8;              /*!< [7:0] Secondary Delay Timer High */
    } B;
} hw_uart_sdth_t;

/*!
 * @name Constants and macros for entire UART_SDTH register
 */
/*@{*/
#define HW_UART_SDTH_ADDR(x)     ((x) + 0x25U)

#define HW_UART_SDTH(x)          (*(__IO hw_uart_sdth_t *) HW_UART_SDTH_ADDR(x))
#define HW_UART_SDTH_RD(x)       (HW_UART_SDTH(x).U)
#define HW_UART_SDTH_WR(x, v)    (HW_UART_SDTH(x).U = (v))
#define HW_UART_SDTH_SET(x, v)   (HW_UART_SDTH_WR(x, HW_UART_SDTH_RD(x) |  (v)))
#define HW_UART_SDTH_CLR(x, v)   (HW_UART_SDTH_WR(x, HW_UART_SDTH_RD(x) & ~(v)))
#define HW_UART_SDTH_TOG(x, v)   (HW_UART_SDTH_WR(x, HW_UART_SDTH_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual UART_SDTH bitfields
 */

/*!
 * @name Register UART_SDTH, field SDTH[7:0] (RW)
 *
 * This is the most significant byte of the secondary delay timer and is set by
 * software. This is generally a variable value that must be set for each data
 * message to be transmitted. It is measured in bit times, i.e. the time that it
 * takes for a single bit or one differential Manchester symbol to be transmitted.
 * This value must be between 0 and (BL*Wbase) + (ProritySlots -1), Beta2
 * timeslots. A value of zero indicates that the queued packet will be sent immediately
 * upon expiration of the beta1 timer.
 */
/*@{*/
#define BP_UART_SDTH_SDTH    (0U)          /*!< Bit position for UART_SDTH_SDTH. */
#define BM_UART_SDTH_SDTH    (0xFFU)       /*!< Bit mask for UART_SDTH_SDTH. */
#define BS_UART_SDTH_SDTH    (8U)          /*!< Bit field size in bits for UART_SDTH_SDTH. */

/*! @brief Read current value of the UART_SDTH_SDTH field. */
#define BR_UART_SDTH_SDTH(x) (HW_UART_SDTH(x).U)

/*! @brief Format value for bitfield UART_SDTH_SDTH. */
#define BF_UART_SDTH_SDTH(v) ((uint8_t)((uint8_t)(v) << BP_UART_SDTH_SDTH) & BM_UART_SDTH_SDTH)

/*! @brief Set the SDTH field to a new value. */
#define BW_UART_SDTH_SDTH(x, v) (HW_UART_SDTH_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_UART_SDTL - UART CEA709.1-B Secondary Delay Timer Low
 ******************************************************************************/

/*!
 * @brief HW_UART_SDTL - UART CEA709.1-B Secondary Delay Timer Low (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_uart_sdtl
{
    uint8_t U;
    struct _hw_uart_sdtl_bitfields
    {
        uint8_t SDTL : 8;              /*!< [7:0] Secondary Delay Timer Low */
    } B;
} hw_uart_sdtl_t;

/*!
 * @name Constants and macros for entire UART_SDTL register
 */
/*@{*/
#define HW_UART_SDTL_ADDR(x)     ((x) + 0x26U)

#define HW_UART_SDTL(x)          (*(__IO hw_uart_sdtl_t *) HW_UART_SDTL_ADDR(x))
#define HW_UART_SDTL_RD(x)       (HW_UART_SDTL(x).U)
#define HW_UART_SDTL_WR(x, v)    (HW_UART_SDTL(x).U = (v))
#define HW_UART_SDTL_SET(x, v)   (HW_UART_SDTL_WR(x, HW_UART_SDTL_RD(x) |  (v)))
#define HW_UART_SDTL_CLR(x, v)   (HW_UART_SDTL_WR(x, HW_UART_SDTL_RD(x) & ~(v)))
#define HW_UART_SDTL_TOG(x, v)   (HW_UART_SDTL_WR(x, HW_UART_SDTL_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual UART_SDTL bitfields
 */

/*!
 * @name Register UART_SDTL, field SDTL[7:0] (RW)
 *
 * This is the least significant byte of the secondary delay timer and is set by
 * software. This is generally a variable value that must be set for each data
 * message to be transmitted. It is measured in bit times i.e. the time that it
 * takes for a single bit or one Differential Manchester symbol to be transmitted.
 * This value must be between 0 and (BL*Wbase) + (ProritySlots -1), Beta2
 * timeslots. A value of zero indicates that the queued packet will be sent immediately
 * upon expiration of the beta1 timer.
 */
/*@{*/
#define BP_UART_SDTL_SDTL    (0U)          /*!< Bit position for UART_SDTL_SDTL. */
#define BM_UART_SDTL_SDTL    (0xFFU)       /*!< Bit mask for UART_SDTL_SDTL. */
#define BS_UART_SDTL_SDTL    (8U)          /*!< Bit field size in bits for UART_SDTL_SDTL. */

/*! @brief Read current value of the UART_SDTL_SDTL field. */
#define BR_UART_SDTL_SDTL(x) (HW_UART_SDTL(x).U)

/*! @brief Format value for bitfield UART_SDTL_SDTL. */
#define BF_UART_SDTL_SDTL(v) ((uint8_t)((uint8_t)(v) << BP_UART_SDTL_SDTL) & BM_UART_SDTL_SDTL)

/*! @brief Set the SDTL field to a new value. */
#define BW_UART_SDTL_SDTL(x, v) (HW_UART_SDTL_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_UART_PRE - UART CEA709.1-B Preamble
 ******************************************************************************/

/*!
 * @brief HW_UART_PRE - UART CEA709.1-B Preamble (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_uart_pre
{
    uint8_t U;
    struct _hw_uart_pre_bitfields
    {
        uint8_t PREAMBLE : 8;          /*!< [7:0] CEA709.1-B Preamble Register */
    } B;
} hw_uart_pre_t;

/*!
 * @name Constants and macros for entire UART_PRE register
 */
/*@{*/
#define HW_UART_PRE_ADDR(x)      ((x) + 0x27U)

#define HW_UART_PRE(x)           (*(__IO hw_uart_pre_t *) HW_UART_PRE_ADDR(x))
#define HW_UART_PRE_RD(x)        (HW_UART_PRE(x).U)
#define HW_UART_PRE_WR(x, v)     (HW_UART_PRE(x).U = (v))
#define HW_UART_PRE_SET(x, v)    (HW_UART_PRE_WR(x, HW_UART_PRE_RD(x) |  (v)))
#define HW_UART_PRE_CLR(x, v)    (HW_UART_PRE_WR(x, HW_UART_PRE_RD(x) & ~(v)))
#define HW_UART_PRE_TOG(x, v)    (HW_UART_PRE_WR(x, HW_UART_PRE_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual UART_PRE bitfields
 */

/*!
 * @name Register UART_PRE, field PREAMBLE[7:0] (RW)
 *
 * The number of bit-sync characters that occurs prior to the byte-sync
 * character when preamble is transmitted.The minimum preamble length supported by
 * twisted pair wire is 4-bit sync fields.
 */
/*@{*/
#define BP_UART_PRE_PREAMBLE (0U)          /*!< Bit position for UART_PRE_PREAMBLE. */
#define BM_UART_PRE_PREAMBLE (0xFFU)       /*!< Bit mask for UART_PRE_PREAMBLE. */
#define BS_UART_PRE_PREAMBLE (8U)          /*!< Bit field size in bits for UART_PRE_PREAMBLE. */

/*! @brief Read current value of the UART_PRE_PREAMBLE field. */
#define BR_UART_PRE_PREAMBLE(x) (HW_UART_PRE(x).U)

/*! @brief Format value for bitfield UART_PRE_PREAMBLE. */
#define BF_UART_PRE_PREAMBLE(v) ((uint8_t)((uint8_t)(v) << BP_UART_PRE_PREAMBLE) & BM_UART_PRE_PREAMBLE)

/*! @brief Set the PREAMBLE field to a new value. */
#define BW_UART_PRE_PREAMBLE(x, v) (HW_UART_PRE_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_UART_TPL - UART CEA709.1-B Transmit Packet Length
 ******************************************************************************/

/*!
 * @brief HW_UART_TPL - UART CEA709.1-B Transmit Packet Length (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_uart_tpl
{
    uint8_t U;
    struct _hw_uart_tpl_bitfields
    {
        uint8_t TPL : 8;               /*!< [7:0] Transmit Packet Length Register */
    } B;
} hw_uart_tpl_t;

/*!
 * @name Constants and macros for entire UART_TPL register
 */
/*@{*/
#define HW_UART_TPL_ADDR(x)      ((x) + 0x28U)

#define HW_UART_TPL(x)           (*(__IO hw_uart_tpl_t *) HW_UART_TPL_ADDR(x))
#define HW_UART_TPL_RD(x)        (HW_UART_TPL(x).U)
#define HW_UART_TPL_WR(x, v)     (HW_UART_TPL(x).U = (v))
#define HW_UART_TPL_SET(x, v)    (HW_UART_TPL_WR(x, HW_UART_TPL_RD(x) |  (v)))
#define HW_UART_TPL_CLR(x, v)    (HW_UART_TPL_WR(x, HW_UART_TPL_RD(x) & ~(v)))
#define HW_UART_TPL_TOG(x, v)    (HW_UART_TPL_WR(x, HW_UART_TPL_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual UART_TPL bitfields
 */

/*!
 * @name Register UART_TPL, field TPL[7:0] (RW)
 *
 * Length of the data packet in bytes that is transmitted by CEA709.1-B
 * transmitter. This includes CRC packet as well.
 */
/*@{*/
#define BP_UART_TPL_TPL      (0U)          /*!< Bit position for UART_TPL_TPL. */
#define BM_UART_TPL_TPL      (0xFFU)       /*!< Bit mask for UART_TPL_TPL. */
#define BS_UART_TPL_TPL      (8U)          /*!< Bit field size in bits for UART_TPL_TPL. */

/*! @brief Read current value of the UART_TPL_TPL field. */
#define BR_UART_TPL_TPL(x)   (HW_UART_TPL(x).U)

/*! @brief Format value for bitfield UART_TPL_TPL. */
#define BF_UART_TPL_TPL(v)   ((uint8_t)((uint8_t)(v) << BP_UART_TPL_TPL) & BM_UART_TPL_TPL)

/*! @brief Set the TPL field to a new value. */
#define BW_UART_TPL_TPL(x, v) (HW_UART_TPL_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_UART_IE - UART CEA709.1-B Interrupt Enable Register
 ******************************************************************************/

/*!
 * @brief HW_UART_IE - UART CEA709.1-B Interrupt Enable Register (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_uart_ie
{
    uint8_t U;
    struct _hw_uart_ie_bitfields
    {
        uint8_t TXFIE : 1;             /*!< [0] Transmission Fail Interrupt Enable */
        uint8_t PSIE : 1;              /*!< [1] Preamble Start Interrupt Enable */
        uint8_t PCTEIE : 1;            /*!< [2] Packet Cycle Timer Interrupt Enable */
        uint8_t PTXIE : 1;             /*!< [3] Packet Transmitted Interrupt Enable */
        uint8_t PRXIE : 1;             /*!< [4] Packet Received Interrupt Enable */
        uint8_t ISDIE : 1;             /*!< [5] Initial Sync Detection Interrupt Enable */
        uint8_t WBEIE : 1;             /*!< [6] Wbase Expired Interrupt Enable */
        uint8_t RESERVED0 : 1;         /*!< [7]  */
    } B;
} hw_uart_ie_t;

/*!
 * @name Constants and macros for entire UART_IE register
 */
/*@{*/
#define HW_UART_IE_ADDR(x)       ((x) + 0x29U)

#define HW_UART_IE(x)            (*(__IO hw_uart_ie_t *) HW_UART_IE_ADDR(x))
#define HW_UART_IE_RD(x)         (HW_UART_IE(x).U)
#define HW_UART_IE_WR(x, v)      (HW_UART_IE(x).U = (v))
#define HW_UART_IE_SET(x, v)     (HW_UART_IE_WR(x, HW_UART_IE_RD(x) |  (v)))
#define HW_UART_IE_CLR(x, v)     (HW_UART_IE_WR(x, HW_UART_IE_RD(x) & ~(v)))
#define HW_UART_IE_TOG(x, v)     (HW_UART_IE_WR(x, HW_UART_IE_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual UART_IE bitfields
 */

/*!
 * @name Register UART_IE, field TXFIE[0] (RW)
 *
 * Interrupt enable for transmission fail flag.
 *
 * Values:
 * - 0 - Interrupt is disabled.
 * - 1 - Interrupt is enabled.
 */
/*@{*/
#define BP_UART_IE_TXFIE     (0U)          /*!< Bit position for UART_IE_TXFIE. */
#define BM_UART_IE_TXFIE     (0x01U)       /*!< Bit mask for UART_IE_TXFIE. */
#define BS_UART_IE_TXFIE     (1U)          /*!< Bit field size in bits for UART_IE_TXFIE. */

/*! @brief Read current value of the UART_IE_TXFIE field. */
#define BR_UART_IE_TXFIE(x)  (BITBAND_ACCESS8(HW_UART_IE_ADDR(x), BP_UART_IE_TXFIE))

/*! @brief Format value for bitfield UART_IE_TXFIE. */
#define BF_UART_IE_TXFIE(v)  ((uint8_t)((uint8_t)(v) << BP_UART_IE_TXFIE) & BM_UART_IE_TXFIE)

/*! @brief Set the TXFIE field to a new value. */
#define BW_UART_IE_TXFIE(x, v) (BITBAND_ACCESS8(HW_UART_IE_ADDR(x), BP_UART_IE_TXFIE) = (v))
/*@}*/

/*!
 * @name Register UART_IE, field PSIE[1] (RW)
 *
 * Interrupt enable for preamble start flag.
 *
 * Values:
 * - 0 - Interrupt is disabled.
 * - 1 - Interrupt is enabled.
 */
/*@{*/
#define BP_UART_IE_PSIE      (1U)          /*!< Bit position for UART_IE_PSIE. */
#define BM_UART_IE_PSIE      (0x02U)       /*!< Bit mask for UART_IE_PSIE. */
#define BS_UART_IE_PSIE      (1U)          /*!< Bit field size in bits for UART_IE_PSIE. */

/*! @brief Read current value of the UART_IE_PSIE field. */
#define BR_UART_IE_PSIE(x)   (BITBAND_ACCESS8(HW_UART_IE_ADDR(x), BP_UART_IE_PSIE))

/*! @brief Format value for bitfield UART_IE_PSIE. */
#define BF_UART_IE_PSIE(v)   ((uint8_t)((uint8_t)(v) << BP_UART_IE_PSIE) & BM_UART_IE_PSIE)

/*! @brief Set the PSIE field to a new value. */
#define BW_UART_IE_PSIE(x, v) (BITBAND_ACCESS8(HW_UART_IE_ADDR(x), BP_UART_IE_PSIE) = (v))
/*@}*/

/*!
 * @name Register UART_IE, field PCTEIE[2] (RW)
 *
 * Interrupt enable for packet cycle time expired flag.
 *
 * Values:
 * - 0 - Interrupt is disabled.
 * - 1 - Interrupt is enabled.
 */
/*@{*/
#define BP_UART_IE_PCTEIE    (2U)          /*!< Bit position for UART_IE_PCTEIE. */
#define BM_UART_IE_PCTEIE    (0x04U)       /*!< Bit mask for UART_IE_PCTEIE. */
#define BS_UART_IE_PCTEIE    (1U)          /*!< Bit field size in bits for UART_IE_PCTEIE. */

/*! @brief Read current value of the UART_IE_PCTEIE field. */
#define BR_UART_IE_PCTEIE(x) (BITBAND_ACCESS8(HW_UART_IE_ADDR(x), BP_UART_IE_PCTEIE))

/*! @brief Format value for bitfield UART_IE_PCTEIE. */
#define BF_UART_IE_PCTEIE(v) ((uint8_t)((uint8_t)(v) << BP_UART_IE_PCTEIE) & BM_UART_IE_PCTEIE)

/*! @brief Set the PCTEIE field to a new value. */
#define BW_UART_IE_PCTEIE(x, v) (BITBAND_ACCESS8(HW_UART_IE_ADDR(x), BP_UART_IE_PCTEIE) = (v))
/*@}*/

/*!
 * @name Register UART_IE, field PTXIE[3] (RW)
 *
 * Interrupt enable for packet transmitted flag.
 *
 * Values:
 * - 0 - Interrupt is disabled.
 * - 1 - Interrupt is enabled.
 */
/*@{*/
#define BP_UART_IE_PTXIE     (3U)          /*!< Bit position for UART_IE_PTXIE. */
#define BM_UART_IE_PTXIE     (0x08U)       /*!< Bit mask for UART_IE_PTXIE. */
#define BS_UART_IE_PTXIE     (1U)          /*!< Bit field size in bits for UART_IE_PTXIE. */

/*! @brief Read current value of the UART_IE_PTXIE field. */
#define BR_UART_IE_PTXIE(x)  (BITBAND_ACCESS8(HW_UART_IE_ADDR(x), BP_UART_IE_PTXIE))

/*! @brief Format value for bitfield UART_IE_PTXIE. */
#define BF_UART_IE_PTXIE(v)  ((uint8_t)((uint8_t)(v) << BP_UART_IE_PTXIE) & BM_UART_IE_PTXIE)

/*! @brief Set the PTXIE field to a new value. */
#define BW_UART_IE_PTXIE(x, v) (BITBAND_ACCESS8(HW_UART_IE_ADDR(x), BP_UART_IE_PTXIE) = (v))
/*@}*/

/*!
 * @name Register UART_IE, field PRXIE[4] (RW)
 *
 * Interrupt enable for packet received flag.
 *
 * Values:
 * - 0 - Interrupt is disabled.
 * - 1 - Interrupt is enabled.
 */
/*@{*/
#define BP_UART_IE_PRXIE     (4U)          /*!< Bit position for UART_IE_PRXIE. */
#define BM_UART_IE_PRXIE     (0x10U)       /*!< Bit mask for UART_IE_PRXIE. */
#define BS_UART_IE_PRXIE     (1U)          /*!< Bit field size in bits for UART_IE_PRXIE. */

/*! @brief Read current value of the UART_IE_PRXIE field. */
#define BR_UART_IE_PRXIE(x)  (BITBAND_ACCESS8(HW_UART_IE_ADDR(x), BP_UART_IE_PRXIE))

/*! @brief Format value for bitfield UART_IE_PRXIE. */
#define BF_UART_IE_PRXIE(v)  ((uint8_t)((uint8_t)(v) << BP_UART_IE_PRXIE) & BM_UART_IE_PRXIE)

/*! @brief Set the PRXIE field to a new value. */
#define BW_UART_IE_PRXIE(x, v) (BITBAND_ACCESS8(HW_UART_IE_ADDR(x), BP_UART_IE_PRXIE) = (v))
/*@}*/

/*!
 * @name Register UART_IE, field ISDIE[5] (RW)
 *
 * Interrupt enable for initial synchronization detection flag.
 *
 * Values:
 * - 0 - Interrupt is disabled.
 * - 1 - Interrupt is enabled.
 */
/*@{*/
#define BP_UART_IE_ISDIE     (5U)          /*!< Bit position for UART_IE_ISDIE. */
#define BM_UART_IE_ISDIE     (0x20U)       /*!< Bit mask for UART_IE_ISDIE. */
#define BS_UART_IE_ISDIE     (1U)          /*!< Bit field size in bits for UART_IE_ISDIE. */

/*! @brief Read current value of the UART_IE_ISDIE field. */
#define BR_UART_IE_ISDIE(x)  (BITBAND_ACCESS8(HW_UART_IE_ADDR(x), BP_UART_IE_ISDIE))

/*! @brief Format value for bitfield UART_IE_ISDIE. */
#define BF_UART_IE_ISDIE(v)  ((uint8_t)((uint8_t)(v) << BP_UART_IE_ISDIE) & BM_UART_IE_ISDIE)

/*! @brief Set the ISDIE field to a new value. */
#define BW_UART_IE_ISDIE(x, v) (BITBAND_ACCESS8(HW_UART_IE_ADDR(x), BP_UART_IE_ISDIE) = (v))
/*@}*/

/*!
 * @name Register UART_IE, field WBEIE[6] (RW)
 *
 * Interrupt enable for Wbase expired flag.
 *
 * Values:
 * - 0 - Interrupt is disabled.
 * - 1 - Interrupt is enabled.
 */
/*@{*/
#define BP_UART_IE_WBEIE     (6U)          /*!< Bit position for UART_IE_WBEIE. */
#define BM_UART_IE_WBEIE     (0x40U)       /*!< Bit mask for UART_IE_WBEIE. */
#define BS_UART_IE_WBEIE     (1U)          /*!< Bit field size in bits for UART_IE_WBEIE. */

/*! @brief Read current value of the UART_IE_WBEIE field. */
#define BR_UART_IE_WBEIE(x)  (BITBAND_ACCESS8(HW_UART_IE_ADDR(x), BP_UART_IE_WBEIE))

/*! @brief Format value for bitfield UART_IE_WBEIE. */
#define BF_UART_IE_WBEIE(v)  ((uint8_t)((uint8_t)(v) << BP_UART_IE_WBEIE) & BM_UART_IE_WBEIE)

/*! @brief Set the WBEIE field to a new value. */
#define BW_UART_IE_WBEIE(x, v) (BITBAND_ACCESS8(HW_UART_IE_ADDR(x), BP_UART_IE_WBEIE) = (v))
/*@}*/

/*******************************************************************************
 * HW_UART_WB - UART CEA709.1-B WBASE
 ******************************************************************************/

/*!
 * @brief HW_UART_WB - UART CEA709.1-B WBASE (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_uart_wb
{
    uint8_t U;
    struct _hw_uart_wb_bitfields
    {
        uint8_t WBASE : 8;             /*!< [7:0] CEA709.1-B WBASE register */
    } B;
} hw_uart_wb_t;

/*!
 * @name Constants and macros for entire UART_WB register
 */
/*@{*/
#define HW_UART_WB_ADDR(x)       ((x) + 0x2AU)

#define HW_UART_WB(x)            (*(__IO hw_uart_wb_t *) HW_UART_WB_ADDR(x))
#define HW_UART_WB_RD(x)         (HW_UART_WB(x).U)
#define HW_UART_WB_WR(x, v)      (HW_UART_WB(x).U = (v))
#define HW_UART_WB_SET(x, v)     (HW_UART_WB_WR(x, HW_UART_WB_RD(x) |  (v)))
#define HW_UART_WB_CLR(x, v)     (HW_UART_WB_WR(x, HW_UART_WB_RD(x) & ~(v)))
#define HW_UART_WB_TOG(x, v)     (HW_UART_WB_WR(x, HW_UART_WB_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual UART_WB bitfields
 */

/*!
 * @name Register UART_WB, field WBASE[7:0] (RW)
 *
 * WBase is the size of the basic randomizing window in bit periods after beta1
 * time period.
 */
/*@{*/
#define BP_UART_WB_WBASE     (0U)          /*!< Bit position for UART_WB_WBASE. */
#define BM_UART_WB_WBASE     (0xFFU)       /*!< Bit mask for UART_WB_WBASE. */
#define BS_UART_WB_WBASE     (8U)          /*!< Bit field size in bits for UART_WB_WBASE. */

/*! @brief Read current value of the UART_WB_WBASE field. */
#define BR_UART_WB_WBASE(x)  (HW_UART_WB(x).U)

/*! @brief Format value for bitfield UART_WB_WBASE. */
#define BF_UART_WB_WBASE(v)  ((uint8_t)((uint8_t)(v) << BP_UART_WB_WBASE) & BM_UART_WB_WBASE)

/*! @brief Set the WBASE field to a new value. */
#define BW_UART_WB_WBASE(x, v) (HW_UART_WB_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_UART_S3 - UART CEA709.1-B Status Register
 ******************************************************************************/

/*!
 * @brief HW_UART_S3 - UART CEA709.1-B Status Register (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_uart_s3
{
    uint8_t U;
    struct _hw_uart_s3_bitfields
    {
        uint8_t TXFF : 1;              /*!< [0] Transmission Fail Flag */
        uint8_t PSF : 1;               /*!< [1] Preamble Start Flag */
        uint8_t PCTEF : 1;             /*!< [2] Packet Cycle Timer Expired Flag */
        uint8_t PTXF : 1;              /*!< [3] Packet Transmitted Flag */
        uint8_t PRXF : 1;              /*!< [4] Packet Received Flag */
        uint8_t ISD : 1;               /*!< [5] Initial Sync Detect */
        uint8_t WBEF : 1;              /*!< [6] Wbase Expired Flag */
        uint8_t PEF : 1;               /*!< [7] Preamble Error Flag */
    } B;
} hw_uart_s3_t;

/*!
 * @name Constants and macros for entire UART_S3 register
 */
/*@{*/
#define HW_UART_S3_ADDR(x)       ((x) + 0x2BU)

#define HW_UART_S3(x)            (*(__IO hw_uart_s3_t *) HW_UART_S3_ADDR(x))
#define HW_UART_S3_RD(x)         (HW_UART_S3(x).U)
#define HW_UART_S3_WR(x, v)      (HW_UART_S3(x).U = (v))
#define HW_UART_S3_SET(x, v)     (HW_UART_S3_WR(x, HW_UART_S3_RD(x) |  (v)))
#define HW_UART_S3_CLR(x, v)     (HW_UART_S3_WR(x, HW_UART_S3_RD(x) & ~(v)))
#define HW_UART_S3_TOG(x, v)     (HW_UART_S3_WR(x, HW_UART_S3_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual UART_S3 bitfields
 */

/*!
 * @name Register UART_S3, field TXFF[0] (RW)
 *
 * This flag indicates that transmission could not proceed. This flag is
 * asserted when the packet is queued for transmission but before the random delay is
 * expired an incoming receive packet is detected. This flag is also asserted while
 * transmission when the TX fifo becomes empty or overflows. During these cases
 * Line Code Violation is transmitted on TX line immediately after current byte
 * or preamble transmission is finished, without waiting for completion of
 * transmit packet length. If the transmission fail flag is asserted then TX709 bit of
 * UART_C6 register is cleared. This flag is cleared by writing `1'.
 *
 * Values:
 * - 0 - Transmission continues normally.
 * - 1 - Transmission is failed.
 */
/*@{*/
#define BP_UART_S3_TXFF      (0U)          /*!< Bit position for UART_S3_TXFF. */
#define BM_UART_S3_TXFF      (0x01U)       /*!< Bit mask for UART_S3_TXFF. */
#define BS_UART_S3_TXFF      (1U)          /*!< Bit field size in bits for UART_S3_TXFF. */

/*! @brief Read current value of the UART_S3_TXFF field. */
#define BR_UART_S3_TXFF(x)   (BITBAND_ACCESS8(HW_UART_S3_ADDR(x), BP_UART_S3_TXFF))

/*! @brief Format value for bitfield UART_S3_TXFF. */
#define BF_UART_S3_TXFF(v)   ((uint8_t)((uint8_t)(v) << BP_UART_S3_TXFF) & BM_UART_S3_TXFF)

/*! @brief Set the TXFF field to a new value. */
#define BW_UART_S3_TXFF(x, v) (BITBAND_ACCESS8(HW_UART_S3_ADDR(x), BP_UART_S3_TXFF) = (v))
/*@}*/

/*!
 * @name Register UART_S3, field PSF[1] (RW)
 *
 * This flag indicates start of preamble while the packet is being transmitted.
 * This flag is cleared by writing `1'.
 *
 * Values:
 * - 0 - Preamble start is not detected.
 * - 1 - Preamble start is detected.
 */
/*@{*/
#define BP_UART_S3_PSF       (1U)          /*!< Bit position for UART_S3_PSF. */
#define BM_UART_S3_PSF       (0x02U)       /*!< Bit mask for UART_S3_PSF. */
#define BS_UART_S3_PSF       (1U)          /*!< Bit field size in bits for UART_S3_PSF. */

/*! @brief Read current value of the UART_S3_PSF field. */
#define BR_UART_S3_PSF(x)    (BITBAND_ACCESS8(HW_UART_S3_ADDR(x), BP_UART_S3_PSF))

/*! @brief Format value for bitfield UART_S3_PSF. */
#define BF_UART_S3_PSF(v)    ((uint8_t)((uint8_t)(v) << BP_UART_S3_PSF) & BM_UART_S3_PSF)

/*! @brief Set the PSF field to a new value. */
#define BW_UART_S3_PSF(x, v) (BITBAND_ACCESS8(HW_UART_S3_ADDR(x), BP_UART_S3_PSF) = (v))
/*@}*/

/*!
 * @name Register UART_S3, field PCTEF[2] (RW)
 *
 * This flag indicates that packet cycle time period has been expired with no
 * activity on the line. This flag is cleared by writing `1'.
 *
 * Values:
 * - 0 - Packet Cycle Time is not expired.
 * - 1 - Packet cycle time is expired.
 */
/*@{*/
#define BP_UART_S3_PCTEF     (2U)          /*!< Bit position for UART_S3_PCTEF. */
#define BM_UART_S3_PCTEF     (0x04U)       /*!< Bit mask for UART_S3_PCTEF. */
#define BS_UART_S3_PCTEF     (1U)          /*!< Bit field size in bits for UART_S3_PCTEF. */

/*! @brief Read current value of the UART_S3_PCTEF field. */
#define BR_UART_S3_PCTEF(x)  (BITBAND_ACCESS8(HW_UART_S3_ADDR(x), BP_UART_S3_PCTEF))

/*! @brief Format value for bitfield UART_S3_PCTEF. */
#define BF_UART_S3_PCTEF(v)  ((uint8_t)((uint8_t)(v) << BP_UART_S3_PCTEF) & BM_UART_S3_PCTEF)

/*! @brief Set the PCTEF field to a new value. */
#define BW_UART_S3_PCTEF(x, v) (BITBAND_ACCESS8(HW_UART_S3_ADDR(x), BP_UART_S3_PCTEF) = (v))
/*@}*/

/*!
 * @name Register UART_S3, field PTXF[3] (RW)
 *
 * This flag indicates that complete packet is transmitted. This flag is cleared
 * by writing `1'. In case TX packet gets aborted due to fifo becoming empty or
 * overflow, packet transmitted flag will still be generated.
 *
 * Values:
 * - 0 - Packet transmission is not complete.
 * - 1 - Packet transmission is complete.
 */
/*@{*/
#define BP_UART_S3_PTXF      (3U)          /*!< Bit position for UART_S3_PTXF. */
#define BM_UART_S3_PTXF      (0x08U)       /*!< Bit mask for UART_S3_PTXF. */
#define BS_UART_S3_PTXF      (1U)          /*!< Bit field size in bits for UART_S3_PTXF. */

/*! @brief Read current value of the UART_S3_PTXF field. */
#define BR_UART_S3_PTXF(x)   (BITBAND_ACCESS8(HW_UART_S3_ADDR(x), BP_UART_S3_PTXF))

/*! @brief Format value for bitfield UART_S3_PTXF. */
#define BF_UART_S3_PTXF(v)   ((uint8_t)((uint8_t)(v) << BP_UART_S3_PTXF) & BM_UART_S3_PTXF)

/*! @brief Set the PTXF field to a new value. */
#define BW_UART_S3_PTXF(x, v) (BITBAND_ACCESS8(HW_UART_S3_ADDR(x), BP_UART_S3_PTXF) = (v))
/*@}*/

/*!
 * @name Register UART_S3, field PRXF[4] (RW)
 *
 * This flag indicates that complete packet is received. This flag is cleared by
 * writing `1'.
 *
 * Values:
 * - 0 - Packet is not received.
 * - 1 - Packet is received.
 */
/*@{*/
#define BP_UART_S3_PRXF      (4U)          /*!< Bit position for UART_S3_PRXF. */
#define BM_UART_S3_PRXF      (0x10U)       /*!< Bit mask for UART_S3_PRXF. */
#define BS_UART_S3_PRXF      (1U)          /*!< Bit field size in bits for UART_S3_PRXF. */

/*! @brief Read current value of the UART_S3_PRXF field. */
#define BR_UART_S3_PRXF(x)   (BITBAND_ACCESS8(HW_UART_S3_ADDR(x), BP_UART_S3_PRXF))

/*! @brief Format value for bitfield UART_S3_PRXF. */
#define BF_UART_S3_PRXF(v)   ((uint8_t)((uint8_t)(v) << BP_UART_S3_PRXF) & BM_UART_S3_PRXF)

/*! @brief Set the PRXF field to a new value. */
#define BW_UART_S3_PRXF(x, v) (BITBAND_ACCESS8(HW_UART_S3_ADDR(x), BP_UART_S3_PRXF) = (v))
/*@}*/

/*!
 * @name Register UART_S3, field ISD[5] (RO)
 *
 * This flag indicates that initially a valid one and a line code violation is
 * detected. This flag is cleared by deasserting EN709 bit.
 *
 * Values:
 * - 0 - Initial sync is not detected.
 * - 1 - Initial sync is detected.
 */
/*@{*/
#define BP_UART_S3_ISD       (5U)          /*!< Bit position for UART_S3_ISD. */
#define BM_UART_S3_ISD       (0x20U)       /*!< Bit mask for UART_S3_ISD. */
#define BS_UART_S3_ISD       (1U)          /*!< Bit field size in bits for UART_S3_ISD. */

/*! @brief Read current value of the UART_S3_ISD field. */
#define BR_UART_S3_ISD(x)    (BITBAND_ACCESS8(HW_UART_S3_ADDR(x), BP_UART_S3_ISD))
/*@}*/

/*!
 * @name Register UART_S3, field WBEF[6] (RW)
 *
 * This flag indicates that Wbase time period has been expired after Beta1 time
 * slots. This flag is cleared by writing `1'.
 *
 * Values:
 * - 0 - Wbase time period is not expired.
 * - 1 - Wbase time period has been expired after beta1 time slots.
 */
/*@{*/
#define BP_UART_S3_WBEF      (6U)          /*!< Bit position for UART_S3_WBEF. */
#define BM_UART_S3_WBEF      (0x40U)       /*!< Bit mask for UART_S3_WBEF. */
#define BS_UART_S3_WBEF      (1U)          /*!< Bit field size in bits for UART_S3_WBEF. */

/*! @brief Read current value of the UART_S3_WBEF field. */
#define BR_UART_S3_WBEF(x)   (BITBAND_ACCESS8(HW_UART_S3_ADDR(x), BP_UART_S3_WBEF))

/*! @brief Format value for bitfield UART_S3_WBEF. */
#define BF_UART_S3_WBEF(v)   ((uint8_t)((uint8_t)(v) << BP_UART_S3_WBEF) & BM_UART_S3_WBEF)

/*! @brief Set the WBEF field to a new value. */
#define BW_UART_S3_WBEF(x, v) (BITBAND_ACCESS8(HW_UART_S3_ADDR(x), BP_UART_S3_WBEF) = (v))
/*@}*/

/*!
 * @name Register UART_S3, field PEF[7] (RW)
 *
 * This flag indicates that received preamble is in error. If the received
 * preamble length is greater than or less than the transmit preamble length, the
 * preamble error flag is asserted. This flag is cleared by writing `1'.
 *
 * Values:
 * - 0 - Preamble is correct.
 * - 1 - Preamble is in error.
 */
/*@{*/
#define BP_UART_S3_PEF       (7U)          /*!< Bit position for UART_S3_PEF. */
#define BM_UART_S3_PEF       (0x80U)       /*!< Bit mask for UART_S3_PEF. */
#define BS_UART_S3_PEF       (1U)          /*!< Bit field size in bits for UART_S3_PEF. */

/*! @brief Read current value of the UART_S3_PEF field. */
#define BR_UART_S3_PEF(x)    (BITBAND_ACCESS8(HW_UART_S3_ADDR(x), BP_UART_S3_PEF))

/*! @brief Format value for bitfield UART_S3_PEF. */
#define BF_UART_S3_PEF(v)    ((uint8_t)((uint8_t)(v) << BP_UART_S3_PEF) & BM_UART_S3_PEF)

/*! @brief Set the PEF field to a new value. */
#define BW_UART_S3_PEF(x, v) (BITBAND_ACCESS8(HW_UART_S3_ADDR(x), BP_UART_S3_PEF) = (v))
/*@}*/

/*******************************************************************************
 * HW_UART_S4 - UART CEA709.1-B Status Register
 ******************************************************************************/

/*!
 * @brief HW_UART_S4 - UART CEA709.1-B Status Register (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_uart_s4
{
    uint8_t U;
    struct _hw_uart_s4_bitfields
    {
        uint8_t FE : 1;                /*!< [0] Framing Error */
        uint8_t ILCV : 1;              /*!< [1] Improper Line Code Violation */
        uint8_t CDET : 2;              /*!< [3:2] CDET */
        uint8_t INITF : 1;             /*!< [4] Initial Synchronization Fail Flag */
        uint8_t RESERVED0 : 3;         /*!< [7:5]  */
    } B;
} hw_uart_s4_t;

/*!
 * @name Constants and macros for entire UART_S4 register
 */
/*@{*/
#define HW_UART_S4_ADDR(x)       ((x) + 0x2CU)

#define HW_UART_S4(x)            (*(__IO hw_uart_s4_t *) HW_UART_S4_ADDR(x))
#define HW_UART_S4_RD(x)         (HW_UART_S4(x).U)
#define HW_UART_S4_WR(x, v)      (HW_UART_S4(x).U = (v))
#define HW_UART_S4_SET(x, v)     (HW_UART_S4_WR(x, HW_UART_S4_RD(x) |  (v)))
#define HW_UART_S4_CLR(x, v)     (HW_UART_S4_WR(x, HW_UART_S4_RD(x) & ~(v)))
#define HW_UART_S4_TOG(x, v)     (HW_UART_S4_WR(x, HW_UART_S4_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual UART_S4 bitfields
 */

/*!
 * @name Register UART_S4, field FE[0] (RW)
 *
 * This flag indicates that received CEA709.1-B packet is finish at byte
 * boundary. This flag is cleared by writing `1'.
 *
 * Values:
 * - 0 - Received packet is byte bound.
 * - 1 - Received packet is not byte bound.
 */
/*@{*/
#define BP_UART_S4_FE        (0U)          /*!< Bit position for UART_S4_FE. */
#define BM_UART_S4_FE        (0x01U)       /*!< Bit mask for UART_S4_FE. */
#define BS_UART_S4_FE        (1U)          /*!< Bit field size in bits for UART_S4_FE. */

/*! @brief Read current value of the UART_S4_FE field. */
#define BR_UART_S4_FE(x)     (BITBAND_ACCESS8(HW_UART_S4_ADDR(x), BP_UART_S4_FE))

/*! @brief Format value for bitfield UART_S4_FE. */
#define BF_UART_S4_FE(v)     ((uint8_t)((uint8_t)(v) << BP_UART_S4_FE) & BM_UART_S4_FE)

/*! @brief Set the FE field to a new value. */
#define BW_UART_S4_FE(x, v)  (BITBAND_ACCESS8(HW_UART_S4_ADDR(x), BP_UART_S4_FE) = (v))
/*@}*/

/*!
 * @name Register UART_S4, field ILCV[1] (RW)
 *
 * This flag indicates that Line Code violation received is not proper. This
 * flag is cleared by writing `1'.
 *
 * Values:
 * - 0 - Line code violation received is proper.
 * - 1 - Line code violation received is improper i.e less than 3-bit periods.
 */
/*@{*/
#define BP_UART_S4_ILCV      (1U)          /*!< Bit position for UART_S4_ILCV. */
#define BM_UART_S4_ILCV      (0x02U)       /*!< Bit mask for UART_S4_ILCV. */
#define BS_UART_S4_ILCV      (1U)          /*!< Bit field size in bits for UART_S4_ILCV. */

/*! @brief Read current value of the UART_S4_ILCV field. */
#define BR_UART_S4_ILCV(x)   (BITBAND_ACCESS8(HW_UART_S4_ADDR(x), BP_UART_S4_ILCV))

/*! @brief Format value for bitfield UART_S4_ILCV. */
#define BF_UART_S4_ILCV(v)   ((uint8_t)((uint8_t)(v) << BP_UART_S4_ILCV) & BM_UART_S4_ILCV)

/*! @brief Set the ILCV field to a new value. */
#define BW_UART_S4_ILCV(x, v) (BITBAND_ACCESS8(HW_UART_S4_ADDR(x), BP_UART_S4_ILCV) = (v))
/*@}*/

/*!
 * @name Register UART_S4, field CDET[3:2] (RW)
 *
 * These bits indicates when the collision occurs during Transmission. This flag
 * is cleared by writing 2'b11. If collision flag is not cleared by software and
 * valid collision pulse is detected during some other phase of transmission,
 * then collision flag will continue to indicate the previous value.
 *
 * Values:
 * - 00 - No collision.
 * - 01 - Collision occurred during preamble.
 * - 10 - Collision occurred during data.
 * - 11 - Collision occurred during line code violation.
 */
/*@{*/
#define BP_UART_S4_CDET      (2U)          /*!< Bit position for UART_S4_CDET. */
#define BM_UART_S4_CDET      (0x0CU)       /*!< Bit mask for UART_S4_CDET. */
#define BS_UART_S4_CDET      (2U)          /*!< Bit field size in bits for UART_S4_CDET. */

/*! @brief Read current value of the UART_S4_CDET field. */
#define BR_UART_S4_CDET(x)   (HW_UART_S4(x).B.CDET)

/*! @brief Format value for bitfield UART_S4_CDET. */
#define BF_UART_S4_CDET(v)   ((uint8_t)((uint8_t)(v) << BP_UART_S4_CDET) & BM_UART_S4_CDET)

/*! @brief Set the CDET field to a new value. */
#define BW_UART_S4_CDET(x, v) (HW_UART_S4_WR(x, (HW_UART_S4_RD(x) & ~BM_UART_S4_CDET) | BF_UART_S4_CDET(v)))
/*@}*/

/*!
 * @name Register UART_S4, field INITF[4] (RO)
 *
 * This bit indicates that initial synchronization is failed and the packet
 * cycle time is expired after enabling EN709 register. This flag is cleared if EN709
 * is cleared.
 *
 * Values:
 * - 0 - Initial synchronization is not failed.
 * - 1 - Initial synchronization is failed.
 */
/*@{*/
#define BP_UART_S4_INITF     (4U)          /*!< Bit position for UART_S4_INITF. */
#define BM_UART_S4_INITF     (0x10U)       /*!< Bit mask for UART_S4_INITF. */
#define BS_UART_S4_INITF     (1U)          /*!< Bit field size in bits for UART_S4_INITF. */

/*! @brief Read current value of the UART_S4_INITF field. */
#define BR_UART_S4_INITF(x)  (BITBAND_ACCESS8(HW_UART_S4_ADDR(x), BP_UART_S4_INITF))
/*@}*/

/*******************************************************************************
 * HW_UART_RPL - UART CEA709.1-B Received Packet Length
 ******************************************************************************/

/*!
 * @brief HW_UART_RPL - UART CEA709.1-B Received Packet Length (RO)
 *
 * Reset value: 0x00U
 */
typedef union _hw_uart_rpl
{
    uint8_t U;
    struct _hw_uart_rpl_bitfields
    {
        uint8_t RPL : 8;               /*!< [7:0] Received packet length */
    } B;
} hw_uart_rpl_t;

/*!
 * @name Constants and macros for entire UART_RPL register
 */
/*@{*/
#define HW_UART_RPL_ADDR(x)      ((x) + 0x2DU)

#define HW_UART_RPL(x)           (*(__I hw_uart_rpl_t *) HW_UART_RPL_ADDR(x))
#define HW_UART_RPL_RD(x)        (HW_UART_RPL(x).U)
/*@}*/

/*
 * Constants & macros for individual UART_RPL bitfields
 */

/*!
 * @name Register UART_RPL, field RPL[7:0] (RO)
 *
 * This register field indicates the length of received packet in bytes. If the
 * received packet is not byte aligned then the partial byte received is appended
 * by zeros.
 */
/*@{*/
#define BP_UART_RPL_RPL      (0U)          /*!< Bit position for UART_RPL_RPL. */
#define BM_UART_RPL_RPL      (0xFFU)       /*!< Bit mask for UART_RPL_RPL. */
#define BS_UART_RPL_RPL      (8U)          /*!< Bit field size in bits for UART_RPL_RPL. */

/*! @brief Read current value of the UART_RPL_RPL field. */
#define BR_UART_RPL_RPL(x)   (HW_UART_RPL(x).U)
/*@}*/

/*******************************************************************************
 * HW_UART_RPREL - UART CEA709.1-B Received Preamble Length
 ******************************************************************************/

/*!
 * @brief HW_UART_RPREL - UART CEA709.1-B Received Preamble Length (RO)
 *
 * Reset value: 0x00U
 */
typedef union _hw_uart_rprel
{
    uint8_t U;
    struct _hw_uart_rprel_bitfields
    {
        uint8_t RPREL : 8;             /*!< [7:0] Received preamble length */
    } B;
} hw_uart_rprel_t;

/*!
 * @name Constants and macros for entire UART_RPREL register
 */
/*@{*/
#define HW_UART_RPREL_ADDR(x)    ((x) + 0x2EU)

#define HW_UART_RPREL(x)         (*(__I hw_uart_rprel_t *) HW_UART_RPREL_ADDR(x))
#define HW_UART_RPREL_RD(x)      (HW_UART_RPREL(x).U)
/*@}*/

/*
 * Constants & macros for individual UART_RPREL bitfields
 */

/*!
 * @name Register UART_RPREL, field RPREL[7:0] (RO)
 *
 * This register field indicates the number of bit sync fields received in the
 * preamble.
 */
/*@{*/
#define BP_UART_RPREL_RPREL  (0U)          /*!< Bit position for UART_RPREL_RPREL. */
#define BM_UART_RPREL_RPREL  (0xFFU)       /*!< Bit mask for UART_RPREL_RPREL. */
#define BS_UART_RPREL_RPREL  (8U)          /*!< Bit field size in bits for UART_RPREL_RPREL. */

/*! @brief Read current value of the UART_RPREL_RPREL field. */
#define BR_UART_RPREL_RPREL(x) (HW_UART_RPREL(x).U)
/*@}*/

/*******************************************************************************
 * HW_UART_CPW - UART CEA709.1-B Collision Pulse Width
 ******************************************************************************/

/*!
 * @brief HW_UART_CPW - UART CEA709.1-B Collision Pulse Width (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_uart_cpw
{
    uint8_t U;
    struct _hw_uart_cpw_bitfields
    {
        uint8_t CPW : 8;               /*!< [7:0] CEA709.1-B CPW register */
    } B;
} hw_uart_cpw_t;

/*!
 * @name Constants and macros for entire UART_CPW register
 */
/*@{*/
#define HW_UART_CPW_ADDR(x)      ((x) + 0x2FU)

#define HW_UART_CPW(x)           (*(__IO hw_uart_cpw_t *) HW_UART_CPW_ADDR(x))
#define HW_UART_CPW_RD(x)        (HW_UART_CPW(x).U)
#define HW_UART_CPW_WR(x, v)     (HW_UART_CPW(x).U = (v))
#define HW_UART_CPW_SET(x, v)    (HW_UART_CPW_WR(x, HW_UART_CPW_RD(x) |  (v)))
#define HW_UART_CPW_CLR(x, v)    (HW_UART_CPW_WR(x, HW_UART_CPW_RD(x) & ~(v)))
#define HW_UART_CPW_TOG(x, v)    (HW_UART_CPW_WR(x, HW_UART_CPW_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual UART_CPW bitfields
 */

/*!
 * @name Register UART_CPW, field CPW[7:0] (RW)
 *
 * This register indicates the width of valid collision pulse in terms of IPG
 * clock cycles.
 */
/*@{*/
#define BP_UART_CPW_CPW      (0U)          /*!< Bit position for UART_CPW_CPW. */
#define BM_UART_CPW_CPW      (0xFFU)       /*!< Bit mask for UART_CPW_CPW. */
#define BS_UART_CPW_CPW      (8U)          /*!< Bit field size in bits for UART_CPW_CPW. */

/*! @brief Read current value of the UART_CPW_CPW field. */
#define BR_UART_CPW_CPW(x)   (HW_UART_CPW(x).U)

/*! @brief Format value for bitfield UART_CPW_CPW. */
#define BF_UART_CPW_CPW(v)   ((uint8_t)((uint8_t)(v) << BP_UART_CPW_CPW) & BM_UART_CPW_CPW)

/*! @brief Set the CPW field to a new value. */
#define BW_UART_CPW_CPW(x, v) (HW_UART_CPW_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_UART_RIDT - UART CEA709.1-B Receive Indeterminate Time
 ******************************************************************************/

/*!
 * @brief HW_UART_RIDT - UART CEA709.1-B Receive Indeterminate Time (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_uart_ridt
{
    uint8_t U;
    struct _hw_uart_ridt_bitfields
    {
        uint8_t RIDT : 8;              /*!< [7:0] CEA709.1-B Receive IDT Register */
    } B;
} hw_uart_ridt_t;

/*!
 * @name Constants and macros for entire UART_RIDT register
 */
/*@{*/
#define HW_UART_RIDT_ADDR(x)     ((x) + 0x30U)

#define HW_UART_RIDT(x)          (*(__IO hw_uart_ridt_t *) HW_UART_RIDT_ADDR(x))
#define HW_UART_RIDT_RD(x)       (HW_UART_RIDT(x).U)
#define HW_UART_RIDT_WR(x, v)    (HW_UART_RIDT(x).U = (v))
#define HW_UART_RIDT_SET(x, v)   (HW_UART_RIDT_WR(x, HW_UART_RIDT_RD(x) |  (v)))
#define HW_UART_RIDT_CLR(x, v)   (HW_UART_RIDT_WR(x, HW_UART_RIDT_RD(x) & ~(v)))
#define HW_UART_RIDT_TOG(x, v)   (HW_UART_RIDT_WR(x, HW_UART_RIDT_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual UART_RIDT bitfields
 */

/*!
 * @name Register UART_RIDT, field RIDT[7:0] (RW)
 *
 * This register indicates the indeterminate time period after reception during
 * which any activity on RX line will be discarded. Indeterminate time period
 * value should be less than Beta1 timer value.
 */
/*@{*/
#define BP_UART_RIDT_RIDT    (0U)          /*!< Bit position for UART_RIDT_RIDT. */
#define BM_UART_RIDT_RIDT    (0xFFU)       /*!< Bit mask for UART_RIDT_RIDT. */
#define BS_UART_RIDT_RIDT    (8U)          /*!< Bit field size in bits for UART_RIDT_RIDT. */

/*! @brief Read current value of the UART_RIDT_RIDT field. */
#define BR_UART_RIDT_RIDT(x) (HW_UART_RIDT(x).U)

/*! @brief Format value for bitfield UART_RIDT_RIDT. */
#define BF_UART_RIDT_RIDT(v) ((uint8_t)((uint8_t)(v) << BP_UART_RIDT_RIDT) & BM_UART_RIDT_RIDT)

/*! @brief Set the RIDT field to a new value. */
#define BW_UART_RIDT_RIDT(x, v) (HW_UART_RIDT_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_UART_TIDT - UART CEA709.1-B Transmit Indeterminate Time
 ******************************************************************************/

/*!
 * @brief HW_UART_TIDT - UART CEA709.1-B Transmit Indeterminate Time (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_uart_tidt
{
    uint8_t U;
    struct _hw_uart_tidt_bitfields
    {
        uint8_t TIDT : 8;              /*!< [7:0] CEA709.1-B Transmit IDT Register */
    } B;
} hw_uart_tidt_t;

/*!
 * @name Constants and macros for entire UART_TIDT register
 */
/*@{*/
#define HW_UART_TIDT_ADDR(x)     ((x) + 0x31U)

#define HW_UART_TIDT(x)          (*(__IO hw_uart_tidt_t *) HW_UART_TIDT_ADDR(x))
#define HW_UART_TIDT_RD(x)       (HW_UART_TIDT(x).U)
#define HW_UART_TIDT_WR(x, v)    (HW_UART_TIDT(x).U = (v))
#define HW_UART_TIDT_SET(x, v)   (HW_UART_TIDT_WR(x, HW_UART_TIDT_RD(x) |  (v)))
#define HW_UART_TIDT_CLR(x, v)   (HW_UART_TIDT_WR(x, HW_UART_TIDT_RD(x) & ~(v)))
#define HW_UART_TIDT_TOG(x, v)   (HW_UART_TIDT_WR(x, HW_UART_TIDT_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual UART_TIDT bitfields
 */

/*!
 * @name Register UART_TIDT, field TIDT[7:0] (RW)
 *
 * This register indicates the indeterminate time period after transmission
 * during which any activity on RX line will be discarded. Indeterminate time period
 * value should be less than Beta1 timer value.
 */
/*@{*/
#define BP_UART_TIDT_TIDT    (0U)          /*!< Bit position for UART_TIDT_TIDT. */
#define BM_UART_TIDT_TIDT    (0xFFU)       /*!< Bit mask for UART_TIDT_TIDT. */
#define BS_UART_TIDT_TIDT    (8U)          /*!< Bit field size in bits for UART_TIDT_TIDT. */

/*! @brief Read current value of the UART_TIDT_TIDT field. */
#define BR_UART_TIDT_TIDT(x) (HW_UART_TIDT(x).U)

/*! @brief Format value for bitfield UART_TIDT_TIDT. */
#define BF_UART_TIDT_TIDT(v) ((uint8_t)((uint8_t)(v) << BP_UART_TIDT_TIDT) & BM_UART_TIDT_TIDT)

/*! @brief Set the TIDT field to a new value. */
#define BW_UART_TIDT_TIDT(x, v) (HW_UART_TIDT_WR(x, v))
/*@}*/

/*
** Start of section using anonymous unions
*/

#if defined(__ARMCC_VERSION)
  #pragma push
  #pragma anon_unions
#elif defined(__CWCC__)
  #pragma push
  #pragma cpp_extensions on
#elif defined(__GNUC__)
  /* anonymous unions are enabled by default */
#elif defined(__IAR_SYSTEMS_ICC__)
  #pragma language=extended
#else
  #error Not supported compiler type
#endif

/*******************************************************************************
 * hw_uart_t - module struct
 ******************************************************************************/
/*!
 * @brief All UART module registers.
 */
#pragma pack(1)
typedef struct _hw_uart
{
    __IO hw_uart_bdh_t BDH;                /*!< [0x0] UART Baud Rate Registers:High */
    __IO hw_uart_bdl_t BDL;                /*!< [0x1] UART Baud Rate Registers: Low */
    __IO hw_uart_c1_t C1;                  /*!< [0x2] UART Control Register 1 */
    __IO hw_uart_c2_t C2;                  /*!< [0x3] UART Control Register 2 */
    __I hw_uart_s1_t S1;                   /*!< [0x4] UART Status Register 1 */
    __IO hw_uart_s2_t S2;                  /*!< [0x5] UART Status Register 2 */
    __IO hw_uart_c3_t C3;                  /*!< [0x6] UART Control Register 3 */
    __IO hw_uart_d_t D;                    /*!< [0x7] UART Data Register */
    __IO hw_uart_ma1_t MA1;                /*!< [0x8] UART Match Address Registers 1 */
    __IO hw_uart_ma2_t MA2;                /*!< [0x9] UART Match Address Registers 2 */
    __IO hw_uart_c4_t C4;                  /*!< [0xA] UART Control Register 4 */
    __IO hw_uart_c5_t C5;                  /*!< [0xB] UART Control Register 5 */
    __I hw_uart_ed_t ED;                   /*!< [0xC] UART Extended Data Register */
    __IO hw_uart_modem_t MODEM;            /*!< [0xD] UART Modem Register */
    __IO hw_uart_ir_t IR;                  /*!< [0xE] UART Infrared Register */
    uint8_t _reserved0[1];
    __IO hw_uart_pfifo_t PFIFO;            /*!< [0x10] UART FIFO Parameters */
    __IO hw_uart_cfifo_t CFIFO;            /*!< [0x11] UART FIFO Control Register */
    __IO hw_uart_sfifo_t SFIFO;            /*!< [0x12] UART FIFO Status Register */
    __IO hw_uart_twfifo_t TWFIFO;          /*!< [0x13] UART FIFO Transmit Watermark */
    __I hw_uart_tcfifo_t TCFIFO;           /*!< [0x14] UART FIFO Transmit Count */
    __IO hw_uart_rwfifo_t RWFIFO;          /*!< [0x15] UART FIFO Receive Watermark */
    __I hw_uart_rcfifo_t RCFIFO;           /*!< [0x16] UART FIFO Receive Count */
    uint8_t _reserved1[1];
    __IO hw_uart_c7816_t C7816;            /*!< [0x18] UART 7816 Control Register */
    __IO hw_uart_ie7816_t IE7816;          /*!< [0x19] UART 7816 Interrupt Enable Register */
    __IO hw_uart_is7816_t IS7816;          /*!< [0x1A] UART 7816 Interrupt Status Register */
    union {
        __IO hw_uart_wp7816t0_t WP7816T0;  /*!< [0x1B] UART 7816 Wait Parameter Register */
        __IO hw_uart_wp7816t1_t WP7816T1;  /*!< [0x1B] UART 7816 Wait Parameter Register */
    };
    __IO hw_uart_wn7816_t WN7816;          /*!< [0x1C] UART 7816 Wait N Register */
    __IO hw_uart_wf7816_t WF7816;          /*!< [0x1D] UART 7816 Wait FD Register */
    __IO hw_uart_et7816_t ET7816;          /*!< [0x1E] UART 7816 Error Threshold Register */
    __IO hw_uart_tl7816_t TL7816;          /*!< [0x1F] UART 7816 Transmit Length Register */
    uint8_t _reserved2[1];
    __IO hw_uart_c6_t C6;                  /*!< [0x21] UART CEA709.1-B Control Register 6 */
    __IO hw_uart_pcth_t PCTH;              /*!< [0x22] UART CEA709.1-B Packet Cycle Time Counter High */
    __IO hw_uart_pctl_t PCTL;              /*!< [0x23] UART CEA709.1-B Packet Cycle Time Counter Low */
    __IO hw_uart_b1t_t B1T;                /*!< [0x24] UART CEA709.1-B Beta1 Timer */
    __IO hw_uart_sdth_t SDTH;              /*!< [0x25] UART CEA709.1-B Secondary Delay Timer High */
    __IO hw_uart_sdtl_t SDTL;              /*!< [0x26] UART CEA709.1-B Secondary Delay Timer Low */
    __IO hw_uart_pre_t PRE;                /*!< [0x27] UART CEA709.1-B Preamble */
    __IO hw_uart_tpl_t TPL;                /*!< [0x28] UART CEA709.1-B Transmit Packet Length */
    __IO hw_uart_ie_t IE;                  /*!< [0x29] UART CEA709.1-B Interrupt Enable Register */
    __IO hw_uart_wb_t WB;                  /*!< [0x2A] UART CEA709.1-B WBASE */
    __IO hw_uart_s3_t S3;                  /*!< [0x2B] UART CEA709.1-B Status Register */
    __IO hw_uart_s4_t S4;                  /*!< [0x2C] UART CEA709.1-B Status Register */
    __I hw_uart_rpl_t RPL;                 /*!< [0x2D] UART CEA709.1-B Received Packet Length */
    __I hw_uart_rprel_t RPREL;             /*!< [0x2E] UART CEA709.1-B Received Preamble Length */
    __IO hw_uart_cpw_t CPW;                /*!< [0x2F] UART CEA709.1-B Collision Pulse Width */
    __IO hw_uart_ridt_t RIDT;              /*!< [0x30] UART CEA709.1-B Receive Indeterminate Time */
    __IO hw_uart_tidt_t TIDT;              /*!< [0x31] UART CEA709.1-B Transmit Indeterminate Time */
} hw_uart_t;
#pragma pack()

/*! @brief Macro to access all UART registers. */
/*! @param x UART module instance base address. */
/*! @return Reference (not a pointer) to the registers struct. To get a pointer to the struct,
 *     use the '&' operator, like <code>&HW_UART(UART0_BASE)</code>. */
#define HW_UART(x)     (*(hw_uart_t *)(x))

/*
** End of section using anonymous unions
*/

#if defined(__ARMCC_VERSION)
  #pragma pop
#elif defined(__CWCC__)
  #pragma pop
#elif defined(__GNUC__)
  /* leave anonymous unions enabled */
#elif defined(__IAR_SYSTEMS_ICC__)
  #pragma language=default
#else
  #error Not supported compiler type
#endif

#endif /* __HW_UART_REGISTERS_H__ */
/* v33/140401/2.1.0 */
/* EOF */

/*
 * Copyright (c) 2014, Freescale Semiconductor, Inc.
 * All rights reserved.
 *
 * THIS SOFTWARE IS PROVIDED BY FREESCALE "AS IS" AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
 * SHALL FREESCALE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
 * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
 * OF SUCH DAMAGE.
 */
/*
 * WARNING! DO NOT EDIT THIS FILE DIRECTLY!
 *
 * This file was generated automatically and any changes may be lost.
 */
#ifndef __HW_UART0_REGISTERS_H__
#define __HW_UART0_REGISTERS_H__

#include "MKL05Z4.h"
#include "fsl_bitband.h"

/*
 * MKL05Z4 UART0
 *
 * Universal Asynchronous Receiver/Transmitter
 *
 * Registers defined in this header file:
 * - HW_UART0_BDH - UART Baud Rate Register High
 * - HW_UART0_BDL - UART Baud Rate Register Low
 * - HW_UART0_C1 - UART Control Register 1
 * - HW_UART0_C2 - UART Control Register 2
 * - HW_UART0_S1 - UART Status Register 1
 * - HW_UART0_S2 - UART Status Register 2
 * - HW_UART0_C3 - UART Control Register 3
 * - HW_UART0_D - UART Data Register
 * - HW_UART0_MA1 - UART Match Address Registers 1
 * - HW_UART0_MA2 - UART Match Address Registers 2
 * - HW_UART0_C4 - UART Control Register 4
 * - HW_UART0_C5 - UART Control Register 5
 *
 * - hw_uart0_t - Struct containing all module registers.
 */

#define HW_UART0_INSTANCE_COUNT (1U) /*!< Number of instances of the UART0 module. */

/*******************************************************************************
 * HW_UART0_BDH - UART Baud Rate Register High
 ******************************************************************************/

/*!
 * @brief HW_UART0_BDH - UART Baud Rate Register High (RW)
 *
 * Reset value: 0x00U
 *
 * This register, along with UART _BDL, controls the prescale divisor for UART
 * baud rate generation. The 13-bit baud rate setting [SBR12:SBR0] should only be
 * updated when the transmitter and receiver are both disabled.
 */
typedef union _hw_uart0_bdh
{
    uint8_t U;
    struct _hw_uart0_bdh_bitfields
    {
        uint8_t SBR : 5;               /*!< [4:0] Baud Rate Modulo Divisor. */
        uint8_t SBNS : 1;              /*!< [5] Stop Bit Number Select */
        uint8_t RXEDGIE : 1;           /*!< [6] RX Input Active Edge Interrupt Enable
                                        * (for RXEDGIF) */
        uint8_t LBKDIE : 1;            /*!< [7] LIN Break Detect Interrupt Enable (for
                                        * LBKDIF) */
    } B;
} hw_uart0_bdh_t;

/*!
 * @name Constants and macros for entire UART0_BDH register
 */
/*@{*/
#define HW_UART0_BDH_ADDR(x)     ((x) + 0x0U)

#define HW_UART0_BDH(x)          (*(__IO hw_uart0_bdh_t *) HW_UART0_BDH_ADDR(x))
#define HW_UART0_BDH_RD(x)       (HW_UART0_BDH(x).U)
#define HW_UART0_BDH_WR(x, v)    (HW_UART0_BDH(x).U = (v))
#define HW_UART0_BDH_SET(x, v)   (BME_OR8(HW_UART0_BDH_ADDR(x), (uint8_t)(v)))
#define HW_UART0_BDH_CLR(x, v)   (BME_AND8(HW_UART0_BDH_ADDR(x), (uint8_t)(~(v))))
#define HW_UART0_BDH_TOG(x, v)   (BME_XOR8(HW_UART0_BDH_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual UART0_BDH bitfields
 */

/*!
 * @name Register UART0_BDH, field SBR[4:0] (RW)
 *
 * The 13 bits in SBR[12:0] are referred to collectively as BR, and they set the
 * modulo divide rate for the baud rate generator. When BR is 1 - 8191, the baud
 * rate equals baud clock / ((OSR+1) * BR).
 */
/*@{*/
#define BP_UART0_BDH_SBR     (0U)          /*!< Bit position for UART0_BDH_SBR. */
#define BM_UART0_BDH_SBR     (0x1FU)       /*!< Bit mask for UART0_BDH_SBR. */
#define BS_UART0_BDH_SBR     (5U)          /*!< Bit field size in bits for UART0_BDH_SBR. */

/*! @brief Read current value of the UART0_BDH_SBR field. */
#define BR_UART0_BDH_SBR(x)  (BME_UBFX8(HW_UART0_BDH_ADDR(x), BP_UART0_BDH_SBR, BS_UART0_BDH_SBR))

/*! @brief Format value for bitfield UART0_BDH_SBR. */
#define BF_UART0_BDH_SBR(v)  ((uint8_t)((uint8_t)(v) << BP_UART0_BDH_SBR) & BM_UART0_BDH_SBR)

/*! @brief Set the SBR field to a new value. */
#define BW_UART0_BDH_SBR(x, v) (BME_BFI8(HW_UART0_BDH_ADDR(x), ((uint8_t)(v) << BP_UART0_BDH_SBR), BP_UART0_BDH_SBR, 5))
/*@}*/

/*!
 * @name Register UART0_BDH, field SBNS[5] (RW)
 *
 * SBNS determines whether data characters are one or two stop bits. This bit
 * should only be changed when the transmitter and receiver are both disabled.
 *
 * Values:
 * - 0 - One stop bit.
 * - 1 - Two stop bit.
 */
/*@{*/
#define BP_UART0_BDH_SBNS    (5U)          /*!< Bit position for UART0_BDH_SBNS. */
#define BM_UART0_BDH_SBNS    (0x20U)       /*!< Bit mask for UART0_BDH_SBNS. */
#define BS_UART0_BDH_SBNS    (1U)          /*!< Bit field size in bits for UART0_BDH_SBNS. */

/*! @brief Read current value of the UART0_BDH_SBNS field. */
#define BR_UART0_BDH_SBNS(x) (BME_UBFX8(HW_UART0_BDH_ADDR(x), BP_UART0_BDH_SBNS, BS_UART0_BDH_SBNS))

/*! @brief Format value for bitfield UART0_BDH_SBNS. */
#define BF_UART0_BDH_SBNS(v) ((uint8_t)((uint8_t)(v) << BP_UART0_BDH_SBNS) & BM_UART0_BDH_SBNS)

/*! @brief Set the SBNS field to a new value. */
#define BW_UART0_BDH_SBNS(x, v) (BME_BFI8(HW_UART0_BDH_ADDR(x), ((uint8_t)(v) << BP_UART0_BDH_SBNS), BP_UART0_BDH_SBNS, 1))
/*@}*/

/*!
 * @name Register UART0_BDH, field RXEDGIE[6] (RW)
 *
 * Values:
 * - 0 - Hardware interrupts from UART _S2[RXEDGIF] disabled (use polling).
 * - 1 - Hardware interrupt requested when UART _S2[RXEDGIF] flag is 1.
 */
/*@{*/
#define BP_UART0_BDH_RXEDGIE (6U)          /*!< Bit position for UART0_BDH_RXEDGIE. */
#define BM_UART0_BDH_RXEDGIE (0x40U)       /*!< Bit mask for UART0_BDH_RXEDGIE. */
#define BS_UART0_BDH_RXEDGIE (1U)          /*!< Bit field size in bits for UART0_BDH_RXEDGIE. */

/*! @brief Read current value of the UART0_BDH_RXEDGIE field. */
#define BR_UART0_BDH_RXEDGIE(x) (BME_UBFX8(HW_UART0_BDH_ADDR(x), BP_UART0_BDH_RXEDGIE, BS_UART0_BDH_RXEDGIE))

/*! @brief Format value for bitfield UART0_BDH_RXEDGIE. */
#define BF_UART0_BDH_RXEDGIE(v) ((uint8_t)((uint8_t)(v) << BP_UART0_BDH_RXEDGIE) & BM_UART0_BDH_RXEDGIE)

/*! @brief Set the RXEDGIE field to a new value. */
#define BW_UART0_BDH_RXEDGIE(x, v) (BME_BFI8(HW_UART0_BDH_ADDR(x), ((uint8_t)(v) << BP_UART0_BDH_RXEDGIE), BP_UART0_BDH_RXEDGIE, 1))
/*@}*/

/*!
 * @name Register UART0_BDH, field LBKDIE[7] (RW)
 *
 * Values:
 * - 0 - Hardware interrupts from UART _S2[LBKDIF] disabled (use polling).
 * - 1 - Hardware interrupt requested when UART _S2[LBKDIF] flag is 1.
 */
/*@{*/
#define BP_UART0_BDH_LBKDIE  (7U)          /*!< Bit position for UART0_BDH_LBKDIE. */
#define BM_UART0_BDH_LBKDIE  (0x80U)       /*!< Bit mask for UART0_BDH_LBKDIE. */
#define BS_UART0_BDH_LBKDIE  (1U)          /*!< Bit field size in bits for UART0_BDH_LBKDIE. */

/*! @brief Read current value of the UART0_BDH_LBKDIE field. */
#define BR_UART0_BDH_LBKDIE(x) (BME_UBFX8(HW_UART0_BDH_ADDR(x), BP_UART0_BDH_LBKDIE, BS_UART0_BDH_LBKDIE))

/*! @brief Format value for bitfield UART0_BDH_LBKDIE. */
#define BF_UART0_BDH_LBKDIE(v) ((uint8_t)((uint8_t)(v) << BP_UART0_BDH_LBKDIE) & BM_UART0_BDH_LBKDIE)

/*! @brief Set the LBKDIE field to a new value. */
#define BW_UART0_BDH_LBKDIE(x, v) (BME_BFI8(HW_UART0_BDH_ADDR(x), ((uint8_t)(v) << BP_UART0_BDH_LBKDIE), BP_UART0_BDH_LBKDIE, 1))
/*@}*/

/*******************************************************************************
 * HW_UART0_BDL - UART Baud Rate Register Low
 ******************************************************************************/

/*!
 * @brief HW_UART0_BDL - UART Baud Rate Register Low (RW)
 *
 * Reset value: 0x04U
 *
 * This register, along with UART _BDH, control the prescale divisor for UART
 * baud rate generation. The 13-bit baud rate setting [SBR12:SBR0] can only be
 * updated when the transmitter and receiver are both disabled. UART _BDL is reset to
 * a non-zero value, so after reset the baud rate generator remains disabled
 * until the first time the receiver or transmitter is enabled; that is, UART
 * _C2[RE] or UART _C2[TE] bits are written to 1.
 */
typedef union _hw_uart0_bdl
{
    uint8_t U;
    struct _hw_uart0_bdl_bitfields
    {
        uint8_t SBR : 8;               /*!< [7:0] Baud Rate Modulo Divisor */
    } B;
} hw_uart0_bdl_t;

/*!
 * @name Constants and macros for entire UART0_BDL register
 */
/*@{*/
#define HW_UART0_BDL_ADDR(x)     ((x) + 0x1U)

#define HW_UART0_BDL(x)          (*(__IO hw_uart0_bdl_t *) HW_UART0_BDL_ADDR(x))
#define HW_UART0_BDL_RD(x)       (HW_UART0_BDL(x).U)
#define HW_UART0_BDL_WR(x, v)    (HW_UART0_BDL(x).U = (v))
#define HW_UART0_BDL_SET(x, v)   (BME_OR8(HW_UART0_BDL_ADDR(x), (uint8_t)(v)))
#define HW_UART0_BDL_CLR(x, v)   (BME_AND8(HW_UART0_BDL_ADDR(x), (uint8_t)(~(v))))
#define HW_UART0_BDL_TOG(x, v)   (BME_XOR8(HW_UART0_BDL_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual UART0_BDL bitfields
 */

/*!
 * @name Register UART0_BDL, field SBR[7:0] (RW)
 *
 * These 13 bits in SBR[12:0] are referred to collectively as BR. They set the
 * modulo divide rate for the baud rate generator. When BR is 1 - 8191, the baud
 * rate equals baud clock/((OSR+1) * BR).
 */
/*@{*/
#define BP_UART0_BDL_SBR     (0U)          /*!< Bit position for UART0_BDL_SBR. */
#define BM_UART0_BDL_SBR     (0xFFU)       /*!< Bit mask for UART0_BDL_SBR. */
#define BS_UART0_BDL_SBR     (8U)          /*!< Bit field size in bits for UART0_BDL_SBR. */

/*! @brief Read current value of the UART0_BDL_SBR field. */
#define BR_UART0_BDL_SBR(x)  (HW_UART0_BDL(x).U)

/*! @brief Format value for bitfield UART0_BDL_SBR. */
#define BF_UART0_BDL_SBR(v)  ((uint8_t)((uint8_t)(v) << BP_UART0_BDL_SBR) & BM_UART0_BDL_SBR)

/*! @brief Set the SBR field to a new value. */
#define BW_UART0_BDL_SBR(x, v) (HW_UART0_BDL_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_UART0_C1 - UART Control Register 1
 ******************************************************************************/

/*!
 * @brief HW_UART0_C1 - UART Control Register 1 (RW)
 *
 * Reset value: 0x00U
 *
 * This read/write register controls various optional features of the UART
 * system. This register should only be altered when the transmitter and receiver are
 * both disabled.
 */
typedef union _hw_uart0_c1
{
    uint8_t U;
    struct _hw_uart0_c1_bitfields
    {
        uint8_t PT : 1;                /*!< [0] Parity Type */
        uint8_t PE : 1;                /*!< [1] Parity Enable */
        uint8_t ILT : 1;               /*!< [2] Idle Line Type Select */
        uint8_t WAKE : 1;              /*!< [3] Receiver Wakeup Method Select */
        uint8_t M : 1;                 /*!< [4] 9-Bit or 8-Bit Mode Select */
        uint8_t RSRC : 1;              /*!< [5] Receiver Source Select */
        uint8_t DOZEEN : 1;            /*!< [6] Doze Enable */
        uint8_t LOOPS : 1;             /*!< [7] Loop Mode Select */
    } B;
} hw_uart0_c1_t;

/*!
 * @name Constants and macros for entire UART0_C1 register
 */
/*@{*/
#define HW_UART0_C1_ADDR(x)      ((x) + 0x2U)

#define HW_UART0_C1(x)           (*(__IO hw_uart0_c1_t *) HW_UART0_C1_ADDR(x))
#define HW_UART0_C1_RD(x)        (HW_UART0_C1(x).U)
#define HW_UART0_C1_WR(x, v)     (HW_UART0_C1(x).U = (v))
#define HW_UART0_C1_SET(x, v)    (BME_OR8(HW_UART0_C1_ADDR(x), (uint8_t)(v)))
#define HW_UART0_C1_CLR(x, v)    (BME_AND8(HW_UART0_C1_ADDR(x), (uint8_t)(~(v))))
#define HW_UART0_C1_TOG(x, v)    (BME_XOR8(HW_UART0_C1_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual UART0_C1 bitfields
 */

/*!
 * @name Register UART0_C1, field PT[0] (RW)
 *
 * Provided parity is enabled (PE = 1), this bit selects even or odd parity. Odd
 * parity means the total number of 1s in the data character, including the
 * parity bit, is odd. Even parity means the total number of 1s in the data
 * character, including the parity bit, is even.
 *
 * Values:
 * - 0 - Even parity.
 * - 1 - Odd parity.
 */
/*@{*/
#define BP_UART0_C1_PT       (0U)          /*!< Bit position for UART0_C1_PT. */
#define BM_UART0_C1_PT       (0x01U)       /*!< Bit mask for UART0_C1_PT. */
#define BS_UART0_C1_PT       (1U)          /*!< Bit field size in bits for UART0_C1_PT. */

/*! @brief Read current value of the UART0_C1_PT field. */
#define BR_UART0_C1_PT(x)    (BME_UBFX8(HW_UART0_C1_ADDR(x), BP_UART0_C1_PT, BS_UART0_C1_PT))

/*! @brief Format value for bitfield UART0_C1_PT. */
#define BF_UART0_C1_PT(v)    ((uint8_t)((uint8_t)(v) << BP_UART0_C1_PT) & BM_UART0_C1_PT)

/*! @brief Set the PT field to a new value. */
#define BW_UART0_C1_PT(x, v) (BME_BFI8(HW_UART0_C1_ADDR(x), ((uint8_t)(v) << BP_UART0_C1_PT), BP_UART0_C1_PT, 1))
/*@}*/

/*!
 * @name Register UART0_C1, field PE[1] (RW)
 *
 * Enables hardware parity generation and checking. When parity is enabled, the
 * bit immediately before the stop bit is treated as the parity bit.
 *
 * Values:
 * - 0 - No hardware parity generation or checking.
 * - 1 - Parity enabled.
 */
/*@{*/
#define BP_UART0_C1_PE       (1U)          /*!< Bit position for UART0_C1_PE. */
#define BM_UART0_C1_PE       (0x02U)       /*!< Bit mask for UART0_C1_PE. */
#define BS_UART0_C1_PE       (1U)          /*!< Bit field size in bits for UART0_C1_PE. */

/*! @brief Read current value of the UART0_C1_PE field. */
#define BR_UART0_C1_PE(x)    (BME_UBFX8(HW_UART0_C1_ADDR(x), BP_UART0_C1_PE, BS_UART0_C1_PE))

/*! @brief Format value for bitfield UART0_C1_PE. */
#define BF_UART0_C1_PE(v)    ((uint8_t)((uint8_t)(v) << BP_UART0_C1_PE) & BM_UART0_C1_PE)

/*! @brief Set the PE field to a new value. */
#define BW_UART0_C1_PE(x, v) (BME_BFI8(HW_UART0_C1_ADDR(x), ((uint8_t)(v) << BP_UART0_C1_PE), BP_UART0_C1_PE, 1))
/*@}*/

/*!
 * @name Register UART0_C1, field ILT[2] (RW)
 *
 * Setting this bit to 1 ensures that the stop bits and logic 1 bits at the end
 * of a character do not count toward the 10 to 13 bit times of logic high level
 * needed by the idle line detection logic.
 *
 * Values:
 * - 0 - Idle character bit count starts after start bit.
 * - 1 - Idle character bit count starts after stop bit.
 */
/*@{*/
#define BP_UART0_C1_ILT      (2U)          /*!< Bit position for UART0_C1_ILT. */
#define BM_UART0_C1_ILT      (0x04U)       /*!< Bit mask for UART0_C1_ILT. */
#define BS_UART0_C1_ILT      (1U)          /*!< Bit field size in bits for UART0_C1_ILT. */

/*! @brief Read current value of the UART0_C1_ILT field. */
#define BR_UART0_C1_ILT(x)   (BME_UBFX8(HW_UART0_C1_ADDR(x), BP_UART0_C1_ILT, BS_UART0_C1_ILT))

/*! @brief Format value for bitfield UART0_C1_ILT. */
#define BF_UART0_C1_ILT(v)   ((uint8_t)((uint8_t)(v) << BP_UART0_C1_ILT) & BM_UART0_C1_ILT)

/*! @brief Set the ILT field to a new value. */
#define BW_UART0_C1_ILT(x, v) (BME_BFI8(HW_UART0_C1_ADDR(x), ((uint8_t)(v) << BP_UART0_C1_ILT), BP_UART0_C1_ILT, 1))
/*@}*/

/*!
 * @name Register UART0_C1, field WAKE[3] (RW)
 *
 * Values:
 * - 0 - Idle-line wakeup.
 * - 1 - Address-mark wakeup.
 */
/*@{*/
#define BP_UART0_C1_WAKE     (3U)          /*!< Bit position for UART0_C1_WAKE. */
#define BM_UART0_C1_WAKE     (0x08U)       /*!< Bit mask for UART0_C1_WAKE. */
#define BS_UART0_C1_WAKE     (1U)          /*!< Bit field size in bits for UART0_C1_WAKE. */

/*! @brief Read current value of the UART0_C1_WAKE field. */
#define BR_UART0_C1_WAKE(x)  (BME_UBFX8(HW_UART0_C1_ADDR(x), BP_UART0_C1_WAKE, BS_UART0_C1_WAKE))

/*! @brief Format value for bitfield UART0_C1_WAKE. */
#define BF_UART0_C1_WAKE(v)  ((uint8_t)((uint8_t)(v) << BP_UART0_C1_WAKE) & BM_UART0_C1_WAKE)

/*! @brief Set the WAKE field to a new value. */
#define BW_UART0_C1_WAKE(x, v) (BME_BFI8(HW_UART0_C1_ADDR(x), ((uint8_t)(v) << BP_UART0_C1_WAKE), BP_UART0_C1_WAKE, 1))
/*@}*/

/*!
 * @name Register UART0_C1, field M[4] (RW)
 *
 * Values:
 * - 0 - Receiver and transmitter use 8-bit data characters.
 * - 1 - Receiver and transmitter use 9-bit data characters.
 */
/*@{*/
#define BP_UART0_C1_M        (4U)          /*!< Bit position for UART0_C1_M. */
#define BM_UART0_C1_M        (0x10U)       /*!< Bit mask for UART0_C1_M. */
#define BS_UART0_C1_M        (1U)          /*!< Bit field size in bits for UART0_C1_M. */

/*! @brief Read current value of the UART0_C1_M field. */
#define BR_UART0_C1_M(x)     (BME_UBFX8(HW_UART0_C1_ADDR(x), BP_UART0_C1_M, BS_UART0_C1_M))

/*! @brief Format value for bitfield UART0_C1_M. */
#define BF_UART0_C1_M(v)     ((uint8_t)((uint8_t)(v) << BP_UART0_C1_M) & BM_UART0_C1_M)

/*! @brief Set the M field to a new value. */
#define BW_UART0_C1_M(x, v)  (BME_BFI8(HW_UART0_C1_ADDR(x), ((uint8_t)(v) << BP_UART0_C1_M), BP_UART0_C1_M, 1))
/*@}*/

/*!
 * @name Register UART0_C1, field RSRC[5] (RW)
 *
 * This bit has no meaning or effect unless the LOOPS bit is set to 1. When
 * LOOPS is set, the receiver input is internally connected to the UART _TX pin and
 * RSRC determines whether this connection is also connected to the transmitter
 * output.
 *
 * Values:
 * - 0 - Provided LOOPS is set, RSRC is cleared, selects internal loop back mode
 *     and the UART does not use the UART _RX pins.
 * - 1 - Single-wire UART mode where the UART _TX pin is connected to the
 *     transmitter output and receiver input.
 */
/*@{*/
#define BP_UART0_C1_RSRC     (5U)          /*!< Bit position for UART0_C1_RSRC. */
#define BM_UART0_C1_RSRC     (0x20U)       /*!< Bit mask for UART0_C1_RSRC. */
#define BS_UART0_C1_RSRC     (1U)          /*!< Bit field size in bits for UART0_C1_RSRC. */

/*! @brief Read current value of the UART0_C1_RSRC field. */
#define BR_UART0_C1_RSRC(x)  (BME_UBFX8(HW_UART0_C1_ADDR(x), BP_UART0_C1_RSRC, BS_UART0_C1_RSRC))

/*! @brief Format value for bitfield UART0_C1_RSRC. */
#define BF_UART0_C1_RSRC(v)  ((uint8_t)((uint8_t)(v) << BP_UART0_C1_RSRC) & BM_UART0_C1_RSRC)

/*! @brief Set the RSRC field to a new value. */
#define BW_UART0_C1_RSRC(x, v) (BME_BFI8(HW_UART0_C1_ADDR(x), ((uint8_t)(v) << BP_UART0_C1_RSRC), BP_UART0_C1_RSRC, 1))
/*@}*/

/*!
 * @name Register UART0_C1, field DOZEEN[6] (RW)
 *
 * Values:
 * - 0 - UART is enabled in Wait mode.
 * - 1 - UART is disabled in Wait mode.
 */
/*@{*/
#define BP_UART0_C1_DOZEEN   (6U)          /*!< Bit position for UART0_C1_DOZEEN. */
#define BM_UART0_C1_DOZEEN   (0x40U)       /*!< Bit mask for UART0_C1_DOZEEN. */
#define BS_UART0_C1_DOZEEN   (1U)          /*!< Bit field size in bits for UART0_C1_DOZEEN. */

/*! @brief Read current value of the UART0_C1_DOZEEN field. */
#define BR_UART0_C1_DOZEEN(x) (BME_UBFX8(HW_UART0_C1_ADDR(x), BP_UART0_C1_DOZEEN, BS_UART0_C1_DOZEEN))

/*! @brief Format value for bitfield UART0_C1_DOZEEN. */
#define BF_UART0_C1_DOZEEN(v) ((uint8_t)((uint8_t)(v) << BP_UART0_C1_DOZEEN) & BM_UART0_C1_DOZEEN)

/*! @brief Set the DOZEEN field to a new value. */
#define BW_UART0_C1_DOZEEN(x, v) (BME_BFI8(HW_UART0_C1_ADDR(x), ((uint8_t)(v) << BP_UART0_C1_DOZEEN), BP_UART0_C1_DOZEEN, 1))
/*@}*/

/*!
 * @name Register UART0_C1, field LOOPS[7] (RW)
 *
 * Selects between loop back modes and normal 2-pin full-duplex modes. When
 * LOOPS is set, the transmitter output is internally connected to the receiver input.
 *
 * Values:
 * - 0 - Normal operation - UART _RX and UART _TX use separate pins.
 * - 1 - Loop mode or single-wire mode where transmitter outputs are internally
 *     connected to receiver input. (See RSRC bit.) UART _RX pin is not used by
 *     UART .
 */
/*@{*/
#define BP_UART0_C1_LOOPS    (7U)          /*!< Bit position for UART0_C1_LOOPS. */
#define BM_UART0_C1_LOOPS    (0x80U)       /*!< Bit mask for UART0_C1_LOOPS. */
#define BS_UART0_C1_LOOPS    (1U)          /*!< Bit field size in bits for UART0_C1_LOOPS. */

/*! @brief Read current value of the UART0_C1_LOOPS field. */
#define BR_UART0_C1_LOOPS(x) (BME_UBFX8(HW_UART0_C1_ADDR(x), BP_UART0_C1_LOOPS, BS_UART0_C1_LOOPS))

/*! @brief Format value for bitfield UART0_C1_LOOPS. */
#define BF_UART0_C1_LOOPS(v) ((uint8_t)((uint8_t)(v) << BP_UART0_C1_LOOPS) & BM_UART0_C1_LOOPS)

/*! @brief Set the LOOPS field to a new value. */
#define BW_UART0_C1_LOOPS(x, v) (BME_BFI8(HW_UART0_C1_ADDR(x), ((uint8_t)(v) << BP_UART0_C1_LOOPS), BP_UART0_C1_LOOPS, 1))
/*@}*/

/*******************************************************************************
 * HW_UART0_C2 - UART Control Register 2
 ******************************************************************************/

/*!
 * @brief HW_UART0_C2 - UART Control Register 2 (RW)
 *
 * Reset value: 0x00U
 *
 * This register can be read or written at any time.
 */
typedef union _hw_uart0_c2
{
    uint8_t U;
    struct _hw_uart0_c2_bitfields
    {
        uint8_t SBK : 1;               /*!< [0] Send Break */
        uint8_t RWU : 1;               /*!< [1] Receiver Wakeup Control */
        uint8_t RE : 1;                /*!< [2] Receiver Enable */
        uint8_t TE : 1;                /*!< [3] Transmitter Enable */
        uint8_t ILIE : 1;              /*!< [4] Idle Line Interrupt Enable for IDLE */
        uint8_t RIE : 1;               /*!< [5] Receiver Interrupt Enable for RDRF */
        uint8_t TCIE : 1;              /*!< [6] Transmission Complete Interrupt Enable for
                                        * TC */
        uint8_t TIE : 1;               /*!< [7] Transmit Interrupt Enable for TDRE */
    } B;
} hw_uart0_c2_t;

/*!
 * @name Constants and macros for entire UART0_C2 register
 */
/*@{*/
#define HW_UART0_C2_ADDR(x)      ((x) + 0x3U)

#define HW_UART0_C2(x)           (*(__IO hw_uart0_c2_t *) HW_UART0_C2_ADDR(x))
#define HW_UART0_C2_RD(x)        (HW_UART0_C2(x).U)
#define HW_UART0_C2_WR(x, v)     (HW_UART0_C2(x).U = (v))
#define HW_UART0_C2_SET(x, v)    (BME_OR8(HW_UART0_C2_ADDR(x), (uint8_t)(v)))
#define HW_UART0_C2_CLR(x, v)    (BME_AND8(HW_UART0_C2_ADDR(x), (uint8_t)(~(v))))
#define HW_UART0_C2_TOG(x, v)    (BME_XOR8(HW_UART0_C2_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual UART0_C2 bitfields
 */

/*!
 * @name Register UART0_C2, field SBK[0] (RW)
 *
 * Writing a 1 and then a 0 to SBK queues a break character in the transmit data
 * stream. Additional break characters of 10 to 13, or 13 to 16 if BRK13 = 1,
 * bit times of logic 0 are queued as long as SBK is set. Depending on the timing
 * of the set and clear of SBK relative to the information currently being
 * transmitted, a second break character may be queued before software clears SBK.
 *
 * Values:
 * - 0 - Normal transmitter operation.
 * - 1 - Queue break character(s) to be sent.
 */
/*@{*/
#define BP_UART0_C2_SBK      (0U)          /*!< Bit position for UART0_C2_SBK. */
#define BM_UART0_C2_SBK      (0x01U)       /*!< Bit mask for UART0_C2_SBK. */
#define BS_UART0_C2_SBK      (1U)          /*!< Bit field size in bits for UART0_C2_SBK. */

/*! @brief Read current value of the UART0_C2_SBK field. */
#define BR_UART0_C2_SBK(x)   (BME_UBFX8(HW_UART0_C2_ADDR(x), BP_UART0_C2_SBK, BS_UART0_C2_SBK))

/*! @brief Format value for bitfield UART0_C2_SBK. */
#define BF_UART0_C2_SBK(v)   ((uint8_t)((uint8_t)(v) << BP_UART0_C2_SBK) & BM_UART0_C2_SBK)

/*! @brief Set the SBK field to a new value. */
#define BW_UART0_C2_SBK(x, v) (BME_BFI8(HW_UART0_C2_ADDR(x), ((uint8_t)(v) << BP_UART0_C2_SBK), BP_UART0_C2_SBK, 1))
/*@}*/

/*!
 * @name Register UART0_C2, field RWU[1] (RW)
 *
 * This bit can be written to 1 to place the UART receiver in a standby state
 * where it waits for automatic hardware detection of a selected wakeup condition.
 * The wakeup condition is an idle line between messages, WAKE = 0, idle-line
 * wakeup, or a logic 1 in the most significant data bit in a character, WAKE = 1,
 * address-mark wakeup. Application software sets RWU and, normally, a selected
 * hardware condition automatically clears RWU.
 *
 * Values:
 * - 0 - Normal UART receiver operation.
 * - 1 - UART receiver in standby waiting for wakeup condition.
 */
/*@{*/
#define BP_UART0_C2_RWU      (1U)          /*!< Bit position for UART0_C2_RWU. */
#define BM_UART0_C2_RWU      (0x02U)       /*!< Bit mask for UART0_C2_RWU. */
#define BS_UART0_C2_RWU      (1U)          /*!< Bit field size in bits for UART0_C2_RWU. */

/*! @brief Read current value of the UART0_C2_RWU field. */
#define BR_UART0_C2_RWU(x)   (BME_UBFX8(HW_UART0_C2_ADDR(x), BP_UART0_C2_RWU, BS_UART0_C2_RWU))

/*! @brief Format value for bitfield UART0_C2_RWU. */
#define BF_UART0_C2_RWU(v)   ((uint8_t)((uint8_t)(v) << BP_UART0_C2_RWU) & BM_UART0_C2_RWU)

/*! @brief Set the RWU field to a new value. */
#define BW_UART0_C2_RWU(x, v) (BME_BFI8(HW_UART0_C2_ADDR(x), ((uint8_t)(v) << BP_UART0_C2_RWU), BP_UART0_C2_RWU, 1))
/*@}*/

/*!
 * @name Register UART0_C2, field RE[2] (RW)
 *
 * When the UART receiver is off or LOOPS is set, the UART _RX pin is not used
 * by the UART . When RE is written to 0, the receiver finishes receiving the
 * current character (if any).
 *
 * Values:
 * - 0 - Receiver disabled.
 * - 1 - Receiver enabled.
 */
/*@{*/
#define BP_UART0_C2_RE       (2U)          /*!< Bit position for UART0_C2_RE. */
#define BM_UART0_C2_RE       (0x04U)       /*!< Bit mask for UART0_C2_RE. */
#define BS_UART0_C2_RE       (1U)          /*!< Bit field size in bits for UART0_C2_RE. */

/*! @brief Read current value of the UART0_C2_RE field. */
#define BR_UART0_C2_RE(x)    (BME_UBFX8(HW_UART0_C2_ADDR(x), BP_UART0_C2_RE, BS_UART0_C2_RE))

/*! @brief Format value for bitfield UART0_C2_RE. */
#define BF_UART0_C2_RE(v)    ((uint8_t)((uint8_t)(v) << BP_UART0_C2_RE) & BM_UART0_C2_RE)

/*! @brief Set the RE field to a new value. */
#define BW_UART0_C2_RE(x, v) (BME_BFI8(HW_UART0_C2_ADDR(x), ((uint8_t)(v) << BP_UART0_C2_RE), BP_UART0_C2_RE, 1))
/*@}*/

/*!
 * @name Register UART0_C2, field TE[3] (RW)
 *
 * TE must be 1 to use the UART transmitter. When TE is set, the UART forces the
 * UART _TX pin to act as an output for the UART system. When the UART is
 * configured for single-wire operation (LOOPS = RSRC = 1), TXDIR controls the
 * direction of traffic on the single UART communication line ( UART _TX pin). TE can
 * also queue an idle character by clearing TE then setting TE while a transmission
 * is in progress. When TE is written to 0, the transmitter keeps control of the
 * port UART _TX pin until any data, queued idle, or queued break character
 * finishes transmitting before allowing the pin to tristate.
 *
 * Values:
 * - 0 - Transmitter disabled.
 * - 1 - Transmitter enabled.
 */
/*@{*/
#define BP_UART0_C2_TE       (3U)          /*!< Bit position for UART0_C2_TE. */
#define BM_UART0_C2_TE       (0x08U)       /*!< Bit mask for UART0_C2_TE. */
#define BS_UART0_C2_TE       (1U)          /*!< Bit field size in bits for UART0_C2_TE. */

/*! @brief Read current value of the UART0_C2_TE field. */
#define BR_UART0_C2_TE(x)    (BME_UBFX8(HW_UART0_C2_ADDR(x), BP_UART0_C2_TE, BS_UART0_C2_TE))

/*! @brief Format value for bitfield UART0_C2_TE. */
#define BF_UART0_C2_TE(v)    ((uint8_t)((uint8_t)(v) << BP_UART0_C2_TE) & BM_UART0_C2_TE)

/*! @brief Set the TE field to a new value. */
#define BW_UART0_C2_TE(x, v) (BME_BFI8(HW_UART0_C2_ADDR(x), ((uint8_t)(v) << BP_UART0_C2_TE), BP_UART0_C2_TE, 1))
/*@}*/

/*!
 * @name Register UART0_C2, field ILIE[4] (RW)
 *
 * Values:
 * - 0 - Hardware interrupts from IDLE disabled; use polling.
 * - 1 - Hardware interrupt requested when IDLE flag is 1.
 */
/*@{*/
#define BP_UART0_C2_ILIE     (4U)          /*!< Bit position for UART0_C2_ILIE. */
#define BM_UART0_C2_ILIE     (0x10U)       /*!< Bit mask for UART0_C2_ILIE. */
#define BS_UART0_C2_ILIE     (1U)          /*!< Bit field size in bits for UART0_C2_ILIE. */

/*! @brief Read current value of the UART0_C2_ILIE field. */
#define BR_UART0_C2_ILIE(x)  (BME_UBFX8(HW_UART0_C2_ADDR(x), BP_UART0_C2_ILIE, BS_UART0_C2_ILIE))

/*! @brief Format value for bitfield UART0_C2_ILIE. */
#define BF_UART0_C2_ILIE(v)  ((uint8_t)((uint8_t)(v) << BP_UART0_C2_ILIE) & BM_UART0_C2_ILIE)

/*! @brief Set the ILIE field to a new value. */
#define BW_UART0_C2_ILIE(x, v) (BME_BFI8(HW_UART0_C2_ADDR(x), ((uint8_t)(v) << BP_UART0_C2_ILIE), BP_UART0_C2_ILIE, 1))
/*@}*/

/*!
 * @name Register UART0_C2, field RIE[5] (RW)
 *
 * Values:
 * - 0 - Hardware interrupts from RDRF disabled; use polling.
 * - 1 - Hardware interrupt requested when RDRF flag is 1.
 */
/*@{*/
#define BP_UART0_C2_RIE      (5U)          /*!< Bit position for UART0_C2_RIE. */
#define BM_UART0_C2_RIE      (0x20U)       /*!< Bit mask for UART0_C2_RIE. */
#define BS_UART0_C2_RIE      (1U)          /*!< Bit field size in bits for UART0_C2_RIE. */

/*! @brief Read current value of the UART0_C2_RIE field. */
#define BR_UART0_C2_RIE(x)   (BME_UBFX8(HW_UART0_C2_ADDR(x), BP_UART0_C2_RIE, BS_UART0_C2_RIE))

/*! @brief Format value for bitfield UART0_C2_RIE. */
#define BF_UART0_C2_RIE(v)   ((uint8_t)((uint8_t)(v) << BP_UART0_C2_RIE) & BM_UART0_C2_RIE)

/*! @brief Set the RIE field to a new value. */
#define BW_UART0_C2_RIE(x, v) (BME_BFI8(HW_UART0_C2_ADDR(x), ((uint8_t)(v) << BP_UART0_C2_RIE), BP_UART0_C2_RIE, 1))
/*@}*/

/*!
 * @name Register UART0_C2, field TCIE[6] (RW)
 *
 * Values:
 * - 0 - Hardware interrupts from TC disabled; use polling.
 * - 1 - Hardware interrupt requested when TC flag is 1.
 */
/*@{*/
#define BP_UART0_C2_TCIE     (6U)          /*!< Bit position for UART0_C2_TCIE. */
#define BM_UART0_C2_TCIE     (0x40U)       /*!< Bit mask for UART0_C2_TCIE. */
#define BS_UART0_C2_TCIE     (1U)          /*!< Bit field size in bits for UART0_C2_TCIE. */

/*! @brief Read current value of the UART0_C2_TCIE field. */
#define BR_UART0_C2_TCIE(x)  (BME_UBFX8(HW_UART0_C2_ADDR(x), BP_UART0_C2_TCIE, BS_UART0_C2_TCIE))

/*! @brief Format value for bitfield UART0_C2_TCIE. */
#define BF_UART0_C2_TCIE(v)  ((uint8_t)((uint8_t)(v) << BP_UART0_C2_TCIE) & BM_UART0_C2_TCIE)

/*! @brief Set the TCIE field to a new value. */
#define BW_UART0_C2_TCIE(x, v) (BME_BFI8(HW_UART0_C2_ADDR(x), ((uint8_t)(v) << BP_UART0_C2_TCIE), BP_UART0_C2_TCIE, 1))
/*@}*/

/*!
 * @name Register UART0_C2, field TIE[7] (RW)
 *
 * Values:
 * - 0 - Hardware interrupts from TDRE disabled; use polling.
 * - 1 - Hardware interrupt requested when TDRE flag is 1.
 */
/*@{*/
#define BP_UART0_C2_TIE      (7U)          /*!< Bit position for UART0_C2_TIE. */
#define BM_UART0_C2_TIE      (0x80U)       /*!< Bit mask for UART0_C2_TIE. */
#define BS_UART0_C2_TIE      (1U)          /*!< Bit field size in bits for UART0_C2_TIE. */

/*! @brief Read current value of the UART0_C2_TIE field. */
#define BR_UART0_C2_TIE(x)   (BME_UBFX8(HW_UART0_C2_ADDR(x), BP_UART0_C2_TIE, BS_UART0_C2_TIE))

/*! @brief Format value for bitfield UART0_C2_TIE. */
#define BF_UART0_C2_TIE(v)   ((uint8_t)((uint8_t)(v) << BP_UART0_C2_TIE) & BM_UART0_C2_TIE)

/*! @brief Set the TIE field to a new value. */
#define BW_UART0_C2_TIE(x, v) (BME_BFI8(HW_UART0_C2_ADDR(x), ((uint8_t)(v) << BP_UART0_C2_TIE), BP_UART0_C2_TIE, 1))
/*@}*/

/*******************************************************************************
 * HW_UART0_S1 - UART Status Register 1
 ******************************************************************************/

/*!
 * @brief HW_UART0_S1 - UART Status Register 1 (RW)
 *
 * Reset value: 0xC0U
 */
typedef union _hw_uart0_s1
{
    uint8_t U;
    struct _hw_uart0_s1_bitfields
    {
        uint8_t PF : 1;                /*!< [0] Parity Error Flag */
        uint8_t FE : 1;                /*!< [1] Framing Error Flag */
        uint8_t NF : 1;                /*!< [2] Noise Flag */
        uint8_t OR : 1;                /*!< [3] Receiver Overrun Flag */
        uint8_t IDLE : 1;              /*!< [4] Idle Line Flag */
        uint8_t RDRF : 1;              /*!< [5] Receive Data Register Full Flag */
        uint8_t TC : 1;                /*!< [6] Transmission Complete Flag */
        uint8_t TDRE : 1;              /*!< [7] Transmit Data Register Empty Flag */
    } B;
} hw_uart0_s1_t;

/*!
 * @name Constants and macros for entire UART0_S1 register
 */
/*@{*/
#define HW_UART0_S1_ADDR(x)      ((x) + 0x4U)

#define HW_UART0_S1(x)           (*(__IO hw_uart0_s1_t *) HW_UART0_S1_ADDR(x))
#define HW_UART0_S1_RD(x)        (HW_UART0_S1(x).U)
#define HW_UART0_S1_WR(x, v)     (HW_UART0_S1(x).U = (v))
#define HW_UART0_S1_SET(x, v)    (BME_OR8(HW_UART0_S1_ADDR(x), (uint8_t)(v)))
#define HW_UART0_S1_CLR(x, v)    (BME_AND8(HW_UART0_S1_ADDR(x), (uint8_t)(~(v))))
#define HW_UART0_S1_TOG(x, v)    (BME_XOR8(HW_UART0_S1_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual UART0_S1 bitfields
 */

/*!
 * @name Register UART0_S1, field PF[0] (W1C)
 *
 * PF is set at the same time as RDRF when parity is enabled (PE = 1) and the
 * parity bit in the received character does not agree with the expected parity
 * value. To clear PF, write a logic one to the PF.
 *
 * Values:
 * - 0 - No parity error.
 * - 1 - Parity error.
 */
/*@{*/
#define BP_UART0_S1_PF       (0U)          /*!< Bit position for UART0_S1_PF. */
#define BM_UART0_S1_PF       (0x01U)       /*!< Bit mask for UART0_S1_PF. */
#define BS_UART0_S1_PF       (1U)          /*!< Bit field size in bits for UART0_S1_PF. */

/*! @brief Read current value of the UART0_S1_PF field. */
#define BR_UART0_S1_PF(x)    (BME_UBFX8(HW_UART0_S1_ADDR(x), BP_UART0_S1_PF, BS_UART0_S1_PF))

/*! @brief Format value for bitfield UART0_S1_PF. */
#define BF_UART0_S1_PF(v)    ((uint8_t)((uint8_t)(v) << BP_UART0_S1_PF) & BM_UART0_S1_PF)

/*! @brief Set the PF field to a new value. */
#define BW_UART0_S1_PF(x, v) (BME_BFI8(HW_UART0_S1_ADDR(x), ((uint8_t)(v) << BP_UART0_S1_PF), BP_UART0_S1_PF, 1))
/*@}*/

/*!
 * @name Register UART0_S1, field FE[1] (W1C)
 *
 * FE is set at the same time as RDRF when the receiver detects a logic 0 where
 * a stop bit was expected. This suggests the receiver was not properly aligned
 * to a character frame. To clear FE, write a logic one to the FE flag.
 *
 * Values:
 * - 0 - No framing error detected. This does not guarantee the framing is
 *     correct.
 * - 1 - Framing error.
 */
/*@{*/
#define BP_UART0_S1_FE       (1U)          /*!< Bit position for UART0_S1_FE. */
#define BM_UART0_S1_FE       (0x02U)       /*!< Bit mask for UART0_S1_FE. */
#define BS_UART0_S1_FE       (1U)          /*!< Bit field size in bits for UART0_S1_FE. */

/*! @brief Read current value of the UART0_S1_FE field. */
#define BR_UART0_S1_FE(x)    (BME_UBFX8(HW_UART0_S1_ADDR(x), BP_UART0_S1_FE, BS_UART0_S1_FE))

/*! @brief Format value for bitfield UART0_S1_FE. */
#define BF_UART0_S1_FE(v)    ((uint8_t)((uint8_t)(v) << BP_UART0_S1_FE) & BM_UART0_S1_FE)

/*! @brief Set the FE field to a new value. */
#define BW_UART0_S1_FE(x, v) (BME_BFI8(HW_UART0_S1_ADDR(x), ((uint8_t)(v) << BP_UART0_S1_FE), BP_UART0_S1_FE, 1))
/*@}*/

/*!
 * @name Register UART0_S1, field NF[2] (W1C)
 *
 * The advanced sampling technique used in the receiver takes three samples in
 * each of the received bits. If any of these samples disagrees with the rest of
 * the samples within any bit time in the frame, the flag NF is set at the same
 * time as RDRF is set for the character. To clear NF, write logic one to the NF.
 *
 * Values:
 * - 0 - No noise detected.
 * - 1 - Noise detected in the received character in UART _D.
 */
/*@{*/
#define BP_UART0_S1_NF       (2U)          /*!< Bit position for UART0_S1_NF. */
#define BM_UART0_S1_NF       (0x04U)       /*!< Bit mask for UART0_S1_NF. */
#define BS_UART0_S1_NF       (1U)          /*!< Bit field size in bits for UART0_S1_NF. */

/*! @brief Read current value of the UART0_S1_NF field. */
#define BR_UART0_S1_NF(x)    (BME_UBFX8(HW_UART0_S1_ADDR(x), BP_UART0_S1_NF, BS_UART0_S1_NF))

/*! @brief Format value for bitfield UART0_S1_NF. */
#define BF_UART0_S1_NF(v)    ((uint8_t)((uint8_t)(v) << BP_UART0_S1_NF) & BM_UART0_S1_NF)

/*! @brief Set the NF field to a new value. */
#define BW_UART0_S1_NF(x, v) (BME_BFI8(HW_UART0_S1_ADDR(x), ((uint8_t)(v) << BP_UART0_S1_NF), BP_UART0_S1_NF, 1))
/*@}*/

/*!
 * @name Register UART0_S1, field OR[3] (W1C)
 *
 * OR is set when a new serial character is ready to be transferred to the
 * receive data buffer, but the previously received character has not been read from
 * UART _D yet. In this case, the new character, and all associated error
 * information, is lost because there is no room to move it into UART _D. To clear OR,
 * write a logic 1 to the OR flag.
 *
 * Values:
 * - 0 - No overrun.
 * - 1 - Receive overrun (new UART data lost).
 */
/*@{*/
#define BP_UART0_S1_OR       (3U)          /*!< Bit position for UART0_S1_OR. */
#define BM_UART0_S1_OR       (0x08U)       /*!< Bit mask for UART0_S1_OR. */
#define BS_UART0_S1_OR       (1U)          /*!< Bit field size in bits for UART0_S1_OR. */

/*! @brief Read current value of the UART0_S1_OR field. */
#define BR_UART0_S1_OR(x)    (BME_UBFX8(HW_UART0_S1_ADDR(x), BP_UART0_S1_OR, BS_UART0_S1_OR))

/*! @brief Format value for bitfield UART0_S1_OR. */
#define BF_UART0_S1_OR(v)    ((uint8_t)((uint8_t)(v) << BP_UART0_S1_OR) & BM_UART0_S1_OR)

/*! @brief Set the OR field to a new value. */
#define BW_UART0_S1_OR(x, v) (BME_BFI8(HW_UART0_S1_ADDR(x), ((uint8_t)(v) << BP_UART0_S1_OR), BP_UART0_S1_OR, 1))
/*@}*/

/*!
 * @name Register UART0_S1, field IDLE[4] (W1C)
 *
 * IDLE is set when the UART receive line becomes idle for a full character time
 * after a period of activity. When ILT is cleared, the receiver starts counting
 * idle bit times after the start bit. If the receive character is all 1s, these
 * bit times and the stop bits time count toward the full character time of
 * logic high, 10 to 13 bit times, needed for the receiver to detect an idle line.
 * When ILT is set, the receiver doesn't start counting idle bit times until after
 * the stop bits. The stop bits and any logic high bit times at the end of the
 * previous character do not count toward the full character time of logic high
 * needed for the receiver to detect an idle line. To clear IDLE, write logic 1 to
 * the IDLE flag. After IDLE has been cleared, it cannot become set again until
 * after a new character has been received and RDRF has been set. IDLE is set only
 * once even if the receive line remains idle for an extended period.
 *
 * Values:
 * - 0 - No idle line detected.
 * - 1 - Idle line was detected.
 */
/*@{*/
#define BP_UART0_S1_IDLE     (4U)          /*!< Bit position for UART0_S1_IDLE. */
#define BM_UART0_S1_IDLE     (0x10U)       /*!< Bit mask for UART0_S1_IDLE. */
#define BS_UART0_S1_IDLE     (1U)          /*!< Bit field size in bits for UART0_S1_IDLE. */

/*! @brief Read current value of the UART0_S1_IDLE field. */
#define BR_UART0_S1_IDLE(x)  (BME_UBFX8(HW_UART0_S1_ADDR(x), BP_UART0_S1_IDLE, BS_UART0_S1_IDLE))

/*! @brief Format value for bitfield UART0_S1_IDLE. */
#define BF_UART0_S1_IDLE(v)  ((uint8_t)((uint8_t)(v) << BP_UART0_S1_IDLE) & BM_UART0_S1_IDLE)

/*! @brief Set the IDLE field to a new value. */
#define BW_UART0_S1_IDLE(x, v) (BME_BFI8(HW_UART0_S1_ADDR(x), ((uint8_t)(v) << BP_UART0_S1_IDLE), BP_UART0_S1_IDLE, 1))
/*@}*/

/*!
 * @name Register UART0_S1, field RDRF[5] (RO)
 *
 * RDRF becomes set whenever the receive data buffer is full. To clear RDRF,
 * read the UART data register ( UART _D).
 *
 * Values:
 * - 0 - Receive data buffer empty.
 * - 1 - Receive data buffer full.
 */
/*@{*/
#define BP_UART0_S1_RDRF     (5U)          /*!< Bit position for UART0_S1_RDRF. */
#define BM_UART0_S1_RDRF     (0x20U)       /*!< Bit mask for UART0_S1_RDRF. */
#define BS_UART0_S1_RDRF     (1U)          /*!< Bit field size in bits for UART0_S1_RDRF. */

/*! @brief Read current value of the UART0_S1_RDRF field. */
#define BR_UART0_S1_RDRF(x)  (BME_UBFX8(HW_UART0_S1_ADDR(x), BP_UART0_S1_RDRF, BS_UART0_S1_RDRF))
/*@}*/

/*!
 * @name Register UART0_S1, field TC[6] (RO)
 *
 * TC is set out of reset and when TDRE is set and no data, preamble, or break
 * character is being transmitted. TC is cleared automatically by one of the
 * following: Write to the UART data register ( UART _D) to transmit new data Queue a
 * preamble by changing TE from 0 to 1 Queue a break character by writing 1 to
 * UART _C2[SBK]
 *
 * Values:
 * - 0 - Transmitter active (sending data, a preamble, or a break).
 * - 1 - Transmitter idle (transmission activity complete).
 */
/*@{*/
#define BP_UART0_S1_TC       (6U)          /*!< Bit position for UART0_S1_TC. */
#define BM_UART0_S1_TC       (0x40U)       /*!< Bit mask for UART0_S1_TC. */
#define BS_UART0_S1_TC       (1U)          /*!< Bit field size in bits for UART0_S1_TC. */

/*! @brief Read current value of the UART0_S1_TC field. */
#define BR_UART0_S1_TC(x)    (BME_UBFX8(HW_UART0_S1_ADDR(x), BP_UART0_S1_TC, BS_UART0_S1_TC))
/*@}*/

/*!
 * @name Register UART0_S1, field TDRE[7] (RO)
 *
 * TDRE is set out of reset and whenever there is room to write data to the
 * transmit data buffer. To clear TDRE, write to the UART data register ( UART _D).
 *
 * Values:
 * - 0 - Transmit data buffer full.
 * - 1 - Transmit data buffer empty.
 */
/*@{*/
#define BP_UART0_S1_TDRE     (7U)          /*!< Bit position for UART0_S1_TDRE. */
#define BM_UART0_S1_TDRE     (0x80U)       /*!< Bit mask for UART0_S1_TDRE. */
#define BS_UART0_S1_TDRE     (1U)          /*!< Bit field size in bits for UART0_S1_TDRE. */

/*! @brief Read current value of the UART0_S1_TDRE field. */
#define BR_UART0_S1_TDRE(x)  (BME_UBFX8(HW_UART0_S1_ADDR(x), BP_UART0_S1_TDRE, BS_UART0_S1_TDRE))
/*@}*/

/*******************************************************************************
 * HW_UART0_S2 - UART Status Register 2
 ******************************************************************************/

/*!
 * @brief HW_UART0_S2 - UART Status Register 2 (RW)
 *
 * Reset value: 0x00U
 *
 * This register contains one read-only status flag. When using an internal
 * oscillator in a LIN system, it is necessary to raise the break detection threshold
 * one bit time. Under the worst case timing conditions allowed in LIN, it is
 * possible that a 0x00 data character can appear to be 10.26 bit times long at a
 * slave running 14% faster than the master. This would trigger normal break
 * detection circuitry designed to detect a 10-bit break symbol. When the LBKDE bit is
 * set, framing errors are inhibited and the break detection threshold
 * increases, preventing false detection of a 0x00 data character as a LIN break symbol.
 */
typedef union _hw_uart0_s2
{
    uint8_t U;
    struct _hw_uart0_s2_bitfields
    {
        uint8_t RAF : 1;               /*!< [0] Receiver Active Flag */
        uint8_t LBKDE : 1;             /*!< [1] LIN Break Detection Enable */
        uint8_t BRK13 : 1;             /*!< [2] Break Character Generation Length */
        uint8_t RWUID : 1;             /*!< [3] Receive Wake Up Idle Detect */
        uint8_t RXINV : 1;             /*!< [4] Receive Data Inversion */
        uint8_t MSBF : 1;              /*!< [5] MSB First */
        uint8_t RXEDGIF : 1;           /*!< [6] UART _RX Pin Active Edge Interrupt Flag
                                        * */
        uint8_t LBKDIF : 1;            /*!< [7] LIN Break Detect Interrupt Flag */
    } B;
} hw_uart0_s2_t;

/*!
 * @name Constants and macros for entire UART0_S2 register
 */
/*@{*/
#define HW_UART0_S2_ADDR(x)      ((x) + 0x5U)

#define HW_UART0_S2(x)           (*(__IO hw_uart0_s2_t *) HW_UART0_S2_ADDR(x))
#define HW_UART0_S2_RD(x)        (HW_UART0_S2(x).U)
#define HW_UART0_S2_WR(x, v)     (HW_UART0_S2(x).U = (v))
#define HW_UART0_S2_SET(x, v)    (BME_OR8(HW_UART0_S2_ADDR(x), (uint8_t)(v)))
#define HW_UART0_S2_CLR(x, v)    (BME_AND8(HW_UART0_S2_ADDR(x), (uint8_t)(~(v))))
#define HW_UART0_S2_TOG(x, v)    (BME_XOR8(HW_UART0_S2_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual UART0_S2 bitfields
 */

/*!
 * @name Register UART0_S2, field RAF[0] (RO)
 *
 * RAF is set when the UART receiver detects the beginning of a valid start bit,
 * and RAF is cleared automatically when the receiver detects an idle line.
 *
 * Values:
 * - 0 - UART receiver idle waiting for a start bit.
 * - 1 - UART receiver active ( UART _RXD input not idle).
 */
/*@{*/
#define BP_UART0_S2_RAF      (0U)          /*!< Bit position for UART0_S2_RAF. */
#define BM_UART0_S2_RAF      (0x01U)       /*!< Bit mask for UART0_S2_RAF. */
#define BS_UART0_S2_RAF      (1U)          /*!< Bit field size in bits for UART0_S2_RAF. */

/*! @brief Read current value of the UART0_S2_RAF field. */
#define BR_UART0_S2_RAF(x)   (BME_UBFX8(HW_UART0_S2_ADDR(x), BP_UART0_S2_RAF, BS_UART0_S2_RAF))
/*@}*/

/*!
 * @name Register UART0_S2, field LBKDE[1] (RW)
 *
 * LBKDE selects a longer break character detection length. While LBKDE is set,
 * framing error (FE) and receive data register full (RDRF) flags are prevented
 * from setting.
 *
 * Values:
 * - 0 - Break character is detected at length 10 bit times (if M = 0, SBNS = 0)
 *     or 11 (if M = 1, SBNS = 0 or M = 0, SBNS = 1) or 12 (if M = 1, SBNS = 1
 *     or M10 = 1, SNBS = 0) or 13 (if M10 = 1, SNBS = 1).
 * - 1 - Break character is detected at length of 11 bit times (if M = 0, SBNS =
 *     0) or 12 (if M = 1, SBNS = 0 or M = 0, SBNS = 1) or 14 (if M = 1, SBNS =
 *     1 or M10 = 1, SNBS = 0) or 15 (if M10 = 1, SNBS = 1).
 */
/*@{*/
#define BP_UART0_S2_LBKDE    (1U)          /*!< Bit position for UART0_S2_LBKDE. */
#define BM_UART0_S2_LBKDE    (0x02U)       /*!< Bit mask for UART0_S2_LBKDE. */
#define BS_UART0_S2_LBKDE    (1U)          /*!< Bit field size in bits for UART0_S2_LBKDE. */

/*! @brief Read current value of the UART0_S2_LBKDE field. */
#define BR_UART0_S2_LBKDE(x) (BME_UBFX8(HW_UART0_S2_ADDR(x), BP_UART0_S2_LBKDE, BS_UART0_S2_LBKDE))

/*! @brief Format value for bitfield UART0_S2_LBKDE. */
#define BF_UART0_S2_LBKDE(v) ((uint8_t)((uint8_t)(v) << BP_UART0_S2_LBKDE) & BM_UART0_S2_LBKDE)

/*! @brief Set the LBKDE field to a new value. */
#define BW_UART0_S2_LBKDE(x, v) (BME_BFI8(HW_UART0_S2_ADDR(x), ((uint8_t)(v) << BP_UART0_S2_LBKDE), BP_UART0_S2_LBKDE, 1))
/*@}*/

/*!
 * @name Register UART0_S2, field BRK13[2] (RW)
 *
 * BRK13 selects a longer transmitted break character length. Detection of a
 * framing error is not affected by the state of this bit. This bit should only be
 * changed when the transmitter is disabled.
 *
 * Values:
 * - 0 - Break character is transmitted with length of 10 bit times (if M = 0,
 *     SBNS = 0) or 11 (if M = 1, SBNS = 0 or M = 0, SBNS = 1) or 12 (if M = 1,
 *     SBNS = 1 or M10 = 1, SNBS = 0) or 13 (if M10 = 1, SNBS = 1).
 * - 1 - Break character is transmitted with length of 13 bit times (if M = 0,
 *     SBNS = 0) or 14 (if M = 1, SBNS = 0 or M = 0, SBNS = 1) or 15 (if M = 1,
 *     SBNS = 1 or M10 = 1, SNBS = 0) or 16 (if M10 = 1, SNBS = 1).
 */
/*@{*/
#define BP_UART0_S2_BRK13    (2U)          /*!< Bit position for UART0_S2_BRK13. */
#define BM_UART0_S2_BRK13    (0x04U)       /*!< Bit mask for UART0_S2_BRK13. */
#define BS_UART0_S2_BRK13    (1U)          /*!< Bit field size in bits for UART0_S2_BRK13. */

/*! @brief Read current value of the UART0_S2_BRK13 field. */
#define BR_UART0_S2_BRK13(x) (BME_UBFX8(HW_UART0_S2_ADDR(x), BP_UART0_S2_BRK13, BS_UART0_S2_BRK13))

/*! @brief Format value for bitfield UART0_S2_BRK13. */
#define BF_UART0_S2_BRK13(v) ((uint8_t)((uint8_t)(v) << BP_UART0_S2_BRK13) & BM_UART0_S2_BRK13)

/*! @brief Set the BRK13 field to a new value. */
#define BW_UART0_S2_BRK13(x, v) (BME_BFI8(HW_UART0_S2_ADDR(x), ((uint8_t)(v) << BP_UART0_S2_BRK13), BP_UART0_S2_BRK13, 1))
/*@}*/

/*!
 * @name Register UART0_S2, field RWUID[3] (RW)
 *
 * RWUID controls whether the idle character that wakes up the receiver sets the
 * IDLE bit. This bit should only be changed when the receiver is disabled.
 *
 * Values:
 * - 0 - During receive standby state (RWU = 1), the IDLE bit does not get set
 *     upon detection of an idle character.
 * - 1 - During receive standby state (RWU = 1), the IDLE bit gets set upon
 *     detection of an idle character.
 */
/*@{*/
#define BP_UART0_S2_RWUID    (3U)          /*!< Bit position for UART0_S2_RWUID. */
#define BM_UART0_S2_RWUID    (0x08U)       /*!< Bit mask for UART0_S2_RWUID. */
#define BS_UART0_S2_RWUID    (1U)          /*!< Bit field size in bits for UART0_S2_RWUID. */

/*! @brief Read current value of the UART0_S2_RWUID field. */
#define BR_UART0_S2_RWUID(x) (BME_UBFX8(HW_UART0_S2_ADDR(x), BP_UART0_S2_RWUID, BS_UART0_S2_RWUID))

/*! @brief Format value for bitfield UART0_S2_RWUID. */
#define BF_UART0_S2_RWUID(v) ((uint8_t)((uint8_t)(v) << BP_UART0_S2_RWUID) & BM_UART0_S2_RWUID)

/*! @brief Set the RWUID field to a new value. */
#define BW_UART0_S2_RWUID(x, v) (BME_BFI8(HW_UART0_S2_ADDR(x), ((uint8_t)(v) << BP_UART0_S2_RWUID), BP_UART0_S2_RWUID, 1))
/*@}*/

/*!
 * @name Register UART0_S2, field RXINV[4] (RW)
 *
 * Setting this bit reverses the polarity of the received data input. Setting
 * RXINV inverts the UART _RXD input for all cases: data bits, start and stop bits,
 * break, and idle.
 *
 * Values:
 * - 0 - Receive data not inverted.
 * - 1 - Receive data inverted.
 */
/*@{*/
#define BP_UART0_S2_RXINV    (4U)          /*!< Bit position for UART0_S2_RXINV. */
#define BM_UART0_S2_RXINV    (0x10U)       /*!< Bit mask for UART0_S2_RXINV. */
#define BS_UART0_S2_RXINV    (1U)          /*!< Bit field size in bits for UART0_S2_RXINV. */

/*! @brief Read current value of the UART0_S2_RXINV field. */
#define BR_UART0_S2_RXINV(x) (BME_UBFX8(HW_UART0_S2_ADDR(x), BP_UART0_S2_RXINV, BS_UART0_S2_RXINV))

/*! @brief Format value for bitfield UART0_S2_RXINV. */
#define BF_UART0_S2_RXINV(v) ((uint8_t)((uint8_t)(v) << BP_UART0_S2_RXINV) & BM_UART0_S2_RXINV)

/*! @brief Set the RXINV field to a new value. */
#define BW_UART0_S2_RXINV(x, v) (BME_BFI8(HW_UART0_S2_ADDR(x), ((uint8_t)(v) << BP_UART0_S2_RXINV), BP_UART0_S2_RXINV, 1))
/*@}*/

/*!
 * @name Register UART0_S2, field MSBF[5] (RW)
 *
 * Setting this bit reverses the order of the bits that are transmitted and
 * received on the wire. This bit does not affect the polarity of the bits, the
 * location of the parity bit or the location of the start or stop bits. This bit
 * should only be changed when the transmitter and receiver are both disabled.
 *
 * Values:
 * - 0 - LSB (bit0) is the first bit that is transmitted following the start
 *     bit. Further, the first bit received after the start bit is identified as
 *     bit0.
 * - 1 - MSB (bit9, bit8, bit7 or bit6) is the first bit that is transmitted
 *     following the start bit depending on the setting of C1[M], C1[PE] and
 *     C4[M10]. Further, the first bit received after the start bit is identified as
 *     bit9, bit8, bit7 or bit6 depending on the setting of C1[M] and C1[PE].
 */
/*@{*/
#define BP_UART0_S2_MSBF     (5U)          /*!< Bit position for UART0_S2_MSBF. */
#define BM_UART0_S2_MSBF     (0x20U)       /*!< Bit mask for UART0_S2_MSBF. */
#define BS_UART0_S2_MSBF     (1U)          /*!< Bit field size in bits for UART0_S2_MSBF. */

/*! @brief Read current value of the UART0_S2_MSBF field. */
#define BR_UART0_S2_MSBF(x)  (BME_UBFX8(HW_UART0_S2_ADDR(x), BP_UART0_S2_MSBF, BS_UART0_S2_MSBF))

/*! @brief Format value for bitfield UART0_S2_MSBF. */
#define BF_UART0_S2_MSBF(v)  ((uint8_t)((uint8_t)(v) << BP_UART0_S2_MSBF) & BM_UART0_S2_MSBF)

/*! @brief Set the MSBF field to a new value. */
#define BW_UART0_S2_MSBF(x, v) (BME_BFI8(HW_UART0_S2_ADDR(x), ((uint8_t)(v) << BP_UART0_S2_MSBF), BP_UART0_S2_MSBF, 1))
/*@}*/

/*!
 * @name Register UART0_S2, field RXEDGIF[6] (RW)
 *
 * RXEDGIF is set when an active edge, falling if RXINV = 0, rising if RXINV=1,
 * on the UART _RX pin occurs. RXEDGIF is cleared by writing a 1 to it.
 *
 * Values:
 * - 0 - No active edge on the receive pin has occurred.
 * - 1 - An active edge on the receive pin has occurred.
 */
/*@{*/
#define BP_UART0_S2_RXEDGIF  (6U)          /*!< Bit position for UART0_S2_RXEDGIF. */
#define BM_UART0_S2_RXEDGIF  (0x40U)       /*!< Bit mask for UART0_S2_RXEDGIF. */
#define BS_UART0_S2_RXEDGIF  (1U)          /*!< Bit field size in bits for UART0_S2_RXEDGIF. */

/*! @brief Read current value of the UART0_S2_RXEDGIF field. */
#define BR_UART0_S2_RXEDGIF(x) (BME_UBFX8(HW_UART0_S2_ADDR(x), BP_UART0_S2_RXEDGIF, BS_UART0_S2_RXEDGIF))

/*! @brief Format value for bitfield UART0_S2_RXEDGIF. */
#define BF_UART0_S2_RXEDGIF(v) ((uint8_t)((uint8_t)(v) << BP_UART0_S2_RXEDGIF) & BM_UART0_S2_RXEDGIF)

/*! @brief Set the RXEDGIF field to a new value. */
#define BW_UART0_S2_RXEDGIF(x, v) (BME_BFI8(HW_UART0_S2_ADDR(x), ((uint8_t)(v) << BP_UART0_S2_RXEDGIF), BP_UART0_S2_RXEDGIF, 1))
/*@}*/

/*!
 * @name Register UART0_S2, field LBKDIF[7] (RW)
 *
 * LBKDIF is set when the LIN break detect circuitry is enabled and a LIN break
 * character is detected. LBKDIF is cleared by writing a 1 to it.
 *
 * Values:
 * - 0 - No LIN break character has been detected.
 * - 1 - LIN break character has been detected.
 */
/*@{*/
#define BP_UART0_S2_LBKDIF   (7U)          /*!< Bit position for UART0_S2_LBKDIF. */
#define BM_UART0_S2_LBKDIF   (0x80U)       /*!< Bit mask for UART0_S2_LBKDIF. */
#define BS_UART0_S2_LBKDIF   (1U)          /*!< Bit field size in bits for UART0_S2_LBKDIF. */

/*! @brief Read current value of the UART0_S2_LBKDIF field. */
#define BR_UART0_S2_LBKDIF(x) (BME_UBFX8(HW_UART0_S2_ADDR(x), BP_UART0_S2_LBKDIF, BS_UART0_S2_LBKDIF))

/*! @brief Format value for bitfield UART0_S2_LBKDIF. */
#define BF_UART0_S2_LBKDIF(v) ((uint8_t)((uint8_t)(v) << BP_UART0_S2_LBKDIF) & BM_UART0_S2_LBKDIF)

/*! @brief Set the LBKDIF field to a new value. */
#define BW_UART0_S2_LBKDIF(x, v) (BME_BFI8(HW_UART0_S2_ADDR(x), ((uint8_t)(v) << BP_UART0_S2_LBKDIF), BP_UART0_S2_LBKDIF, 1))
/*@}*/

/*******************************************************************************
 * HW_UART0_C3 - UART Control Register 3
 ******************************************************************************/

/*!
 * @brief HW_UART0_C3 - UART Control Register 3 (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_uart0_c3
{
    uint8_t U;
    struct _hw_uart0_c3_bitfields
    {
        uint8_t PEIE : 1;              /*!< [0] Parity Error Interrupt Enable */
        uint8_t FEIE : 1;              /*!< [1] Framing Error Interrupt Enable */
        uint8_t NEIE : 1;              /*!< [2] Noise Error Interrupt Enable */
        uint8_t ORIE : 1;              /*!< [3] Overrun Interrupt Enable */
        uint8_t TXINV : 1;             /*!< [4] Transmit Data Inversion */
        uint8_t TXDIR : 1;             /*!< [5] UART _TX Pin Direction in Single-Wire
                                        * Mode */
        uint8_t R9T8 : 1;              /*!< [6] Receive Bit 9 / Transmit Bit 8 */
        uint8_t R8T9 : 1;              /*!< [7] Receive Bit 8 / Transmit Bit 9 */
    } B;
} hw_uart0_c3_t;

/*!
 * @name Constants and macros for entire UART0_C3 register
 */
/*@{*/
#define HW_UART0_C3_ADDR(x)      ((x) + 0x6U)

#define HW_UART0_C3(x)           (*(__IO hw_uart0_c3_t *) HW_UART0_C3_ADDR(x))
#define HW_UART0_C3_RD(x)        (HW_UART0_C3(x).U)
#define HW_UART0_C3_WR(x, v)     (HW_UART0_C3(x).U = (v))
#define HW_UART0_C3_SET(x, v)    (BME_OR8(HW_UART0_C3_ADDR(x), (uint8_t)(v)))
#define HW_UART0_C3_CLR(x, v)    (BME_AND8(HW_UART0_C3_ADDR(x), (uint8_t)(~(v))))
#define HW_UART0_C3_TOG(x, v)    (BME_XOR8(HW_UART0_C3_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual UART0_C3 bitfields
 */

/*!
 * @name Register UART0_C3, field PEIE[0] (RW)
 *
 * This bit enables the parity error flag (PF) to generate hardware interrupt
 * requests.
 *
 * Values:
 * - 0 - PF interrupts disabled; use polling).
 * - 1 - Hardware interrupt requested when PF is set.
 */
/*@{*/
#define BP_UART0_C3_PEIE     (0U)          /*!< Bit position for UART0_C3_PEIE. */
#define BM_UART0_C3_PEIE     (0x01U)       /*!< Bit mask for UART0_C3_PEIE. */
#define BS_UART0_C3_PEIE     (1U)          /*!< Bit field size in bits for UART0_C3_PEIE. */

/*! @brief Read current value of the UART0_C3_PEIE field. */
#define BR_UART0_C3_PEIE(x)  (BME_UBFX8(HW_UART0_C3_ADDR(x), BP_UART0_C3_PEIE, BS_UART0_C3_PEIE))

/*! @brief Format value for bitfield UART0_C3_PEIE. */
#define BF_UART0_C3_PEIE(v)  ((uint8_t)((uint8_t)(v) << BP_UART0_C3_PEIE) & BM_UART0_C3_PEIE)

/*! @brief Set the PEIE field to a new value. */
#define BW_UART0_C3_PEIE(x, v) (BME_BFI8(HW_UART0_C3_ADDR(x), ((uint8_t)(v) << BP_UART0_C3_PEIE), BP_UART0_C3_PEIE, 1))
/*@}*/

/*!
 * @name Register UART0_C3, field FEIE[1] (RW)
 *
 * This bit enables the framing error flag (FE) to generate hardware interrupt
 * requests.
 *
 * Values:
 * - 0 - FE interrupts disabled; use polling.
 * - 1 - Hardware interrupt requested when FE is set.
 */
/*@{*/
#define BP_UART0_C3_FEIE     (1U)          /*!< Bit position for UART0_C3_FEIE. */
#define BM_UART0_C3_FEIE     (0x02U)       /*!< Bit mask for UART0_C3_FEIE. */
#define BS_UART0_C3_FEIE     (1U)          /*!< Bit field size in bits for UART0_C3_FEIE. */

/*! @brief Read current value of the UART0_C3_FEIE field. */
#define BR_UART0_C3_FEIE(x)  (BME_UBFX8(HW_UART0_C3_ADDR(x), BP_UART0_C3_FEIE, BS_UART0_C3_FEIE))

/*! @brief Format value for bitfield UART0_C3_FEIE. */
#define BF_UART0_C3_FEIE(v)  ((uint8_t)((uint8_t)(v) << BP_UART0_C3_FEIE) & BM_UART0_C3_FEIE)

/*! @brief Set the FEIE field to a new value. */
#define BW_UART0_C3_FEIE(x, v) (BME_BFI8(HW_UART0_C3_ADDR(x), ((uint8_t)(v) << BP_UART0_C3_FEIE), BP_UART0_C3_FEIE, 1))
/*@}*/

/*!
 * @name Register UART0_C3, field NEIE[2] (RW)
 *
 * This bit enables the noise flag (NF) to generate hardware interrupt requests.
 *
 * Values:
 * - 0 - NF interrupts disabled; use polling.
 * - 1 - Hardware interrupt requested when NF is set.
 */
/*@{*/
#define BP_UART0_C3_NEIE     (2U)          /*!< Bit position for UART0_C3_NEIE. */
#define BM_UART0_C3_NEIE     (0x04U)       /*!< Bit mask for UART0_C3_NEIE. */
#define BS_UART0_C3_NEIE     (1U)          /*!< Bit field size in bits for UART0_C3_NEIE. */

/*! @brief Read current value of the UART0_C3_NEIE field. */
#define BR_UART0_C3_NEIE(x)  (BME_UBFX8(HW_UART0_C3_ADDR(x), BP_UART0_C3_NEIE, BS_UART0_C3_NEIE))

/*! @brief Format value for bitfield UART0_C3_NEIE. */
#define BF_UART0_C3_NEIE(v)  ((uint8_t)((uint8_t)(v) << BP_UART0_C3_NEIE) & BM_UART0_C3_NEIE)

/*! @brief Set the NEIE field to a new value. */
#define BW_UART0_C3_NEIE(x, v) (BME_BFI8(HW_UART0_C3_ADDR(x), ((uint8_t)(v) << BP_UART0_C3_NEIE), BP_UART0_C3_NEIE, 1))
/*@}*/

/*!
 * @name Register UART0_C3, field ORIE[3] (RW)
 *
 * This bit enables the overrun flag (OR) to generate hardware interrupt
 * requests.
 *
 * Values:
 * - 0 - OR interrupts disabled; use polling.
 * - 1 - Hardware interrupt requested when OR is set.
 */
/*@{*/
#define BP_UART0_C3_ORIE     (3U)          /*!< Bit position for UART0_C3_ORIE. */
#define BM_UART0_C3_ORIE     (0x08U)       /*!< Bit mask for UART0_C3_ORIE. */
#define BS_UART0_C3_ORIE     (1U)          /*!< Bit field size in bits for UART0_C3_ORIE. */

/*! @brief Read current value of the UART0_C3_ORIE field. */
#define BR_UART0_C3_ORIE(x)  (BME_UBFX8(HW_UART0_C3_ADDR(x), BP_UART0_C3_ORIE, BS_UART0_C3_ORIE))

/*! @brief Format value for bitfield UART0_C3_ORIE. */
#define BF_UART0_C3_ORIE(v)  ((uint8_t)((uint8_t)(v) << BP_UART0_C3_ORIE) & BM_UART0_C3_ORIE)

/*! @brief Set the ORIE field to a new value. */
#define BW_UART0_C3_ORIE(x, v) (BME_BFI8(HW_UART0_C3_ADDR(x), ((uint8_t)(v) << BP_UART0_C3_ORIE), BP_UART0_C3_ORIE, 1))
/*@}*/

/*!
 * @name Register UART0_C3, field TXINV[4] (RW)
 *
 * Setting this bit reverses the polarity of the transmitted data output.
 * Setting TXINV inverts the UART _TXD output for all cases: data bits, start and stop
 * bits, break, and idle.
 *
 * Values:
 * - 0 - Transmit data not inverted.
 * - 1 - Transmit data inverted.
 */
/*@{*/
#define BP_UART0_C3_TXINV    (4U)          /*!< Bit position for UART0_C3_TXINV. */
#define BM_UART0_C3_TXINV    (0x10U)       /*!< Bit mask for UART0_C3_TXINV. */
#define BS_UART0_C3_TXINV    (1U)          /*!< Bit field size in bits for UART0_C3_TXINV. */

/*! @brief Read current value of the UART0_C3_TXINV field. */
#define BR_UART0_C3_TXINV(x) (BME_UBFX8(HW_UART0_C3_ADDR(x), BP_UART0_C3_TXINV, BS_UART0_C3_TXINV))

/*! @brief Format value for bitfield UART0_C3_TXINV. */
#define BF_UART0_C3_TXINV(v) ((uint8_t)((uint8_t)(v) << BP_UART0_C3_TXINV) & BM_UART0_C3_TXINV)

/*! @brief Set the TXINV field to a new value. */
#define BW_UART0_C3_TXINV(x, v) (BME_BFI8(HW_UART0_C3_ADDR(x), ((uint8_t)(v) << BP_UART0_C3_TXINV), BP_UART0_C3_TXINV, 1))
/*@}*/

/*!
 * @name Register UART0_C3, field TXDIR[5] (RW)
 *
 * When the is configured for single-wire half-duplex operation (LOOPS = RSRC =
 * 1), this bit determines the direction of data at the UART_TXD pin. When
 * clearing TXDIR, the transmitter will finish receiving the current character (if any)
 * before the receiver starts receiving data from the UART_TXD pin.
 *
 * Values:
 * - 0 - UART _TXD pin is an input in single-wire mode.
 * - 1 - UART _TXD pin is an output in single-wire mode.
 */
/*@{*/
#define BP_UART0_C3_TXDIR    (5U)          /*!< Bit position for UART0_C3_TXDIR. */
#define BM_UART0_C3_TXDIR    (0x20U)       /*!< Bit mask for UART0_C3_TXDIR. */
#define BS_UART0_C3_TXDIR    (1U)          /*!< Bit field size in bits for UART0_C3_TXDIR. */

/*! @brief Read current value of the UART0_C3_TXDIR field. */
#define BR_UART0_C3_TXDIR(x) (BME_UBFX8(HW_UART0_C3_ADDR(x), BP_UART0_C3_TXDIR, BS_UART0_C3_TXDIR))

/*! @brief Format value for bitfield UART0_C3_TXDIR. */
#define BF_UART0_C3_TXDIR(v) ((uint8_t)((uint8_t)(v) << BP_UART0_C3_TXDIR) & BM_UART0_C3_TXDIR)

/*! @brief Set the TXDIR field to a new value. */
#define BW_UART0_C3_TXDIR(x, v) (BME_BFI8(HW_UART0_C3_ADDR(x), ((uint8_t)(v) << BP_UART0_C3_TXDIR), BP_UART0_C3_TXDIR, 1))
/*@}*/

/*!
 * @name Register UART0_C3, field R9T8[6] (RW)
 *
 * When the UART is configured for 9-bit data (M = 1), T8 may be thought of as a
 * ninth transmit data bit to the left of the msb of the data in the UART_D
 * register. When writing 9-bit data, the entire 9-bit value is transferred to the
 * UART transmit buffer after UART_D is written so T8 should be written, if it
 * needs to change from its previous value, before UART_D is written. If T8 does not
 * need to change in the new value, such as when it is used to generate mark or
 * space parity, it need not be written each time UART_D is written. When the UART
 * is configured for 10-bit data (M10 = 1), R9 can be thought of as a tenth
 * receive data bit. When reading 10-bit data, read R9 and R8 before reading UART_D
 * because reading UART_D completes automatic flag clearing sequences that could
 * allow R8, R9 and UART_D to be overwritten with new data.
 */
/*@{*/
#define BP_UART0_C3_R9T8     (6U)          /*!< Bit position for UART0_C3_R9T8. */
#define BM_UART0_C3_R9T8     (0x40U)       /*!< Bit mask for UART0_C3_R9T8. */
#define BS_UART0_C3_R9T8     (1U)          /*!< Bit field size in bits for UART0_C3_R9T8. */

/*! @brief Read current value of the UART0_C3_R9T8 field. */
#define BR_UART0_C3_R9T8(x)  (BME_UBFX8(HW_UART0_C3_ADDR(x), BP_UART0_C3_R9T8, BS_UART0_C3_R9T8))

/*! @brief Format value for bitfield UART0_C3_R9T8. */
#define BF_UART0_C3_R9T8(v)  ((uint8_t)((uint8_t)(v) << BP_UART0_C3_R9T8) & BM_UART0_C3_R9T8)

/*! @brief Set the R9T8 field to a new value. */
#define BW_UART0_C3_R9T8(x, v) (BME_BFI8(HW_UART0_C3_ADDR(x), ((uint8_t)(v) << BP_UART0_C3_R9T8), BP_UART0_C3_R9T8, 1))
/*@}*/

/*!
 * @name Register UART0_C3, field R8T9[7] (RW)
 *
 * When the UART is configured for 9-bit data (M = 1), R8 can be thought of as a
 * ninth receive data bit to the left of the msb of the buffered data in the
 * UART_D register. When reading 9-bit data, read R8 before reading UART_D because
 * reading UART_D completes automatic flag clearing sequences that could allow R8
 * and UART_D to be overwritten with new data. When the UART is configured for
 * 10-bit data (M10 = 1), T9 may be thought of as a tenth transmit data bit. When
 * writing 10-bit data, the entire 10-bit value is transferred to the UART
 * transmit buffer when UART_D is written so T9 and T8 should be written, if it needs to
 * change from its previous value, before UART_D is written. If T9 and T8 do not
 * need to change in the new value, such as when it is used to generate mark or
 * space parity, they need not be written each time UART_D is written.
 */
/*@{*/
#define BP_UART0_C3_R8T9     (7U)          /*!< Bit position for UART0_C3_R8T9. */
#define BM_UART0_C3_R8T9     (0x80U)       /*!< Bit mask for UART0_C3_R8T9. */
#define BS_UART0_C3_R8T9     (1U)          /*!< Bit field size in bits for UART0_C3_R8T9. */

/*! @brief Read current value of the UART0_C3_R8T9 field. */
#define BR_UART0_C3_R8T9(x)  (BME_UBFX8(HW_UART0_C3_ADDR(x), BP_UART0_C3_R8T9, BS_UART0_C3_R8T9))

/*! @brief Format value for bitfield UART0_C3_R8T9. */
#define BF_UART0_C3_R8T9(v)  ((uint8_t)((uint8_t)(v) << BP_UART0_C3_R8T9) & BM_UART0_C3_R8T9)

/*! @brief Set the R8T9 field to a new value. */
#define BW_UART0_C3_R8T9(x, v) (BME_BFI8(HW_UART0_C3_ADDR(x), ((uint8_t)(v) << BP_UART0_C3_R8T9), BP_UART0_C3_R8T9, 1))
/*@}*/

/*******************************************************************************
 * HW_UART0_D - UART Data Register
 ******************************************************************************/

/*!
 * @brief HW_UART0_D - UART Data Register (RW)
 *
 * Reset value: 0x00U
 *
 * This register is actually two separate registers. Reads return the contents
 * of the read-only receive data buffer and writes go to the write-only transmit
 * data buffer. Reads and writes of this register are also involved in the
 * automatic flag clearing mechanisms for some of the UART status flags.
 */
typedef union _hw_uart0_d
{
    uint8_t U;
    struct _hw_uart0_d_bitfields
    {
        uint8_t R0T0 : 1;              /*!< [0]  */
        uint8_t R1T1 : 1;              /*!< [1]  */
        uint8_t R2T2 : 1;              /*!< [2]  */
        uint8_t R3T3 : 1;              /*!< [3]  */
        uint8_t R4T4 : 1;              /*!< [4]  */
        uint8_t R5T5 : 1;              /*!< [5]  */
        uint8_t R6T6 : 1;              /*!< [6]  */
        uint8_t R7T7 : 1;              /*!< [7]  */
    } B;
} hw_uart0_d_t;

/*!
 * @name Constants and macros for entire UART0_D register
 */
/*@{*/
#define HW_UART0_D_ADDR(x)       ((x) + 0x7U)

#define HW_UART0_D(x)            (*(__IO hw_uart0_d_t *) HW_UART0_D_ADDR(x))
#define HW_UART0_D_RD(x)         (HW_UART0_D(x).U)
#define HW_UART0_D_WR(x, v)      (HW_UART0_D(x).U = (v))
#define HW_UART0_D_SET(x, v)     (BME_OR8(HW_UART0_D_ADDR(x), (uint8_t)(v)))
#define HW_UART0_D_CLR(x, v)     (BME_AND8(HW_UART0_D_ADDR(x), (uint8_t)(~(v))))
#define HW_UART0_D_TOG(x, v)     (BME_XOR8(HW_UART0_D_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual UART0_D bitfields
 */

/*!
 * @name Register UART0_D, field R0T0[0] (RW)
 *
 * Read receive data buffer 0 or write transmit data buffer 0.
 */
/*@{*/
#define BP_UART0_D_R0T0      (0U)          /*!< Bit position for UART0_D_R0T0. */
#define BM_UART0_D_R0T0      (0x01U)       /*!< Bit mask for UART0_D_R0T0. */
#define BS_UART0_D_R0T0      (1U)          /*!< Bit field size in bits for UART0_D_R0T0. */

/*! @brief Read current value of the UART0_D_R0T0 field. */
#define BR_UART0_D_R0T0(x)   (BME_UBFX8(HW_UART0_D_ADDR(x), BP_UART0_D_R0T0, BS_UART0_D_R0T0))

/*! @brief Format value for bitfield UART0_D_R0T0. */
#define BF_UART0_D_R0T0(v)   ((uint8_t)((uint8_t)(v) << BP_UART0_D_R0T0) & BM_UART0_D_R0T0)

/*! @brief Set the R0T0 field to a new value. */
#define BW_UART0_D_R0T0(x, v) (BME_BFI8(HW_UART0_D_ADDR(x), ((uint8_t)(v) << BP_UART0_D_R0T0), BP_UART0_D_R0T0, 1))
/*@}*/

/*!
 * @name Register UART0_D, field R1T1[1] (RW)
 *
 * Read receive data buffer 1 or write transmit data buffer 1.
 */
/*@{*/
#define BP_UART0_D_R1T1      (1U)          /*!< Bit position for UART0_D_R1T1. */
#define BM_UART0_D_R1T1      (0x02U)       /*!< Bit mask for UART0_D_R1T1. */
#define BS_UART0_D_R1T1      (1U)          /*!< Bit field size in bits for UART0_D_R1T1. */

/*! @brief Read current value of the UART0_D_R1T1 field. */
#define BR_UART0_D_R1T1(x)   (BME_UBFX8(HW_UART0_D_ADDR(x), BP_UART0_D_R1T1, BS_UART0_D_R1T1))

/*! @brief Format value for bitfield UART0_D_R1T1. */
#define BF_UART0_D_R1T1(v)   ((uint8_t)((uint8_t)(v) << BP_UART0_D_R1T1) & BM_UART0_D_R1T1)

/*! @brief Set the R1T1 field to a new value. */
#define BW_UART0_D_R1T1(x, v) (BME_BFI8(HW_UART0_D_ADDR(x), ((uint8_t)(v) << BP_UART0_D_R1T1), BP_UART0_D_R1T1, 1))
/*@}*/

/*!
 * @name Register UART0_D, field R2T2[2] (RW)
 *
 * Read receive data buffer 2 or write transmit data buffer 2.
 */
/*@{*/
#define BP_UART0_D_R2T2      (2U)          /*!< Bit position for UART0_D_R2T2. */
#define BM_UART0_D_R2T2      (0x04U)       /*!< Bit mask for UART0_D_R2T2. */
#define BS_UART0_D_R2T2      (1U)          /*!< Bit field size in bits for UART0_D_R2T2. */

/*! @brief Read current value of the UART0_D_R2T2 field. */
#define BR_UART0_D_R2T2(x)   (BME_UBFX8(HW_UART0_D_ADDR(x), BP_UART0_D_R2T2, BS_UART0_D_R2T2))

/*! @brief Format value for bitfield UART0_D_R2T2. */
#define BF_UART0_D_R2T2(v)   ((uint8_t)((uint8_t)(v) << BP_UART0_D_R2T2) & BM_UART0_D_R2T2)

/*! @brief Set the R2T2 field to a new value. */
#define BW_UART0_D_R2T2(x, v) (BME_BFI8(HW_UART0_D_ADDR(x), ((uint8_t)(v) << BP_UART0_D_R2T2), BP_UART0_D_R2T2, 1))
/*@}*/

/*!
 * @name Register UART0_D, field R3T3[3] (RW)
 *
 * Read receive data buffer 3 or write transmit data buffer 3.
 */
/*@{*/
#define BP_UART0_D_R3T3      (3U)          /*!< Bit position for UART0_D_R3T3. */
#define BM_UART0_D_R3T3      (0x08U)       /*!< Bit mask for UART0_D_R3T3. */
#define BS_UART0_D_R3T3      (1U)          /*!< Bit field size in bits for UART0_D_R3T3. */

/*! @brief Read current value of the UART0_D_R3T3 field. */
#define BR_UART0_D_R3T3(x)   (BME_UBFX8(HW_UART0_D_ADDR(x), BP_UART0_D_R3T3, BS_UART0_D_R3T3))

/*! @brief Format value for bitfield UART0_D_R3T3. */
#define BF_UART0_D_R3T3(v)   ((uint8_t)((uint8_t)(v) << BP_UART0_D_R3T3) & BM_UART0_D_R3T3)

/*! @brief Set the R3T3 field to a new value. */
#define BW_UART0_D_R3T3(x, v) (BME_BFI8(HW_UART0_D_ADDR(x), ((uint8_t)(v) << BP_UART0_D_R3T3), BP_UART0_D_R3T3, 1))
/*@}*/

/*!
 * @name Register UART0_D, field R4T4[4] (RW)
 *
 * Read receive data buffer 4 or write transmit data buffer 4.
 */
/*@{*/
#define BP_UART0_D_R4T4      (4U)          /*!< Bit position for UART0_D_R4T4. */
#define BM_UART0_D_R4T4      (0x10U)       /*!< Bit mask for UART0_D_R4T4. */
#define BS_UART0_D_R4T4      (1U)          /*!< Bit field size in bits for UART0_D_R4T4. */

/*! @brief Read current value of the UART0_D_R4T4 field. */
#define BR_UART0_D_R4T4(x)   (BME_UBFX8(HW_UART0_D_ADDR(x), BP_UART0_D_R4T4, BS_UART0_D_R4T4))

/*! @brief Format value for bitfield UART0_D_R4T4. */
#define BF_UART0_D_R4T4(v)   ((uint8_t)((uint8_t)(v) << BP_UART0_D_R4T4) & BM_UART0_D_R4T4)

/*! @brief Set the R4T4 field to a new value. */
#define BW_UART0_D_R4T4(x, v) (BME_BFI8(HW_UART0_D_ADDR(x), ((uint8_t)(v) << BP_UART0_D_R4T4), BP_UART0_D_R4T4, 1))
/*@}*/

/*!
 * @name Register UART0_D, field R5T5[5] (RW)
 *
 * Read receive data buffer 5 or write transmit data buffer 5.
 */
/*@{*/
#define BP_UART0_D_R5T5      (5U)          /*!< Bit position for UART0_D_R5T5. */
#define BM_UART0_D_R5T5      (0x20U)       /*!< Bit mask for UART0_D_R5T5. */
#define BS_UART0_D_R5T5      (1U)          /*!< Bit field size in bits for UART0_D_R5T5. */

/*! @brief Read current value of the UART0_D_R5T5 field. */
#define BR_UART0_D_R5T5(x)   (BME_UBFX8(HW_UART0_D_ADDR(x), BP_UART0_D_R5T5, BS_UART0_D_R5T5))

/*! @brief Format value for bitfield UART0_D_R5T5. */
#define BF_UART0_D_R5T5(v)   ((uint8_t)((uint8_t)(v) << BP_UART0_D_R5T5) & BM_UART0_D_R5T5)

/*! @brief Set the R5T5 field to a new value. */
#define BW_UART0_D_R5T5(x, v) (BME_BFI8(HW_UART0_D_ADDR(x), ((uint8_t)(v) << BP_UART0_D_R5T5), BP_UART0_D_R5T5, 1))
/*@}*/

/*!
 * @name Register UART0_D, field R6T6[6] (RW)
 *
 * Read receive data buffer 6 or write transmit data buffer 6.
 */
/*@{*/
#define BP_UART0_D_R6T6      (6U)          /*!< Bit position for UART0_D_R6T6. */
#define BM_UART0_D_R6T6      (0x40U)       /*!< Bit mask for UART0_D_R6T6. */
#define BS_UART0_D_R6T6      (1U)          /*!< Bit field size in bits for UART0_D_R6T6. */

/*! @brief Read current value of the UART0_D_R6T6 field. */
#define BR_UART0_D_R6T6(x)   (BME_UBFX8(HW_UART0_D_ADDR(x), BP_UART0_D_R6T6, BS_UART0_D_R6T6))

/*! @brief Format value for bitfield UART0_D_R6T6. */
#define BF_UART0_D_R6T6(v)   ((uint8_t)((uint8_t)(v) << BP_UART0_D_R6T6) & BM_UART0_D_R6T6)

/*! @brief Set the R6T6 field to a new value. */
#define BW_UART0_D_R6T6(x, v) (BME_BFI8(HW_UART0_D_ADDR(x), ((uint8_t)(v) << BP_UART0_D_R6T6), BP_UART0_D_R6T6, 1))
/*@}*/

/*!
 * @name Register UART0_D, field R7T7[7] (RW)
 *
 * Read receive data buffer 7 or write transmit data buffer 7.
 */
/*@{*/
#define BP_UART0_D_R7T7      (7U)          /*!< Bit position for UART0_D_R7T7. */
#define BM_UART0_D_R7T7      (0x80U)       /*!< Bit mask for UART0_D_R7T7. */
#define BS_UART0_D_R7T7      (1U)          /*!< Bit field size in bits for UART0_D_R7T7. */

/*! @brief Read current value of the UART0_D_R7T7 field. */
#define BR_UART0_D_R7T7(x)   (BME_UBFX8(HW_UART0_D_ADDR(x), BP_UART0_D_R7T7, BS_UART0_D_R7T7))

/*! @brief Format value for bitfield UART0_D_R7T7. */
#define BF_UART0_D_R7T7(v)   ((uint8_t)((uint8_t)(v) << BP_UART0_D_R7T7) & BM_UART0_D_R7T7)

/*! @brief Set the R7T7 field to a new value. */
#define BW_UART0_D_R7T7(x, v) (BME_BFI8(HW_UART0_D_ADDR(x), ((uint8_t)(v) << BP_UART0_D_R7T7), BP_UART0_D_R7T7, 1))
/*@}*/

/*******************************************************************************
 * HW_UART0_MA1 - UART Match Address Registers 1
 ******************************************************************************/

/*!
 * @brief HW_UART0_MA1 - UART Match Address Registers 1 (RW)
 *
 * Reset value: 0x00U
 *
 * The MA1 and MA2 registers are compared to input data addresses when the most
 * significant bit is set and the associated C4[MAEN] bit is set. If a match
 * occurs, the following data is transferred to the data register. If a match fails,
 * the following data is discarded. Software should only write a MA register when
 * the associated C4[MAEN] bit is clear.
 */
typedef union _hw_uart0_ma1
{
    uint8_t U;
    struct _hw_uart0_ma1_bitfields
    {
        uint8_t MA : 8;                /*!< [7:0] Match Address */
    } B;
} hw_uart0_ma1_t;

/*!
 * @name Constants and macros for entire UART0_MA1 register
 */
/*@{*/
#define HW_UART0_MA1_ADDR(x)     ((x) + 0x8U)

#define HW_UART0_MA1(x)          (*(__IO hw_uart0_ma1_t *) HW_UART0_MA1_ADDR(x))
#define HW_UART0_MA1_RD(x)       (HW_UART0_MA1(x).U)
#define HW_UART0_MA1_WR(x, v)    (HW_UART0_MA1(x).U = (v))
#define HW_UART0_MA1_SET(x, v)   (BME_OR8(HW_UART0_MA1_ADDR(x), (uint8_t)(v)))
#define HW_UART0_MA1_CLR(x, v)   (BME_AND8(HW_UART0_MA1_ADDR(x), (uint8_t)(~(v))))
#define HW_UART0_MA1_TOG(x, v)   (BME_XOR8(HW_UART0_MA1_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual UART0_MA1 bitfields
 */

/*!
 * @name Register UART0_MA1, field MA[7:0] (RW)
 */
/*@{*/
#define BP_UART0_MA1_MA      (0U)          /*!< Bit position for UART0_MA1_MA. */
#define BM_UART0_MA1_MA      (0xFFU)       /*!< Bit mask for UART0_MA1_MA. */
#define BS_UART0_MA1_MA      (8U)          /*!< Bit field size in bits for UART0_MA1_MA. */

/*! @brief Read current value of the UART0_MA1_MA field. */
#define BR_UART0_MA1_MA(x)   (HW_UART0_MA1(x).U)

/*! @brief Format value for bitfield UART0_MA1_MA. */
#define BF_UART0_MA1_MA(v)   ((uint8_t)((uint8_t)(v) << BP_UART0_MA1_MA) & BM_UART0_MA1_MA)

/*! @brief Set the MA field to a new value. */
#define BW_UART0_MA1_MA(x, v) (HW_UART0_MA1_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_UART0_MA2 - UART Match Address Registers 2
 ******************************************************************************/

/*!
 * @brief HW_UART0_MA2 - UART Match Address Registers 2 (RW)
 *
 * Reset value: 0x00U
 *
 * The MA1 and MA2 registers are compared to input data addresses when the most
 * significant bit is set and the associated C4[MAEN] bit is set. If a match
 * occurs, the following data is transferred to the data register. If a match fails,
 * the following data is discarded. Software should only write a MA register when
 * the associated C4[MAEN] bit is clear.
 */
typedef union _hw_uart0_ma2
{
    uint8_t U;
    struct _hw_uart0_ma2_bitfields
    {
        uint8_t MA : 8;                /*!< [7:0] Match Address */
    } B;
} hw_uart0_ma2_t;

/*!
 * @name Constants and macros for entire UART0_MA2 register
 */
/*@{*/
#define HW_UART0_MA2_ADDR(x)     ((x) + 0x9U)

#define HW_UART0_MA2(x)          (*(__IO hw_uart0_ma2_t *) HW_UART0_MA2_ADDR(x))
#define HW_UART0_MA2_RD(x)       (HW_UART0_MA2(x).U)
#define HW_UART0_MA2_WR(x, v)    (HW_UART0_MA2(x).U = (v))
#define HW_UART0_MA2_SET(x, v)   (BME_OR8(HW_UART0_MA2_ADDR(x), (uint8_t)(v)))
#define HW_UART0_MA2_CLR(x, v)   (BME_AND8(HW_UART0_MA2_ADDR(x), (uint8_t)(~(v))))
#define HW_UART0_MA2_TOG(x, v)   (BME_XOR8(HW_UART0_MA2_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual UART0_MA2 bitfields
 */

/*!
 * @name Register UART0_MA2, field MA[7:0] (RW)
 */
/*@{*/
#define BP_UART0_MA2_MA      (0U)          /*!< Bit position for UART0_MA2_MA. */
#define BM_UART0_MA2_MA      (0xFFU)       /*!< Bit mask for UART0_MA2_MA. */
#define BS_UART0_MA2_MA      (8U)          /*!< Bit field size in bits for UART0_MA2_MA. */

/*! @brief Read current value of the UART0_MA2_MA field. */
#define BR_UART0_MA2_MA(x)   (HW_UART0_MA2(x).U)

/*! @brief Format value for bitfield UART0_MA2_MA. */
#define BF_UART0_MA2_MA(v)   ((uint8_t)((uint8_t)(v) << BP_UART0_MA2_MA) & BM_UART0_MA2_MA)

/*! @brief Set the MA field to a new value. */
#define BW_UART0_MA2_MA(x, v) (HW_UART0_MA2_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_UART0_C4 - UART Control Register 4
 ******************************************************************************/

/*!
 * @brief HW_UART0_C4 - UART Control Register 4 (RW)
 *
 * Reset value: 0x0FU
 */
typedef union _hw_uart0_c4
{
    uint8_t U;
    struct _hw_uart0_c4_bitfields
    {
        uint8_t OSR : 5;               /*!< [4:0] Over Sampling Ratio */
        uint8_t M10 : 1;               /*!< [5] 10-bit Mode select */
        uint8_t MAEN2 : 1;             /*!< [6] Match Address Mode Enable 2 */
        uint8_t MAEN1 : 1;             /*!< [7] Match Address Mode Enable 1 */
    } B;
} hw_uart0_c4_t;

/*!
 * @name Constants and macros for entire UART0_C4 register
 */
/*@{*/
#define HW_UART0_C4_ADDR(x)      ((x) + 0xAU)

#define HW_UART0_C4(x)           (*(__IO hw_uart0_c4_t *) HW_UART0_C4_ADDR(x))
#define HW_UART0_C4_RD(x)        (HW_UART0_C4(x).U)
#define HW_UART0_C4_WR(x, v)     (HW_UART0_C4(x).U = (v))
#define HW_UART0_C4_SET(x, v)    (BME_OR8(HW_UART0_C4_ADDR(x), (uint8_t)(v)))
#define HW_UART0_C4_CLR(x, v)    (BME_AND8(HW_UART0_C4_ADDR(x), (uint8_t)(~(v))))
#define HW_UART0_C4_TOG(x, v)    (BME_XOR8(HW_UART0_C4_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual UART0_C4 bitfields
 */

/*!
 * @name Register UART0_C4, field OSR[4:0] (RW)
 *
 * This field configures the oversampling ratio for the receiver between 4x
 * (00011) and 32x (11111). Writing an invalid oversampling ratio will default to an
 * oversampling ratio of 16 (01111). This field should only be changed when the
 * transmitter and receiver are both disabled.
 */
/*@{*/
#define BP_UART0_C4_OSR      (0U)          /*!< Bit position for UART0_C4_OSR. */
#define BM_UART0_C4_OSR      (0x1FU)       /*!< Bit mask for UART0_C4_OSR. */
#define BS_UART0_C4_OSR      (5U)          /*!< Bit field size in bits for UART0_C4_OSR. */

/*! @brief Read current value of the UART0_C4_OSR field. */
#define BR_UART0_C4_OSR(x)   (BME_UBFX8(HW_UART0_C4_ADDR(x), BP_UART0_C4_OSR, BS_UART0_C4_OSR))

/*! @brief Format value for bitfield UART0_C4_OSR. */
#define BF_UART0_C4_OSR(v)   ((uint8_t)((uint8_t)(v) << BP_UART0_C4_OSR) & BM_UART0_C4_OSR)

/*! @brief Set the OSR field to a new value. */
#define BW_UART0_C4_OSR(x, v) (BME_BFI8(HW_UART0_C4_ADDR(x), ((uint8_t)(v) << BP_UART0_C4_OSR), BP_UART0_C4_OSR, 5))
/*@}*/

/*!
 * @name Register UART0_C4, field M10[5] (RW)
 *
 * The M10 bit causes a tenth bit to be part of the serial transmission. This
 * bit should only be changed when the transmitter and receiver are both disabled.
 *
 * Values:
 * - 0 - Receiver and transmitter use 8-bit or 9-bit data characters.
 * - 1 - Receiver and transmitter use 10-bit data characters.
 */
/*@{*/
#define BP_UART0_C4_M10      (5U)          /*!< Bit position for UART0_C4_M10. */
#define BM_UART0_C4_M10      (0x20U)       /*!< Bit mask for UART0_C4_M10. */
#define BS_UART0_C4_M10      (1U)          /*!< Bit field size in bits for UART0_C4_M10. */

/*! @brief Read current value of the UART0_C4_M10 field. */
#define BR_UART0_C4_M10(x)   (BME_UBFX8(HW_UART0_C4_ADDR(x), BP_UART0_C4_M10, BS_UART0_C4_M10))

/*! @brief Format value for bitfield UART0_C4_M10. */
#define BF_UART0_C4_M10(v)   ((uint8_t)((uint8_t)(v) << BP_UART0_C4_M10) & BM_UART0_C4_M10)

/*! @brief Set the M10 field to a new value. */
#define BW_UART0_C4_M10(x, v) (BME_BFI8(HW_UART0_C4_ADDR(x), ((uint8_t)(v) << BP_UART0_C4_M10), BP_UART0_C4_M10, 1))
/*@}*/

/*!
 * @name Register UART0_C4, field MAEN2[6] (RW)
 *
 * Refer to Match address operation for more information.
 *
 * Values:
 * - 0 - All data received is transferred to the data buffer if MAEN1 is cleared.
 * - 1 - All data received with the most significant bit cleared, is discarded.
 *     All data received with the most significant bit set, is compared with
 *     contents of MA2 register. If no match occurs, the data is discarded. If match
 *     occurs, data is transferred to the data buffer.
 */
/*@{*/
#define BP_UART0_C4_MAEN2    (6U)          /*!< Bit position for UART0_C4_MAEN2. */
#define BM_UART0_C4_MAEN2    (0x40U)       /*!< Bit mask for UART0_C4_MAEN2. */
#define BS_UART0_C4_MAEN2    (1U)          /*!< Bit field size in bits for UART0_C4_MAEN2. */

/*! @brief Read current value of the UART0_C4_MAEN2 field. */
#define BR_UART0_C4_MAEN2(x) (BME_UBFX8(HW_UART0_C4_ADDR(x), BP_UART0_C4_MAEN2, BS_UART0_C4_MAEN2))

/*! @brief Format value for bitfield UART0_C4_MAEN2. */
#define BF_UART0_C4_MAEN2(v) ((uint8_t)((uint8_t)(v) << BP_UART0_C4_MAEN2) & BM_UART0_C4_MAEN2)

/*! @brief Set the MAEN2 field to a new value. */
#define BW_UART0_C4_MAEN2(x, v) (BME_BFI8(HW_UART0_C4_ADDR(x), ((uint8_t)(v) << BP_UART0_C4_MAEN2), BP_UART0_C4_MAEN2, 1))
/*@}*/

/*!
 * @name Register UART0_C4, field MAEN1[7] (RW)
 *
 * Refer to Match address operation for more information.
 *
 * Values:
 * - 0 - All data received is transferred to the data buffer if MAEN2 is cleared.
 * - 1 - All data received with the most significant bit cleared, is discarded.
 *     All data received with the most significant bit set, is compared with
 *     contents of MA1 register. If no match occurs, the data is discarded. If match
 *     occurs, data is transferred to the data buffer.
 */
/*@{*/
#define BP_UART0_C4_MAEN1    (7U)          /*!< Bit position for UART0_C4_MAEN1. */
#define BM_UART0_C4_MAEN1    (0x80U)       /*!< Bit mask for UART0_C4_MAEN1. */
#define BS_UART0_C4_MAEN1    (1U)          /*!< Bit field size in bits for UART0_C4_MAEN1. */

/*! @brief Read current value of the UART0_C4_MAEN1 field. */
#define BR_UART0_C4_MAEN1(x) (BME_UBFX8(HW_UART0_C4_ADDR(x), BP_UART0_C4_MAEN1, BS_UART0_C4_MAEN1))

/*! @brief Format value for bitfield UART0_C4_MAEN1. */
#define BF_UART0_C4_MAEN1(v) ((uint8_t)((uint8_t)(v) << BP_UART0_C4_MAEN1) & BM_UART0_C4_MAEN1)

/*! @brief Set the MAEN1 field to a new value. */
#define BW_UART0_C4_MAEN1(x, v) (BME_BFI8(HW_UART0_C4_ADDR(x), ((uint8_t)(v) << BP_UART0_C4_MAEN1), BP_UART0_C4_MAEN1, 1))
/*@}*/

/*******************************************************************************
 * HW_UART0_C5 - UART Control Register 5
 ******************************************************************************/

/*!
 * @brief HW_UART0_C5 - UART Control Register 5 (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_uart0_c5
{
    uint8_t U;
    struct _hw_uart0_c5_bitfields
    {
        uint8_t RESYNCDIS : 1;         /*!< [0] Resynchronization Disable */
        uint8_t BOTHEDGE : 1;          /*!< [1] Both Edge Sampling */
        uint8_t RESERVED0 : 3;         /*!< [4:2]  */
        uint8_t RDMAE : 1;             /*!< [5] Receiver Full DMA Enable */
        uint8_t RESERVED1 : 1;         /*!< [6]  */
        uint8_t TDMAE : 1;             /*!< [7] Transmitter DMA Enable */
    } B;
} hw_uart0_c5_t;

/*!
 * @name Constants and macros for entire UART0_C5 register
 */
/*@{*/
#define HW_UART0_C5_ADDR(x)      ((x) + 0xBU)

#define HW_UART0_C5(x)           (*(__IO hw_uart0_c5_t *) HW_UART0_C5_ADDR(x))
#define HW_UART0_C5_RD(x)        (HW_UART0_C5(x).U)
#define HW_UART0_C5_WR(x, v)     (HW_UART0_C5(x).U = (v))
#define HW_UART0_C5_SET(x, v)    (BME_OR8(HW_UART0_C5_ADDR(x), (uint8_t)(v)))
#define HW_UART0_C5_CLR(x, v)    (BME_AND8(HW_UART0_C5_ADDR(x), (uint8_t)(~(v))))
#define HW_UART0_C5_TOG(x, v)    (BME_XOR8(HW_UART0_C5_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual UART0_C5 bitfields
 */

/*!
 * @name Register UART0_C5, field RESYNCDIS[0] (RW)
 *
 * When set, disables the resynchronization of the received data word when a
 * data one followed by data zero transition is detected. This bit should only be
 * changed when the receiver is disabled.
 *
 * Values:
 * - 0 - Resynchronization during received data word is supported
 * - 1 - Resynchronization during received data word is disabled
 */
/*@{*/
#define BP_UART0_C5_RESYNCDIS (0U)         /*!< Bit position for UART0_C5_RESYNCDIS. */
#define BM_UART0_C5_RESYNCDIS (0x01U)      /*!< Bit mask for UART0_C5_RESYNCDIS. */
#define BS_UART0_C5_RESYNCDIS (1U)         /*!< Bit field size in bits for UART0_C5_RESYNCDIS. */

/*! @brief Read current value of the UART0_C5_RESYNCDIS field. */
#define BR_UART0_C5_RESYNCDIS(x) (BME_UBFX8(HW_UART0_C5_ADDR(x), BP_UART0_C5_RESYNCDIS, BS_UART0_C5_RESYNCDIS))

/*! @brief Format value for bitfield UART0_C5_RESYNCDIS. */
#define BF_UART0_C5_RESYNCDIS(v) ((uint8_t)((uint8_t)(v) << BP_UART0_C5_RESYNCDIS) & BM_UART0_C5_RESYNCDIS)

/*! @brief Set the RESYNCDIS field to a new value. */
#define BW_UART0_C5_RESYNCDIS(x, v) (BME_BFI8(HW_UART0_C5_ADDR(x), ((uint8_t)(v) << BP_UART0_C5_RESYNCDIS), BP_UART0_C5_RESYNCDIS, 1))
/*@}*/

/*!
 * @name Register UART0_C5, field BOTHEDGE[1] (RW)
 *
 * Enables sampling of the received data on both edges of the baud rate clock,
 * effectively doubling the number of times the receiver samples the input data
 * for a given oversampling ratio. This bit must be set for oversampling ratios
 * between x4 and x7 and is optional for higher oversampling ratios. This bit should
 * only be changed when the receiver is disabled.
 *
 * Values:
 * - 0 - Receiver samples input data using the rising edge of the baud rate
 *     clock.
 * - 1 - Receiver samples input data using the rising and falling edge of the
 *     baud rate clock.
 */
/*@{*/
#define BP_UART0_C5_BOTHEDGE (1U)          /*!< Bit position for UART0_C5_BOTHEDGE. */
#define BM_UART0_C5_BOTHEDGE (0x02U)       /*!< Bit mask for UART0_C5_BOTHEDGE. */
#define BS_UART0_C5_BOTHEDGE (1U)          /*!< Bit field size in bits for UART0_C5_BOTHEDGE. */

/*! @brief Read current value of the UART0_C5_BOTHEDGE field. */
#define BR_UART0_C5_BOTHEDGE(x) (BME_UBFX8(HW_UART0_C5_ADDR(x), BP_UART0_C5_BOTHEDGE, BS_UART0_C5_BOTHEDGE))

/*! @brief Format value for bitfield UART0_C5_BOTHEDGE. */
#define BF_UART0_C5_BOTHEDGE(v) ((uint8_t)((uint8_t)(v) << BP_UART0_C5_BOTHEDGE) & BM_UART0_C5_BOTHEDGE)

/*! @brief Set the BOTHEDGE field to a new value. */
#define BW_UART0_C5_BOTHEDGE(x, v) (BME_BFI8(HW_UART0_C5_ADDR(x), ((uint8_t)(v) << BP_UART0_C5_BOTHEDGE), BP_UART0_C5_BOTHEDGE, 1))
/*@}*/

/*!
 * @name Register UART0_C5, field RDMAE[5] (RW)
 *
 * RDMAE configures the receiver data register full flag, S1[RDRF], to generate
 * a DMA request.
 *
 * Values:
 * - 0 - DMA request disabled.
 * - 1 - DMA request enabled.
 */
/*@{*/
#define BP_UART0_C5_RDMAE    (5U)          /*!< Bit position for UART0_C5_RDMAE. */
#define BM_UART0_C5_RDMAE    (0x20U)       /*!< Bit mask for UART0_C5_RDMAE. */
#define BS_UART0_C5_RDMAE    (1U)          /*!< Bit field size in bits for UART0_C5_RDMAE. */

/*! @brief Read current value of the UART0_C5_RDMAE field. */
#define BR_UART0_C5_RDMAE(x) (BME_UBFX8(HW_UART0_C5_ADDR(x), BP_UART0_C5_RDMAE, BS_UART0_C5_RDMAE))

/*! @brief Format value for bitfield UART0_C5_RDMAE. */
#define BF_UART0_C5_RDMAE(v) ((uint8_t)((uint8_t)(v) << BP_UART0_C5_RDMAE) & BM_UART0_C5_RDMAE)

/*! @brief Set the RDMAE field to a new value. */
#define BW_UART0_C5_RDMAE(x, v) (BME_BFI8(HW_UART0_C5_ADDR(x), ((uint8_t)(v) << BP_UART0_C5_RDMAE), BP_UART0_C5_RDMAE, 1))
/*@}*/

/*!
 * @name Register UART0_C5, field TDMAE[7] (RW)
 *
 * TDMAE configures the transmit data register empty flag, S1[TDRE], to generate
 * a DMA request.
 *
 * Values:
 * - 0 - DMA request disabled.
 * - 1 - DMA request enabled.
 */
/*@{*/
#define BP_UART0_C5_TDMAE    (7U)          /*!< Bit position for UART0_C5_TDMAE. */
#define BM_UART0_C5_TDMAE    (0x80U)       /*!< Bit mask for UART0_C5_TDMAE. */
#define BS_UART0_C5_TDMAE    (1U)          /*!< Bit field size in bits for UART0_C5_TDMAE. */

/*! @brief Read current value of the UART0_C5_TDMAE field. */
#define BR_UART0_C5_TDMAE(x) (BME_UBFX8(HW_UART0_C5_ADDR(x), BP_UART0_C5_TDMAE, BS_UART0_C5_TDMAE))

/*! @brief Format value for bitfield UART0_C5_TDMAE. */
#define BF_UART0_C5_TDMAE(v) ((uint8_t)((uint8_t)(v) << BP_UART0_C5_TDMAE) & BM_UART0_C5_TDMAE)

/*! @brief Set the TDMAE field to a new value. */
#define BW_UART0_C5_TDMAE(x, v) (BME_BFI8(HW_UART0_C5_ADDR(x), ((uint8_t)(v) << BP_UART0_C5_TDMAE), BP_UART0_C5_TDMAE, 1))
/*@}*/

/*******************************************************************************
 * hw_uart0_t - module struct
 ******************************************************************************/
/*!
 * @brief All UART0 module registers.
 */
#pragma pack(1)
typedef struct _hw_uart0
{
    __IO hw_uart0_bdh_t BDH;               /*!< [0x0] UART Baud Rate Register High */
    __IO hw_uart0_bdl_t BDL;               /*!< [0x1] UART Baud Rate Register Low */
    __IO hw_uart0_c1_t C1;                 /*!< [0x2] UART Control Register 1 */
    __IO hw_uart0_c2_t C2;                 /*!< [0x3] UART Control Register 2 */
    __IO hw_uart0_s1_t S1;                 /*!< [0x4] UART Status Register 1 */
    __IO hw_uart0_s2_t S2;                 /*!< [0x5] UART Status Register 2 */
    __IO hw_uart0_c3_t C3;                 /*!< [0x6] UART Control Register 3 */
    __IO hw_uart0_d_t D;                   /*!< [0x7] UART Data Register */
    __IO hw_uart0_ma1_t MA1;               /*!< [0x8] UART Match Address Registers 1 */
    __IO hw_uart0_ma2_t MA2;               /*!< [0x9] UART Match Address Registers 2 */
    __IO hw_uart0_c4_t C4;                 /*!< [0xA] UART Control Register 4 */
    __IO hw_uart0_c5_t C5;                 /*!< [0xB] UART Control Register 5 */
} hw_uart0_t;
#pragma pack()

/*! @brief Macro to access all UART0 registers. */
/*! @param x UART0 module instance base address. */
/*! @return Reference (not a pointer) to the registers struct. To get a pointer to the struct,
 *     use the '&' operator, like <code>&HW_UART0(UART0_BASE)</code>. */
#define HW_UART0(x)    (*(hw_uart0_t *)(x))

#endif /* __HW_UART0_REGISTERS_H__ */
/* v33/140401/2.1.0 */
/* EOF */
